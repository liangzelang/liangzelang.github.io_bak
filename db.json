{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1496071375885},{"_id":"source/CNAME","hash":"f750fbe056777576c7db3d05d649daac1ac63283","modified":1496071375881},{"_id":"themes/landscape/.npmignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1496071375885},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1496071375885},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1496071375885},{"_id":"themes/landscape/README.md","hash":"c7e83cfe8f2c724fc9cac32bd71bb5faf9ceeddb","modified":1496071375885},{"_id":"themes/landscape/_config.yml","hash":"dcda391c56f5e036ff85b80da65de482fdf42824","modified":1496071375885},{"_id":"themes/landscape/package.json","hash":"85358dc34311c6662e841584e206a4679183943f","modified":1496071375889},{"_id":"source/_drafts/模板函数的优先序列.md","hash":"1c22213a8fd7a00e3c7c0a14751da4fc19cf6941","modified":1496071375881},{"_id":"source/_drafts/虚函数的工作原理.md~","hash":"9d22f2e0f23e052b26becc723f8c3d8dd22cea51","modified":1496071375881},{"_id":"source/about/index.md","hash":"9251b6093b29ac1f63639690917c14e29f467bc6","modified":1496071375885},{"_id":"source/about/index.md~","hash":"e5e709fb425fd8a0eabf9f61dbe93bd36aa684c3","modified":1496071375885},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1496071375889},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1496071375889},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1496071375889},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1496071375889},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1496071375889},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1496071375889},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1496071375889},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1496071375885},{"_id":"themes/landscape/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1496071375885},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1496071375885},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1496071375885},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1496071375885},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1496071375885},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1496071375885},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1496071375889},{"_id":"source/_posts/CPP/CPP中如何输出char型指针地址.md","hash":"0cd6829becb775c7ca10f7208ae25c5d66d521ab","modified":1496071375885},{"_id":"source/_posts/CPP/C-指针注意事项.md","hash":"af5db9a380834186fb4588b0218085be1cdf587e","modified":1496071375885},{"_id":"source/_posts/CPP/c-成员运算符.md","hash":"9b3d3aa0d269761ebd0ac876169f2b108d8a2944","modified":1496071375885},{"_id":"source/_posts/CPP/sizeof-和-strlen的区别.md","hash":"a1cf2acf177a9e329764917b8a7a4aecdc8368ee","modified":1496071375885},{"_id":"source/_posts/CPP/友元、异常和其他问题.md","hash":"0017a6b8de29eaf73eac8126e9e507aefe740aa2","modified":1496067118437},{"_id":"source/_posts/CPP/模板的具体化和实例化.md","hash":"a17cda40943b72101886817af5807b13930b5331","modified":1496071375885},{"_id":"source/_posts/CPP/派生类与基类之间的特殊关系.md","hash":"7f6c641f0411deffef7461dc1d3092b881ab1dea","modified":1496071375885},{"_id":"source/_posts/CPP/虚函数的工作原理.md","hash":"0ce5e47ecf13f63ca328d987b78cc5679fa32d0f","modified":1496071375885},{"_id":"source/_posts/CPP/虚析构函数的作用.md","hash":"0e1e79fc8b5cd9267abe97f22c347a35c5c42150","modified":1496071375885},{"_id":"source/_posts/Leetcode/1-two-sum.md","hash":"128ec5c1677638e3ff31dd884302ff0310710cc3","modified":1496071375885},{"_id":"source/_posts/Leetcode/202-happy-number-md.md","hash":"ab09836a4cfdd9ff9f7d50195accdbad2d509243","modified":1496071375885},{"_id":"source/_posts/Leetcode/412-fizz-buzz-md.md","hash":"d34f163e22af30bee3c8090e78a533ff63a7ea45","modified":1496071375885},{"_id":"source/_posts/Leetcode/414-the-third-maxium-number.md","hash":"27f44c26d27457628dcc3072ae16e2a8c9ea8081","modified":1496071375885},{"_id":"source/_posts/Leetcode/442-find-all-duplicates-in-an-array-md.md","hash":"21773be69cf60e761bb047b9e081116350d8fe31","modified":1496071375885},{"_id":"source/_posts/Leetcode/461-hamming-distance-md.md","hash":"120533c21fdfeac640877f29648877257761d6d1","modified":1496071375885},{"_id":"source/_posts/Summary/New-Begining.md","hash":"367e8788ccc08e6eb8e4e4bde90bae97d353559b","modified":1496071375885},{"_id":"source/_posts/Summary/test.md","hash":"fc4bb1df05ee6f30a3d11edfa147f2ea70a37b0b","modified":1496071375885},{"_id":"source/_posts/Linux_shell/Linux下gedit打开文件产生带波浪号（～）的备份文件.md","hash":"b29f00c6f868157cf492b733504997fdd2779d0a","modified":1496071375885},{"_id":"source/_posts/OpenCV/HigtGUI的初识.md","hash":"eb23a9651ff45d7f7cdfc533dbb3b8ccd5dcbd57","modified":1496071375885},{"_id":"source/_posts/OpenCV/HigtGUI的初识.md~","hash":"ddf796d1197bb0ee0e51f502fbe92c601bf7ea82","modified":1496071375885},{"_id":"source/_posts/OpenCV/OpenCV数据结构与基本绘图.md","hash":"6d3319ea2d6171f3e85a9104056ee2be09ad1f9c","modified":1496071375885},{"_id":"source/_posts/OpenCV/OpenCV数据结构与基本绘图.md~","hash":"56b754f74467e21ce3a57143a5db9e20dfa00337","modified":1496071375885},{"_id":"source/_posts/OpenCV/VS2010+OpenCV2.4.10的安装与配置.md","hash":"7cd2fef96f34e6f5a72d7f87d48bf6c3667d412f","modified":1496071375885},{"_id":"source/_posts/OpenCV/VS2010+OpenCV2.4.10的安装与配置.md~","hash":"09c8f540e8b556c18a172b059a537a733dd3dff8","modified":1496071375885},{"_id":"source/_posts/OpenCV/post-1.md~","hash":"611a681de8772a1cad4e41d3c53be070e1b9370e","modified":1496071375885},{"_id":"source/_posts/OpenCV/post.md~","hash":"11164fbfb5c6c6cb419b607c030b1b38a726d475","modified":1496071375885},{"_id":"source/_posts/OpenCV/【OpenCV基础】core组件进阶.md~","hash":"14b0b1ded3af33f076a6e568fb189bb76d4d5772","modified":1496071375885},{"_id":"source/_posts/OpenCV/core组件进阶.md","hash":"4131695c60e52da7b526d3fb26df3d2eba99b163","modified":1496071375885},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"82a30f81c0e8ba4a8af17acd6cc99e93834e4d5e","modified":1496071375885},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1496071375885},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"931aaaffa0910a48199388ede576184ff15793ee","modified":1496071375885},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"99ca4225a5d7fdc5673f856e0e9536a681420861","modified":1496071375889},{"_id":"themes/landscape/layout/_partial/article.ejs~","hash":"c4d830ac25d61ae64fc0a3906c4511139d21754b","modified":1496071375889},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1496071375889},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"4fe8853e864d192701c03e5cd3a5390287b90612","modified":1496071375889},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1496071375889},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"c21ca56f419d01a9f49c27b6be9f4a98402b2aa3","modified":1496071375889},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1496071375889},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1496071375889},{"_id":"themes/landscape/layout/_widget/about.ejs","hash":"3d89c97a4c1425f1c4f0b30be4f711ef96d50a26","modified":1496071375889},{"_id":"themes/landscape/layout/_widget/about.ejs~","hash":"0f57b15277fe78db839823009eba459baa0ce8cb","modified":1496071375889},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1496071375889},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1496071375889},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1496071375889},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1496071375889},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1496071375889},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1496071375889},{"_id":"themes/landscape/source/css/_variables.styl","hash":"5e37a6571caf87149af83ac1cc0cdef99f117350","modified":1496071375889},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1496071375897},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1496071375897},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1496071375897},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1496071375897},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1496071375897},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1496071375897},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1496071375897},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1496071375897},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1496071375897},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1496071375897},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1496071375897},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1496071375889},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1496071375889},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1496071375889},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1496071375889},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1496071375889},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1496071375889},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1496071375889},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1496071375889},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1496071375889},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1496071375889},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1496071375889},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1496071375889},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1496071375889},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1496071375889},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1496071375889},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1496071375889},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1496071375889},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1496071375889},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1496071375893},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1496071375893},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1496071375893},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1496071375897},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1496071375897},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1496071375897},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1496071375897},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1496071375897},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1496071375897},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1496071375893},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1496071375897},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1496071375893},{"_id":"public/2017/03/28/OpenCV/core组件进阶/index.html","hash":"13ea0f7f9750e7e206a0ed325b9d3b24976ec3d1","modified":1496071918004},{"_id":"public/about/index.html","hash":"fa4663ae23bc194d6df562027a136775cee2c7c3","modified":1496071918005},{"_id":"public/2017/03/12/CPP/虚析构函数的作用/index.html","hash":"e5ff2dd54172f67a878d39a48d4764ef1c31d33a","modified":1496071918006},{"_id":"public/2017/03/12/CPP/模板的具体化和实例化/index.html","hash":"a9f97201697df278ecb743f2c908e78192c82115","modified":1496071918006},{"_id":"public/2017/03/12/CPP/CPP中如何输出char型指针地址/index.html","hash":"dad023f6297723c1e3aa164083b9e50f17cf9a89","modified":1496071918006},{"_id":"public/2017/03/12/CPP/派生类与基类之间的特殊关系/index.html","hash":"7050786d30158eeafb22521c3a2d4ec7ddafba55","modified":1496071918006},{"_id":"public/2016/12/29/CPP/c-成员运算符/index.html","hash":"dd76f06f1bc369a07d1305495b21e7a8a70fab08","modified":1496071918006},{"_id":"public/2016/12/29/CPP/sizeof-和-strlen的区别/index.html","hash":"0f35139e054536091fb70f0a5c8597282a5c13bb","modified":1496071918008},{"_id":"public/2016/12/29/CPP/C-指针注意事项/index.html","hash":"8c1bafe9339922d46b2b65ae0504bd92ef12243d","modified":1496071918008},{"_id":"public/2016/12/26/Leetcode/1-two-sum/index.html","hash":"7902afcefefa7f35ce533e77e510eab7298e9d39","modified":1496071918008},{"_id":"public/2016/12/23/Leetcode/202-happy-number-md/index.html","hash":"e257fb60967357bf9229baefe5304b3d09dcaa4d","modified":1496071918008},{"_id":"public/2016/12/20/Linux_shell/Linux下gedit打开文件产生带波浪号（～）的备份文件/index.html","hash":"b88c7ac0a044d1d4731a4a19a5e1c63a439c05cf","modified":1496071918008},{"_id":"public/2016/09/21/Summary/test/index.html","hash":"6a4f80a66871ed3b8c8e69094ef8d1d2cf697deb","modified":1496071918008},{"_id":"public/2016/07/20/Summary/New-Begining/index.html","hash":"b01bba8c2be14b2a7c9624768c7c6c11d08a9662","modified":1496071918009},{"_id":"public/categories/技术/index.html","hash":"e4afc889323f9c6627089c52e7a8fcf76fc9d696","modified":1496071918009},{"_id":"public/categories/技术/page/2/index.html","hash":"97a498eb6a6be092250b45e8df588900e82220c8","modified":1496071918009},{"_id":"public/categories/技术/page/3/index.html","hash":"bdf074bd8365d36c1cd08d7e2344bccf9a83a948","modified":1496071918009},{"_id":"public/categories/生活/index.html","hash":"686ad9dbce796f4536808b81dc7b045ce7900259","modified":1496071918009},{"_id":"public/archives/index.html","hash":"e8f5c1421d993e7f91502d18362ece4485e076d4","modified":1496071918009},{"_id":"public/archives/page/2/index.html","hash":"07ea9963dcd64bfce684b1bfbb28e33d70bff89b","modified":1496071918010},{"_id":"public/archives/2016/index.html","hash":"49f554f122914fd34cd061ff71607dc447e183d7","modified":1496071918011},{"_id":"public/archives/page/3/index.html","hash":"0087dabafdf73b852bfe35ae2d3d24ee97e24a87","modified":1496071918011},{"_id":"public/archives/2016/page/2/index.html","hash":"b2f370216a8ce114c9b51081ddf3b5e46cda57a2","modified":1496071918011},{"_id":"public/archives/2016/07/index.html","hash":"e38528a60a07c6d8fad2f58333728a33b379a064","modified":1496071918011},{"_id":"public/archives/2016/09/index.html","hash":"6266af93960094d7ac1a5ff18db84d11794f846e","modified":1496071918011},{"_id":"public/archives/2016/12/index.html","hash":"d49a01eaaff86d2cec04f290feabb1aa12e792b4","modified":1496071918011},{"_id":"public/archives/2017/index.html","hash":"4c702790846742a271df078b62e63d549aeef02c","modified":1496071918011},{"_id":"public/archives/2017/03/index.html","hash":"b4b0ed093a42e9d91c6369af1e341d07d2d00113","modified":1496071918011},{"_id":"public/archives/2017/05/index.html","hash":"42c421391229511245f7894385b5ea1deff6608b","modified":1496071918011},{"_id":"public/page/3/index.html","hash":"568bf4bddacbd28f7be8b319f6849ff52ac0bca4","modified":1496071918011},{"_id":"public/tags/c/index.html","hash":"5b3931faea044fac1a444af9484597975746d467","modified":1496071918012},{"_id":"public/tags/c/page/2/index.html","hash":"299e64660dcbf087b524b3c360c1ef981728bd83","modified":1496071918012},{"_id":"public/tags/leetcode/index.html","hash":"2148903f00c0091e55f159d2651fe62043f6a83e","modified":1496071918012},{"_id":"public/tags/数据结构与算法/index.html","hash":"7374d872c56882dfbbd561099fde8e980b439e95","modified":1496071918012},{"_id":"public/tags/随笔/index.html","hash":"36cd94b4c115df369e3e7fa19a79de318d2b06dc","modified":1496071918012},{"_id":"public/tags/hexo/index.html","hash":"0e067766658dbef9fa6a1bee329420060980fad7","modified":1496071918013},{"_id":"public/tags/OpenCV基础/index.html","hash":"1a3bd759d3fe91a3a17354e7d91d3c60a01f0145","modified":1496071918013},{"_id":"public/tags/Linux/index.html","hash":"90be0bbbb574cc245b0e09532de8cd14687a4928","modified":1496071918013},{"_id":"public/tags/VS2010/index.html","hash":"531de6703bc01f11164eef7661db2c7424108c36","modified":1496071918013},{"_id":"public/2017/05/29/CPP/友元、异常和其他问题/index.html","hash":"882e8955b6d5ce7329e3378056b2403e6e29483f","modified":1496071918013},{"_id":"public/2017/03/28/OpenCV/OpenCV数据结构与基本绘图/index.html","hash":"2007ed5ffba6008eb459a639c3cbf228a6784c3c","modified":1496071918013},{"_id":"public/2017/03/12/CPP/虚函数的工作原理/index.html","hash":"c22e71e334c8fe5f64332b8937d0969e1977aefe","modified":1496071918013},{"_id":"public/2017/03/01/OpenCV/HigtGUI的初识/index.html","hash":"af7313db52489489a925afe3b1125035004f3424","modified":1496071918014},{"_id":"public/2016/12/28/Leetcode/414-the-third-maxium-number/index.html","hash":"fc3bb6ff12267925c37081360605aa585db02810","modified":1496071918014},{"_id":"public/2016/12/23/Leetcode/461-hamming-distance-md/index.html","hash":"36c937431f4dff522509821bddcc675b435dc253","modified":1496071918014},{"_id":"public/2016/12/23/Leetcode/442-find-all-duplicates-in-an-array-md/index.html","hash":"b0598be138f9831d96f076a6014e3141ac0a5da0","modified":1496071918014},{"_id":"public/2016/12/23/Leetcode/412-fizz-buzz-md/index.html","hash":"ec933cb8f2b8495f56d050d0f6e2554918bdc93b","modified":1496071918014},{"_id":"public/2016/09/25/OpenCV/VS2010+OpenCV2.4.10的安装与配置/index.html","hash":"323a3b3a9f68151cd341488c937eb2414ab22eb8","modified":1496071918014},{"_id":"public/index.html","hash":"07b9a57c1c29ac7a14d56a213c82414e95b69bca","modified":1496071918015},{"_id":"public/page/2/index.html","hash":"1474ac1de13e06dff7efe01e6affe70bf0e7636f","modified":1496071918015},{"_id":"public/CNAME","hash":"f750fbe056777576c7db3d05d649daac1ac63283","modified":1496071918033},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1496071918033},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1496071918033},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1496071918034},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1496071918034},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1496071918034},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1496071918034},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1496071918034},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1496071918034},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1496071918034},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1496071918034},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1496071919365},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1496071919388},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1496071919388},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1496071919388},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1496071919388},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1496071919389},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1496071919389},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1496071919389},{"_id":"public/css/style.css","hash":"11c9f812d2e2c9f4980553c78844522fa960a413","modified":1496071919389},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1496071919389},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1496071919389},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1496071919399},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1496071919399}],"Category":[{"name":"技术","_id":"cj3aal9pb0003094uts32741o"},{"name":"生活","_id":"cj3aal9u2001f094urxn0gt8q"}],"Data":[],"Page":[{"title":"关于我（About）","date":"2016-07-27T12:35:34.000Z","_content":"***\n## Zelang Liang(梁泽浪)\n\n***\n<img src=\"http://oapeb119y.bkt.clouddn.com/IMG_20160921_193937.jpg\" alt=\"Zelang Liang\" height=\"300\" width=\"400\">\n***\n\n## 个人介绍\n\n个人喜欢机器视觉、图像处理、机器学习等知识领域\n\n目前在实验室研究的方向和自己的兴趣相差很大，所以自己只有自学了，不能实验室项目增长个人技能，反倒是有点浪费时间。\n\n现在在积极充实自己的技能包：\n  C | C++ | Python | Shell | Linux | Matlab | Markdown | OpenCV\n \n## 教育背景\n2016.09-         北京理工大学（模式识别与智能系统）\n2011.09-2015.07  吉林大学（自动化） \n\n\n## 目标\n\n在有限的硕士研究生生涯中，把握好每一天，扩宽胸怀、提高眼界、增长胆识和充实技能\n\n能有一天进入心仪的公司，用技术在历史的长河中留下属于自己的印记\n\n## 链接\n\n+ [Github](https://github.com/liangzelang)\n\n\n\n","source":"about/index.md","raw":"---\ntitle: 关于我（About）\ndate: 2016-07-27 20:35:34\n---\n***\n## Zelang Liang(梁泽浪)\n\n***\n<img src=\"http://oapeb119y.bkt.clouddn.com/IMG_20160921_193937.jpg\" alt=\"Zelang Liang\" height=\"300\" width=\"400\">\n***\n\n## 个人介绍\n\n个人喜欢机器视觉、图像处理、机器学习等知识领域\n\n目前在实验室研究的方向和自己的兴趣相差很大，所以自己只有自学了，不能实验室项目增长个人技能，反倒是有点浪费时间。\n\n现在在积极充实自己的技能包：\n  C | C++ | Python | Shell | Linux | Matlab | Markdown | OpenCV\n \n## 教育背景\n2016.09-         北京理工大学（模式识别与智能系统）\n2011.09-2015.07  吉林大学（自动化） \n\n\n## 目标\n\n在有限的硕士研究生生涯中，把握好每一天，扩宽胸怀、提高眼界、增长胆识和充实技能\n\n能有一天进入心仪的公司，用技术在历史的长河中留下属于自己的印记\n\n## 链接\n\n+ [Github](https://github.com/liangzelang)\n\n\n\n","updated":"2017-05-29T15:22:55.885Z","path":"about/index.html","comments":1,"layout":"page","_id":"cj3aal9p10001094u364t5or9","content":"<hr>\n<h2 id=\"Zelang-Liang-梁泽浪\"><a href=\"#Zelang-Liang-梁泽浪\" class=\"headerlink\" title=\"Zelang Liang(梁泽浪)\"></a>Zelang Liang(梁泽浪)</h2><hr>\n<p><img src=\"http://oapeb119y.bkt.clouddn.com/IMG_20160921_193937.jpg\" alt=\"Zelang Liang\" height=\"300\" width=\"400\"></p>\n<hr>\n<h2 id=\"个人介绍\"><a href=\"#个人介绍\" class=\"headerlink\" title=\"个人介绍\"></a>个人介绍</h2><p>个人喜欢机器视觉、图像处理、机器学习等知识领域</p>\n<p>目前在实验室研究的方向和自己的兴趣相差很大，所以自己只有自学了，不能实验室项目增长个人技能，反倒是有点浪费时间。</p>\n<p>现在在积极充实自己的技能包：<br>  C | C++ | Python | Shell | Linux | Matlab | Markdown | OpenCV</p>\n<h2 id=\"教育背景\"><a href=\"#教育背景\" class=\"headerlink\" title=\"教育背景\"></a>教育背景</h2><p>2016.09-         北京理工大学（模式识别与智能系统）<br>2011.09-2015.07  吉林大学（自动化） </p>\n<h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><p>在有限的硕士研究生生涯中，把握好每一天，扩宽胸怀、提高眼界、增长胆识和充实技能</p>\n<p>能有一天进入心仪的公司，用技术在历史的长河中留下属于自己的印记</p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><ul>\n<li><a href=\"https://github.com/liangzelang\" target=\"_blank\" rel=\"external\">Github</a></li>\n</ul>\n","excerpt":"","more":"<hr>\n<h2 id=\"Zelang-Liang-梁泽浪\"><a href=\"#Zelang-Liang-梁泽浪\" class=\"headerlink\" title=\"Zelang Liang(梁泽浪)\"></a>Zelang Liang(梁泽浪)</h2><hr>\n<p><img src=\"http://oapeb119y.bkt.clouddn.com/IMG_20160921_193937.jpg\" alt=\"Zelang Liang\" height=\"300\" width=\"400\"></p>\n<hr>\n<h2 id=\"个人介绍\"><a href=\"#个人介绍\" class=\"headerlink\" title=\"个人介绍\"></a>个人介绍</h2><p>个人喜欢机器视觉、图像处理、机器学习等知识领域</p>\n<p>目前在实验室研究的方向和自己的兴趣相差很大，所以自己只有自学了，不能实验室项目增长个人技能，反倒是有点浪费时间。</p>\n<p>现在在积极充实自己的技能包：<br>  C | C++ | Python | Shell | Linux | Matlab | Markdown | OpenCV</p>\n<h2 id=\"教育背景\"><a href=\"#教育背景\" class=\"headerlink\" title=\"教育背景\"></a>教育背景</h2><p>2016.09-         北京理工大学（模式识别与智能系统）<br>2011.09-2015.07  吉林大学（自动化） </p>\n<h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><p>在有限的硕士研究生生涯中，把握好每一天，扩宽胸怀、提高眼界、增长胆识和充实技能</p>\n<p>能有一天进入心仪的公司，用技术在历史的长河中留下属于自己的印记</p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><ul>\n<li><a href=\"https://github.com/liangzelang\">Github</a></li>\n</ul>\n"}],"Post":[{"title":"模板函数的优先序列","date":"2017-03-11T23:08:54.000Z","comments":1,"_content":"\n# 编译器选择哪个函数版本去执行任务？\nC++中有函数重载、函数模板、函数模板重载，那么在使用调用函数时，到底具体是使用的哪一个函数定义呢？？？这就是 重载解析（overloading resolution）。\n","source":"_drafts/模板函数的优先序列.md","raw":"---\ntitle: 模板函数的优先序列\ndate: 2017-03-12 07:08:54\ncategories:\n- 技术\ntags:\n- c++\ncomments: true\n---\n\n# 编译器选择哪个函数版本去执行任务？\nC++中有函数重载、函数模板、函数模板重载，那么在使用调用函数时，到底具体是使用的哪一个函数定义呢？？？这就是 重载解析（overloading resolution）。\n","slug":"模板函数的优先序列","published":0,"updated":"2017-05-29T15:22:55.881Z","layout":"post","photos":[],"link":"","_id":"cj3aal9on0000094udaohbdch","content":"<h1 id=\"编译器选择哪个函数版本去执行任务？\"><a href=\"#编译器选择哪个函数版本去执行任务？\" class=\"headerlink\" title=\"编译器选择哪个函数版本去执行任务？\"></a>编译器选择哪个函数版本去执行任务？</h1><p>C++中有函数重载、函数模板、函数模板重载，那么在使用调用函数时，到底具体是使用的哪一个函数定义呢？？？这就是 重载解析（overloading resolution）。</p>\n","excerpt":"","more":"<h1 id=\"编译器选择哪个函数版本去执行任务？\"><a href=\"#编译器选择哪个函数版本去执行任务？\" class=\"headerlink\" title=\"编译器选择哪个函数版本去执行任务？\"></a>编译器选择哪个函数版本去执行任务？</h1><p>C++中有函数重载、函数模板、函数模板重载，那么在使用调用函数时，到底具体是使用的哪一个函数定义呢？？？这就是 重载解析（overloading resolution）。</p>\n"},{"title":"sizeof和strlen的区别","date":"2016-12-29T15:39:01.000Z","comments":1,"_content":"\n在一些场景下,希望得到数组的大小，字符串的长度，char型数组的长度等等，很自然想到sizeof以及strlen,但是非常容易搞混弄错.下面简要列出一些区别：\n\n1. sizeof操作符的结果类型是size_t，它在头文件中typedef为unsigned int类型。\n该类型保证能容纳实现所建立的最大对象的字节大小。 \n\n2. sizeof是操作符，strlen是函数。 \n\n3. sizeof可以用类型做参数，strlen只能用char*做参数，且必须是以''\\0''结尾的。\nsizeof还可以用函数做参数，比如： \n```\nshort f();\nprintf(\"%d\\n\", sizeof(f()));\n```\n输出的结果是 `sizeof(short)` ，即2。 \n\n<!--more-->\n4. 数组做sizeof的参数不退化，传递给strlen就退化为指针了。 \n\n5. 大部分编译程序 在编译的时候就把sizeof计算过了 是类型或是变量的长度这就是sizeof(x)可以用来定义数组维数的原因 \n```\nchar str[20]=\"0123456789\";\nint a=strlen(str); //a=10;\nint b=sizeof(str); //而b=20;\n```\n6. strlen的结果要在运行的时候才能计算出来，时用来计算字符串的长度，不是类型占内存的大小。 \n\n7. sizeof后如果是类型必须加括弧，如果是变量名可以不加括弧。这是因为sizeof是个操作符不是个函数。\n\n8. 当适用了于一个结构类型时或变量， sizeof 返回实际的大小，\n当适用一静态地空间数组， sizeof 归还全部数组的尺寸。\nsizeof 操作符不能返回动态地被分派了的数组或外部的数组的尺寸 \n\n9. 数组作为参数传给函数时传的是指针而不是数组，传递的是数组的首地址，\n如：\n``` \nfun(char [8])\nfun(char [])\n都等价于 fun(char *)\n``` \n在C++里参数传递数组永远都是传递指向数组首元素的指针，编译器不知道数组的大小\n如果想在函数内知道数组的大小， 需要这样做：\n进入函数后用memcpy拷贝出来，长度由另一个形参传进去 \n```\nfun(unsiged char *p1, int len)\n{\n  unsigned char* buf = new unsigned char[len+1]\n  memcpy(buf, p1, len);\n}\n```\n我们能常在用到 sizeof 和 strlen 的时候，通常是计算字符串数组的长度\n看了上面的详细解释，发现两者的使用还是有区别的，从这个例子可以看得很清楚：\n```\nchar str[20]=\"0123456789\";\nint a=strlen(str); //a=10; >>>> strlen 计算字符串的长度，以结束符 0x00 为字符串结束。\nint b=sizeof(str); //而b=20; >>>> sizeof 计算的则是分配的数组 str[20] 所占的内存空间的大小，不受里面存储的内容改变。  \n```\n上面是对静态数组处理的结果，如果是对指针，结果就不一样了\n`char* ss = \"0123456789\";`\n`sizeof(ss)` 结果 4 ＝＝＝》ss是指向字符串常量的字符指针，sizeof 获得的是一个指针的之所占的空间,应该是长整型的，所以是4\n`sizeof(*ss)` 结果 1 ＝＝＝》*ss是第一个字符 其实就是获得了字符串的第一位'0' 所占的内存空间，是char类型的，占了 1 位\n`strlen(ss)= 10` >>>> 如果要获得这个字符串的长度，则一定要使用 strlen\n","source":"_posts/CPP/sizeof-和-strlen的区别.md","raw":"---\ntitle: sizeof和strlen的区别\ndate: 2016-12-29 23:39:01\ncategories:\n- 技术\ntags:\n- c++\ncomments: true\n---\n\n在一些场景下,希望得到数组的大小，字符串的长度，char型数组的长度等等，很自然想到sizeof以及strlen,但是非常容易搞混弄错.下面简要列出一些区别：\n\n1. sizeof操作符的结果类型是size_t，它在头文件中typedef为unsigned int类型。\n该类型保证能容纳实现所建立的最大对象的字节大小。 \n\n2. sizeof是操作符，strlen是函数。 \n\n3. sizeof可以用类型做参数，strlen只能用char*做参数，且必须是以''\\0''结尾的。\nsizeof还可以用函数做参数，比如： \n```\nshort f();\nprintf(\"%d\\n\", sizeof(f()));\n```\n输出的结果是 `sizeof(short)` ，即2。 \n\n<!--more-->\n4. 数组做sizeof的参数不退化，传递给strlen就退化为指针了。 \n\n5. 大部分编译程序 在编译的时候就把sizeof计算过了 是类型或是变量的长度这就是sizeof(x)可以用来定义数组维数的原因 \n```\nchar str[20]=\"0123456789\";\nint a=strlen(str); //a=10;\nint b=sizeof(str); //而b=20;\n```\n6. strlen的结果要在运行的时候才能计算出来，时用来计算字符串的长度，不是类型占内存的大小。 \n\n7. sizeof后如果是类型必须加括弧，如果是变量名可以不加括弧。这是因为sizeof是个操作符不是个函数。\n\n8. 当适用了于一个结构类型时或变量， sizeof 返回实际的大小，\n当适用一静态地空间数组， sizeof 归还全部数组的尺寸。\nsizeof 操作符不能返回动态地被分派了的数组或外部的数组的尺寸 \n\n9. 数组作为参数传给函数时传的是指针而不是数组，传递的是数组的首地址，\n如：\n``` \nfun(char [8])\nfun(char [])\n都等价于 fun(char *)\n``` \n在C++里参数传递数组永远都是传递指向数组首元素的指针，编译器不知道数组的大小\n如果想在函数内知道数组的大小， 需要这样做：\n进入函数后用memcpy拷贝出来，长度由另一个形参传进去 \n```\nfun(unsiged char *p1, int len)\n{\n  unsigned char* buf = new unsigned char[len+1]\n  memcpy(buf, p1, len);\n}\n```\n我们能常在用到 sizeof 和 strlen 的时候，通常是计算字符串数组的长度\n看了上面的详细解释，发现两者的使用还是有区别的，从这个例子可以看得很清楚：\n```\nchar str[20]=\"0123456789\";\nint a=strlen(str); //a=10; >>>> strlen 计算字符串的长度，以结束符 0x00 为字符串结束。\nint b=sizeof(str); //而b=20; >>>> sizeof 计算的则是分配的数组 str[20] 所占的内存空间的大小，不受里面存储的内容改变。  \n```\n上面是对静态数组处理的结果，如果是对指针，结果就不一样了\n`char* ss = \"0123456789\";`\n`sizeof(ss)` 结果 4 ＝＝＝》ss是指向字符串常量的字符指针，sizeof 获得的是一个指针的之所占的空间,应该是长整型的，所以是4\n`sizeof(*ss)` 结果 1 ＝＝＝》*ss是第一个字符 其实就是获得了字符串的第一位'0' 所占的内存空间，是char类型的，占了 1 位\n`strlen(ss)= 10` >>>> 如果要获得这个字符串的长度，则一定要使用 strlen\n","slug":"CPP/sizeof-和-strlen的区别","published":1,"updated":"2017-05-29T15:22:55.885Z","layout":"post","photos":[],"link":"","_id":"cj3aal9rc0006094ux3d2tgiu","content":"<p>在一些场景下,希望得到数组的大小，字符串的长度，char型数组的长度等等，很自然想到sizeof以及strlen,但是非常容易搞混弄错.下面简要列出一些区别：</p>\n<ol>\n<li><p>sizeof操作符的结果类型是size_t，它在头文件中typedef为unsigned int类型。<br>该类型保证能容纳实现所建立的最大对象的字节大小。 </p>\n</li>\n<li><p>sizeof是操作符，strlen是函数。 </p>\n</li>\n<li><p>sizeof可以用类型做参数，strlen只能用char*做参数，且必须是以’’\\0’’结尾的。<br>sizeof还可以用函数做参数，比如： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">short f();</div><div class=\"line\">printf(&quot;%d\\n&quot;, sizeof(f()));</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>输出的结果是 <code>sizeof(short)</code> ，即2。 </p>\n<a id=\"more\"></a>\n<ol>\n<li><p>数组做sizeof的参数不退化，传递给strlen就退化为指针了。 </p>\n</li>\n<li><p>大部分编译程序 在编译的时候就把sizeof计算过了 是类型或是变量的长度这就是sizeof(x)可以用来定义数组维数的原因 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">char str[20]=&quot;0123456789&quot;;</div><div class=\"line\">int a=strlen(str); //a=10;</div><div class=\"line\">int b=sizeof(str); //而b=20;</div></pre></td></tr></table></figure>\n</li>\n<li><p>strlen的结果要在运行的时候才能计算出来，时用来计算字符串的长度，不是类型占内存的大小。 </p>\n</li>\n<li><p>sizeof后如果是类型必须加括弧，如果是变量名可以不加括弧。这是因为sizeof是个操作符不是个函数。</p>\n</li>\n<li><p>当适用了于一个结构类型时或变量， sizeof 返回实际的大小，<br>当适用一静态地空间数组， sizeof 归还全部数组的尺寸。<br>sizeof 操作符不能返回动态地被分派了的数组或外部的数组的尺寸 </p>\n</li>\n<li><p>数组作为参数传给函数时传的是指针而不是数组，传递的是数组的首地址，<br>如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">fun(char [8])</div><div class=\"line\">fun(char [])</div><div class=\"line\">都等价于 fun(char *)</div><div class=\"line\">``` </div><div class=\"line\">在C++里参数传递数组永远都是传递指向数组首元素的指针，编译器不知道数组的大小</div><div class=\"line\">如果想在函数内知道数组的大小， 需要这样做：</div><div class=\"line\">进入函数后用memcpy拷贝出来，长度由另一个形参传进去</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>fun(unsiged char <em>p1, int len)<br>{<br>  unsigned char</em> buf = new unsigned char[len+1]<br>  memcpy(buf, p1, len);<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">我们能常在用到 sizeof 和 strlen 的时候，通常是计算字符串数组的长度</div><div class=\"line\">看了上面的详细解释，发现两者的使用还是有区别的，从这个例子可以看得很清楚：</div></pre></td></tr></table></figure></p>\n<p>char str[20]=”0123456789”;<br>int a=strlen(str); //a=10; &gt;&gt;&gt;&gt; strlen 计算字符串的长度，以结束符 0x00 为字符串结束。<br>int b=sizeof(str); //而b=20; &gt;&gt;&gt;&gt; sizeof 计算的则是分配的数组 str[20] 所占的内存空间的大小，不受里面存储的内容改变。<br><code>``\n上面是对静态数组处理的结果，如果是对指针，结果就不一样了</code>char<em> ss = “0123456789”;<code>`sizeof(ss)</code> 结果 4 ＝＝＝》ss是指向字符串常量的字符指针，sizeof 获得的是一个指针的之所占的空间,应该是长整型的，所以是4<br>`sizeof(</em>ss)<code>结果 1 ＝＝＝》*ss是第一个字符 其实就是获得了字符串的第一位&#39;0&#39; 所占的内存空间，是char类型的，占了 1 位</code>strlen(ss)= 10` &gt;&gt;&gt;&gt; 如果要获得这个字符串的长度，则一定要使用 strlen</p>\n","excerpt":"<p>在一些场景下,希望得到数组的大小，字符串的长度，char型数组的长度等等，很自然想到sizeof以及strlen,但是非常容易搞混弄错.下面简要列出一些区别：</p>\n<ol>\n<li><p>sizeof操作符的结果类型是size_t，它在头文件中typedef为unsigned int类型。<br>该类型保证能容纳实现所建立的最大对象的字节大小。 </p>\n</li>\n<li><p>sizeof是操作符，strlen是函数。 </p>\n</li>\n<li><p>sizeof可以用类型做参数，strlen只能用char*做参数，且必须是以’’\\0’’结尾的。<br>sizeof还可以用函数做参数，比如： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">short f();</div><div class=\"line\">printf(&quot;%d\\n&quot;, sizeof(f()));</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>输出的结果是 <code>sizeof(short)</code> ，即2。 </p>","more":"<ol>\n<li><p>数组做sizeof的参数不退化，传递给strlen就退化为指针了。 </p>\n</li>\n<li><p>大部分编译程序 在编译的时候就把sizeof计算过了 是类型或是变量的长度这就是sizeof(x)可以用来定义数组维数的原因 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">char str[20]=&quot;0123456789&quot;;</div><div class=\"line\">int a=strlen(str); //a=10;</div><div class=\"line\">int b=sizeof(str); //而b=20;</div></pre></td></tr></table></figure>\n</li>\n<li><p>strlen的结果要在运行的时候才能计算出来，时用来计算字符串的长度，不是类型占内存的大小。 </p>\n</li>\n<li><p>sizeof后如果是类型必须加括弧，如果是变量名可以不加括弧。这是因为sizeof是个操作符不是个函数。</p>\n</li>\n<li><p>当适用了于一个结构类型时或变量， sizeof 返回实际的大小，<br>当适用一静态地空间数组， sizeof 归还全部数组的尺寸。<br>sizeof 操作符不能返回动态地被分派了的数组或外部的数组的尺寸 </p>\n</li>\n<li><p>数组作为参数传给函数时传的是指针而不是数组，传递的是数组的首地址，<br>如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">fun(char [8])</div><div class=\"line\">fun(char [])</div><div class=\"line\">都等价于 fun(char *)</div><div class=\"line\">``` </div><div class=\"line\">在C++里参数传递数组永远都是传递指向数组首元素的指针，编译器不知道数组的大小</div><div class=\"line\">如果想在函数内知道数组的大小， 需要这样做：</div><div class=\"line\">进入函数后用memcpy拷贝出来，长度由另一个形参传进去</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>fun(unsiged char <em>p1, int len)<br>{<br>  unsigned char</em> buf = new unsigned char[len+1]<br>  memcpy(buf, p1, len);<br>}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">我们能常在用到 sizeof 和 strlen 的时候，通常是计算字符串数组的长度</div><div class=\"line\">看了上面的详细解释，发现两者的使用还是有区别的，从这个例子可以看得很清楚：</div></pre></td></tr></table></figure></p>\n<p>char str[20]=”0123456789”;<br>int a=strlen(str); //a=10; &gt;&gt;&gt;&gt; strlen 计算字符串的长度，以结束符 0x00 为字符串结束。<br>int b=sizeof(str); //而b=20; &gt;&gt;&gt;&gt; sizeof 计算的则是分配的数组 str[20] 所占的内存空间的大小，不受里面存储的内容改变。<br><code>``\n上面是对静态数组处理的结果，如果是对指针，结果就不一样了</code>char<em> ss = “0123456789”;<code>`sizeof(ss)</code> 结果 4 ＝＝＝》ss是指向字符串常量的字符指针，sizeof 获得的是一个指针的之所占的空间,应该是长整型的，所以是4<br>`sizeof(</em>ss)<code>结果 1 ＝＝＝》*ss是第一个字符 其实就是获得了字符串的第一位&#39;0&#39; 所占的内存空间，是char类型的，占了 1 位</code>strlen(ss)= 10` &gt;&gt;&gt;&gt; 如果要获得这个字符串的长度，则一定要使用 strlen</p>"},{"title":"C++指针注意事项","date":"2016-12-29T15:34:47.000Z","comments":1,"_content":"\n+ 一定要在对指针使用解除运算符（*）之前，将指针初始化为一个确定的适当的地址，这是关于使用指针的金科玉律。\n\n+ 使用delete的关键在于，将他用于new分配的内存。这并不意味这要使用用于new的指针，而是用于new分配的地址。\n<b>Example:</b>\n```cpp\nint *ps = new int;    //allocate memory\nint *pq = ps;         //set second pointer to same block\ndelete pq;\t\t\t  //delete with second pointer\n```\n以上方法为同一使用new分配的空间，创建了两个指针，通常不会这么做，这将增加删除同一内存块两次的可能性。遵守\n\n+ 使用new和delete时，需要以下规则。\n1. 不要使用delete来释放不是new分配的内存；\n2. 不要使用delete释放同一个内存块两次；\n3. 如果使用new []为数组分配内存，则应使用delete []来释放\n4. 如果使用new []为一个实体分配内存，则应使用delete来释放\n5. 对空指针使用delete是安全的\n","source":"_posts/CPP/C-指针注意事项.md","raw":"---\ntitle: C++指针注意事项\ndate: 2016-12-29 23:34:47\ncategories:\n- 技术\ntags:\n- c++\ncomments: true\n---\n\n+ 一定要在对指针使用解除运算符（*）之前，将指针初始化为一个确定的适当的地址，这是关于使用指针的金科玉律。\n\n+ 使用delete的关键在于，将他用于new分配的内存。这并不意味这要使用用于new的指针，而是用于new分配的地址。\n<b>Example:</b>\n```cpp\nint *ps = new int;    //allocate memory\nint *pq = ps;         //set second pointer to same block\ndelete pq;\t\t\t  //delete with second pointer\n```\n以上方法为同一使用new分配的空间，创建了两个指针，通常不会这么做，这将增加删除同一内存块两次的可能性。遵守\n\n+ 使用new和delete时，需要以下规则。\n1. 不要使用delete来释放不是new分配的内存；\n2. 不要使用delete释放同一个内存块两次；\n3. 如果使用new []为数组分配内存，则应使用delete []来释放\n4. 如果使用new []为一个实体分配内存，则应使用delete来释放\n5. 对空指针使用delete是安全的\n","slug":"CPP/C-指针注意事项","published":1,"updated":"2017-05-29T15:22:55.885Z","layout":"post","photos":[],"link":"","_id":"cj3aal9rk0007094uut3owuto","content":"<ul>\n<li><p>一定要在对指针使用解除运算符（*）之前，将指针初始化为一个确定的适当的地址，这是关于使用指针的金科玉律。</p>\n</li>\n<li><p>使用delete的关键在于，将他用于new分配的内存。这并不意味这要使用用于new的指针，而是用于new分配的地址。<br><b>Example:</b></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> *ps = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>;    <span class=\"comment\">//allocate memory</span></div><div class=\"line\"><span class=\"keyword\">int</span> *pq = ps;         <span class=\"comment\">//set second pointer to same block</span></div><div class=\"line\"><span class=\"keyword\">delete</span> pq;\t\t\t  <span class=\"comment\">//delete with second pointer</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>以上方法为同一使用new分配的空间，创建了两个指针，通常不会这么做，这将增加删除同一内存块两次的可能性。遵守</p>\n<ul>\n<li>使用new和delete时，需要以下规则。</li>\n</ul>\n<ol>\n<li>不要使用delete来释放不是new分配的内存；</li>\n<li>不要使用delete释放同一个内存块两次；</li>\n<li>如果使用new []为数组分配内存，则应使用delete []来释放</li>\n<li>如果使用new []为一个实体分配内存，则应使用delete来释放</li>\n<li>对空指针使用delete是安全的</li>\n</ol>\n","excerpt":"","more":"<ul>\n<li><p>一定要在对指针使用解除运算符（*）之前，将指针初始化为一个确定的适当的地址，这是关于使用指针的金科玉律。</p>\n</li>\n<li><p>使用delete的关键在于，将他用于new分配的内存。这并不意味这要使用用于new的指针，而是用于new分配的地址。<br><b>Example:</b></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> *ps = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>;    <span class=\"comment\">//allocate memory</span></div><div class=\"line\"><span class=\"keyword\">int</span> *pq = ps;         <span class=\"comment\">//set second pointer to same block</span></div><div class=\"line\"><span class=\"keyword\">delete</span> pq;\t\t\t  <span class=\"comment\">//delete with second pointer</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>以上方法为同一使用new分配的空间，创建了两个指针，通常不会这么做，这将增加删除同一内存块两次的可能性。遵守</p>\n<ul>\n<li>使用new和delete时，需要以下规则。</li>\n</ul>\n<ol>\n<li>不要使用delete来释放不是new分配的内存；</li>\n<li>不要使用delete释放同一个内存块两次；</li>\n<li>如果使用new []为数组分配内存，则应使用delete []来释放</li>\n<li>如果使用new []为一个实体分配内存，则应使用delete来释放</li>\n<li>对空指针使用delete是安全的</li>\n</ol>\n"},{"title":"模板的具体化和实例化","date":"2017-03-11T23:08:12.000Z","comments":1,"_content":"什么是模板的具体化和实例化呢？有以下模板\n```\n#include <iostream>\ntemplate <typename T>\nvoid Swap(T &a, T &b);\n\ntemplate <typename T> void Swap(T &a, T  &b)\n{\n\tT temp;\n\ttemp = a;\n\ta = b;\n\tb = temp;\n}\n\nint main()\n{\n\tusing namespace std;\n\tint i = 10;\n\tint j = 20;\n\tSwap(i, j);   // 标志1\n\t...\n\t...\n}\n```\n在上面的模板函数声明中，声明一个交换类型为T的两个元素。代码包含函数模板并不会生产函数定义，它只是一个用于生产函数定义的方案。当编译器使用模板为特定类型生产函数定义时（程序标志1处），得到的是<b>模板实例化</b>，值得注意的是这里实例化的方式为隐式实例化，因为编译器发现你用的int类型参数，所以就隐式实例化。\n在C++中，还有一种实例化方式：<b>显式实例化</b>，语法如下：\n```\ntemplate void Swap<int>(int, int);  //显式实例化\n```\n与实例化不太一样的是<b>显式具体化</b>,具体的声明语法如下：\n```\ntemplate <> void Swap(int &, int &);\ntemplate <> void Swap<int>(int &, int &);\n```\n显示具体化不同的是：需要专门为int类型显式地定义函数定义，显式具体化声明在关键字template后包含<>,而显式实例化没有。\n\n此时，我们会发现有很多不同的函数定义，那么我们使用某个函数的时候，编译器到底使用的哪个函数原型呢？ 编译器选择原型的时候，非模板函数版本 > 显式具体化 > 通用模板版本。\n\n另外一点，同一个类型的显示实例化和显式具体化不能同时使用，会出错。\n","source":"_posts/CPP/模板的具体化和实例化.md","raw":"---\ntitle: 模板的具体化和实例化\ndate: 2017-03-12 07:08:12\ncategories:\n- 技术\ntags:\n- c++\ncomments: true\n---\n什么是模板的具体化和实例化呢？有以下模板\n```\n#include <iostream>\ntemplate <typename T>\nvoid Swap(T &a, T &b);\n\ntemplate <typename T> void Swap(T &a, T  &b)\n{\n\tT temp;\n\ttemp = a;\n\ta = b;\n\tb = temp;\n}\n\nint main()\n{\n\tusing namespace std;\n\tint i = 10;\n\tint j = 20;\n\tSwap(i, j);   // 标志1\n\t...\n\t...\n}\n```\n在上面的模板函数声明中，声明一个交换类型为T的两个元素。代码包含函数模板并不会生产函数定义，它只是一个用于生产函数定义的方案。当编译器使用模板为特定类型生产函数定义时（程序标志1处），得到的是<b>模板实例化</b>，值得注意的是这里实例化的方式为隐式实例化，因为编译器发现你用的int类型参数，所以就隐式实例化。\n在C++中，还有一种实例化方式：<b>显式实例化</b>，语法如下：\n```\ntemplate void Swap<int>(int, int);  //显式实例化\n```\n与实例化不太一样的是<b>显式具体化</b>,具体的声明语法如下：\n```\ntemplate <> void Swap(int &, int &);\ntemplate <> void Swap<int>(int &, int &);\n```\n显示具体化不同的是：需要专门为int类型显式地定义函数定义，显式具体化声明在关键字template后包含<>,而显式实例化没有。\n\n此时，我们会发现有很多不同的函数定义，那么我们使用某个函数的时候，编译器到底使用的哪个函数原型呢？ 编译器选择原型的时候，非模板函数版本 > 显式具体化 > 通用模板版本。\n\n另外一点，同一个类型的显示实例化和显式具体化不能同时使用，会出错。\n","slug":"CPP/模板的具体化和实例化","published":1,"updated":"2017-05-29T15:22:55.885Z","layout":"post","photos":[],"link":"","_id":"cj3aal9rn0009094uhfbokcx3","content":"<p>什么是模板的具体化和实例化呢？有以下模板<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;iostream&gt;</div><div class=\"line\">template &lt;typename T&gt;</div><div class=\"line\">void Swap(T &amp;a, T &amp;b);</div><div class=\"line\"></div><div class=\"line\">template &lt;typename T&gt; void Swap(T &amp;a, T  &amp;b)</div><div class=\"line\">&#123;</div><div class=\"line\">\tT temp;</div><div class=\"line\">\ttemp = a;</div><div class=\"line\">\ta = b;</div><div class=\"line\">\tb = temp;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">\tusing namespace std;</div><div class=\"line\">\tint i = 10;</div><div class=\"line\">\tint j = 20;</div><div class=\"line\">\tSwap(i, j);   // 标志1</div><div class=\"line\">\t...</div><div class=\"line\">\t...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在上面的模板函数声明中，声明一个交换类型为T的两个元素。代码包含函数模板并不会生产函数定义，它只是一个用于生产函数定义的方案。当编译器使用模板为特定类型生产函数定义时（程序标志1处），得到的是<b>模板实例化</b>，值得注意的是这里实例化的方式为隐式实例化，因为编译器发现你用的int类型参数，所以就隐式实例化。<br>在C++中，还有一种实例化方式：<b>显式实例化</b>，语法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">template void Swap&lt;int&gt;(int, int);  //显式实例化</div></pre></td></tr></table></figure></p>\n<p>与实例化不太一样的是<b>显式具体化</b>,具体的声明语法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">template &lt;&gt; void Swap(int &amp;, int &amp;);</div><div class=\"line\">template &lt;&gt; void Swap&lt;int&gt;(int &amp;, int &amp;);</div></pre></td></tr></table></figure></p>\n<p>显示具体化不同的是：需要专门为int类型显式地定义函数定义，显式具体化声明在关键字template后包含&lt;&gt;,而显式实例化没有。</p>\n<p>此时，我们会发现有很多不同的函数定义，那么我们使用某个函数的时候，编译器到底使用的哪个函数原型呢？ 编译器选择原型的时候，非模板函数版本 &gt; 显式具体化 &gt; 通用模板版本。</p>\n<p>另外一点，同一个类型的显示实例化和显式具体化不能同时使用，会出错。</p>\n","excerpt":"","more":"<p>什么是模板的具体化和实例化呢？有以下模板<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;iostream&gt;</div><div class=\"line\">template &lt;typename T&gt;</div><div class=\"line\">void Swap(T &amp;a, T &amp;b);</div><div class=\"line\"></div><div class=\"line\">template &lt;typename T&gt; void Swap(T &amp;a, T  &amp;b)</div><div class=\"line\">&#123;</div><div class=\"line\">\tT temp;</div><div class=\"line\">\ttemp = a;</div><div class=\"line\">\ta = b;</div><div class=\"line\">\tb = temp;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">\tusing namespace std;</div><div class=\"line\">\tint i = 10;</div><div class=\"line\">\tint j = 20;</div><div class=\"line\">\tSwap(i, j);   // 标志1</div><div class=\"line\">\t...</div><div class=\"line\">\t...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在上面的模板函数声明中，声明一个交换类型为T的两个元素。代码包含函数模板并不会生产函数定义，它只是一个用于生产函数定义的方案。当编译器使用模板为特定类型生产函数定义时（程序标志1处），得到的是<b>模板实例化</b>，值得注意的是这里实例化的方式为隐式实例化，因为编译器发现你用的int类型参数，所以就隐式实例化。<br>在C++中，还有一种实例化方式：<b>显式实例化</b>，语法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">template void Swap&lt;int&gt;(int, int);  //显式实例化</div></pre></td></tr></table></figure></p>\n<p>与实例化不太一样的是<b>显式具体化</b>,具体的声明语法如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">template &lt;&gt; void Swap(int &amp;, int &amp;);</div><div class=\"line\">template &lt;&gt; void Swap&lt;int&gt;(int &amp;, int &amp;);</div></pre></td></tr></table></figure></p>\n<p>显示具体化不同的是：需要专门为int类型显式地定义函数定义，显式具体化声明在关键字template后包含&lt;&gt;,而显式实例化没有。</p>\n<p>此时，我们会发现有很多不同的函数定义，那么我们使用某个函数的时候，编译器到底使用的哪个函数原型呢？ 编译器选择原型的时候，非模板函数版本 &gt; 显式具体化 &gt; 通用模板版本。</p>\n<p>另外一点，同一个类型的显示实例化和显式具体化不能同时使用，会出错。</p>\n"},{"title":"c++成员运算符","date":"2016-12-29T15:49:13.000Z","comments":1,"_content":"总结一下成员运算符的简单知识。\n\n+ 成员运算符有直接成员运算符 `.` 和间接成员运算符 `->` \n\n+ 直接成员运算符 ‘.’\n直接成员运算符主要是在直接引用，类本身以及内部引用时使用。人话就是对象使用\n+ 间接成员运算符 ‘->’\n间接成员运算符主要是在间接引用时使用。人话就是指向对象的指针使用\n\n+ 有时，C++新手在指定结构成员时，搞不清楚何时应使用句点运算符，何时应使用箭头运算符。规则很简单，如果结构标识符是结构名称，则使用句点运算符（直接成员运算符）；如果标识符是指向结构的指针，则使用箭头运算符。\n\n<b>Example:</b>\n\n```cpp\n//利用结构，演示直接成员运算符和间接成员运算符的用法\n\n#include <iostream>\n\nstruct inflatable\n{\n\tchar name[20];\n\tfloat volume;\n\tdouble price;\n};\n\nint main()\n{\n\tusing namespace std;\n\tinflatable *ps = new inflatable;\n\tcout << \"enter name of inflable item: \";\n\tcin.get(ps->name,20);\n\tcout << \"enter volume in cubic feet : \";\n\tcin >> (*ps).volume;\n\tcout << \"enter price : $\";\n\tcin >> ps->price;\n\tcout << \"Name: \" << (*ps).name <<endl;\n\tcout << \"volume : \"<< ps->volume <<\"cubic feet\\n\";\n\tcout << \"Price: $\" << ps->price <<endl;\n\tsystem(\"pause\");\n\tdelete ps;\n\t\n\treturn 0;\n}\n```\n","source":"_posts/CPP/c-成员运算符.md","raw":"---\ntitle: c++成员运算符\ndate: 2016-12-29 23:49:13\ncategories:\n- 技术\ntags:\n- c++\ncomments: true\n---\n总结一下成员运算符的简单知识。\n\n+ 成员运算符有直接成员运算符 `.` 和间接成员运算符 `->` \n\n+ 直接成员运算符 ‘.’\n直接成员运算符主要是在直接引用，类本身以及内部引用时使用。人话就是对象使用\n+ 间接成员运算符 ‘->’\n间接成员运算符主要是在间接引用时使用。人话就是指向对象的指针使用\n\n+ 有时，C++新手在指定结构成员时，搞不清楚何时应使用句点运算符，何时应使用箭头运算符。规则很简单，如果结构标识符是结构名称，则使用句点运算符（直接成员运算符）；如果标识符是指向结构的指针，则使用箭头运算符。\n\n<b>Example:</b>\n\n```cpp\n//利用结构，演示直接成员运算符和间接成员运算符的用法\n\n#include <iostream>\n\nstruct inflatable\n{\n\tchar name[20];\n\tfloat volume;\n\tdouble price;\n};\n\nint main()\n{\n\tusing namespace std;\n\tinflatable *ps = new inflatable;\n\tcout << \"enter name of inflable item: \";\n\tcin.get(ps->name,20);\n\tcout << \"enter volume in cubic feet : \";\n\tcin >> (*ps).volume;\n\tcout << \"enter price : $\";\n\tcin >> ps->price;\n\tcout << \"Name: \" << (*ps).name <<endl;\n\tcout << \"volume : \"<< ps->volume <<\"cubic feet\\n\";\n\tcout << \"Price: $\" << ps->price <<endl;\n\tsystem(\"pause\");\n\tdelete ps;\n\t\n\treturn 0;\n}\n```\n","slug":"CPP/c-成员运算符","published":1,"updated":"2017-05-29T15:22:55.885Z","layout":"post","photos":[],"link":"","_id":"cj3aal9rw000c094uowcblaib","content":"<p>总结一下成员运算符的简单知识。</p>\n<ul>\n<li><p>成员运算符有直接成员运算符 <code>.</code> 和间接成员运算符 <code>-&gt;</code> </p>\n</li>\n<li><p>直接成员运算符 ‘.’<br>直接成员运算符主要是在直接引用，类本身以及内部引用时使用。人话就是对象使用</p>\n</li>\n<li><p>间接成员运算符 ‘-&gt;’<br>间接成员运算符主要是在间接引用时使用。人话就是指向对象的指针使用</p>\n</li>\n<li><p>有时，C++新手在指定结构成员时，搞不清楚何时应使用句点运算符，何时应使用箭头运算符。规则很简单，如果结构标识符是结构名称，则使用句点运算符（直接成员运算符）；如果标识符是指向结构的指针，则使用箭头运算符。</p>\n</li>\n</ul>\n<p><b>Example:</b></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//利用结构，演示直接成员运算符和间接成员运算符的用法</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">struct</span> inflatable</div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">char</span> name[<span class=\"number\">20</span>];</div><div class=\"line\">\t<span class=\"keyword\">float</span> volume;</div><div class=\"line\">\t<span class=\"keyword\">double</span> price;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\">\tinflatable *ps = <span class=\"keyword\">new</span> inflatable;</div><div class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"enter name of inflable item: \"</span>;</div><div class=\"line\">\t<span class=\"built_in\">cin</span>.get(ps-&gt;name,<span class=\"number\">20</span>);</div><div class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"enter volume in cubic feet : \"</span>;</div><div class=\"line\">\t<span class=\"built_in\">cin</span> &gt;&gt; (*ps).volume;</div><div class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"enter price : $\"</span>;</div><div class=\"line\">\t<span class=\"built_in\">cin</span> &gt;&gt; ps-&gt;price;</div><div class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Name: \"</span> &lt;&lt; (*ps).name &lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"volume : \"</span>&lt;&lt; ps-&gt;volume &lt;&lt;<span class=\"string\">\"cubic feet\\n\"</span>;</div><div class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Price: $\"</span> &lt;&lt; ps-&gt;price &lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</div><div class=\"line\">\t<span class=\"keyword\">delete</span> ps;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","excerpt":"","more":"<p>总结一下成员运算符的简单知识。</p>\n<ul>\n<li><p>成员运算符有直接成员运算符 <code>.</code> 和间接成员运算符 <code>-&gt;</code> </p>\n</li>\n<li><p>直接成员运算符 ‘.’<br>直接成员运算符主要是在直接引用，类本身以及内部引用时使用。人话就是对象使用</p>\n</li>\n<li><p>间接成员运算符 ‘-&gt;’<br>间接成员运算符主要是在间接引用时使用。人话就是指向对象的指针使用</p>\n</li>\n<li><p>有时，C++新手在指定结构成员时，搞不清楚何时应使用句点运算符，何时应使用箭头运算符。规则很简单，如果结构标识符是结构名称，则使用句点运算符（直接成员运算符）；如果标识符是指向结构的指针，则使用箭头运算符。</p>\n</li>\n</ul>\n<p><b>Example:</b></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//利用结构，演示直接成员运算符和间接成员运算符的用法</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">struct</span> inflatable</div><div class=\"line\">&#123;</div><div class=\"line\">\t<span class=\"keyword\">char</span> name[<span class=\"number\">20</span>];</div><div class=\"line\">\t<span class=\"keyword\">float</span> volume;</div><div class=\"line\">\t<span class=\"keyword\">double</span> price;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></div><div class=\"line\"></span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</div><div class=\"line\">\tinflatable *ps = <span class=\"keyword\">new</span> inflatable;</div><div class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"enter name of inflable item: \"</span>;</div><div class=\"line\">\t<span class=\"built_in\">cin</span>.get(ps-&gt;name,<span class=\"number\">20</span>);</div><div class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"enter volume in cubic feet : \"</span>;</div><div class=\"line\">\t<span class=\"built_in\">cin</span> &gt;&gt; (*ps).volume;</div><div class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"enter price : $\"</span>;</div><div class=\"line\">\t<span class=\"built_in\">cin</span> &gt;&gt; ps-&gt;price;</div><div class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Name: \"</span> &lt;&lt; (*ps).name &lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"volume : \"</span>&lt;&lt; ps-&gt;volume &lt;&lt;<span class=\"string\">\"cubic feet\\n\"</span>;</div><div class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Price: $\"</span> &lt;&lt; ps-&gt;price &lt;&lt;<span class=\"built_in\">endl</span>;</div><div class=\"line\">\tsystem(<span class=\"string\">\"pause\"</span>);</div><div class=\"line\">\t<span class=\"keyword\">delete</span> ps;</div><div class=\"line\">\t</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"派生类与基类之间的特殊关系","date":"2017-03-11T22:51:52.000Z","comments":1,"_content":"\n+ 继承是C++中一项非常重要的特性，继承派生使得C++的代码重用实现可能。基类与其派生类之间也有着较为特殊的关系\n```\nclass person{\nprivate:\n\tstring name;\n\tdouble height;\npublic:\n\tvoid Funciton_One();\n};\nclass student : public person{\nprivate:\n\tint student_ID;\npublic:\n\tvoid Funciton_TWo();\n}\n```\n由上述简要代码可以知道，student类从person类派生出来，继承了person类的实现（存储了基类数据成员）与接口（可以使用基类方法）。\n<b>重点</b>\n基类指针可以在不进行显式转换的情况下，指向派生类对象；同理，\n基类引用也可以在不进行显式转换的情况下引用派生类对象。\n但是，反过来确实不允许的，\n```\nperson Zhang(……);\nstudent Lee(……)；\nperson * Temp1 = &Lee; // Allowed\nperson & Temp2 = Lee;  // Allowed\nstudent * temp1 = &Zhang; // Not Allowed\nstudent & temp2 = Zhang;  // Not Allowed\n```\n从上面代码可以看出这一特殊的关系。虽然基类引用和指针可以引用和指向派生类对象，但是基类引用和指针只能调用基类方法。这也正常，你试想，使用基类引用为派生类对象调用基类方法，显然是可以的，因为派生类继承了基类方法；相反，如果使用派生类引用为基类对象调用派生类方法，这明显会发生错误。\n这一关系也存在于以基类引用（指针）作为形参的函数。\n","source":"_posts/CPP/派生类与基类之间的特殊关系.md","raw":"---\ntitle: 派生类与基类之间的特殊关系\ndate: 2017-03-12 06:51:52\ntags: \n- c++\ncategories:\n- 技术\ncomments: true\n---\n\n+ 继承是C++中一项非常重要的特性，继承派生使得C++的代码重用实现可能。基类与其派生类之间也有着较为特殊的关系\n```\nclass person{\nprivate:\n\tstring name;\n\tdouble height;\npublic:\n\tvoid Funciton_One();\n};\nclass student : public person{\nprivate:\n\tint student_ID;\npublic:\n\tvoid Funciton_TWo();\n}\n```\n由上述简要代码可以知道，student类从person类派生出来，继承了person类的实现（存储了基类数据成员）与接口（可以使用基类方法）。\n<b>重点</b>\n基类指针可以在不进行显式转换的情况下，指向派生类对象；同理，\n基类引用也可以在不进行显式转换的情况下引用派生类对象。\n但是，反过来确实不允许的，\n```\nperson Zhang(……);\nstudent Lee(……)；\nperson * Temp1 = &Lee; // Allowed\nperson & Temp2 = Lee;  // Allowed\nstudent * temp1 = &Zhang; // Not Allowed\nstudent & temp2 = Zhang;  // Not Allowed\n```\n从上面代码可以看出这一特殊的关系。虽然基类引用和指针可以引用和指向派生类对象，但是基类引用和指针只能调用基类方法。这也正常，你试想，使用基类引用为派生类对象调用基类方法，显然是可以的，因为派生类继承了基类方法；相反，如果使用派生类引用为基类对象调用派生类方法，这明显会发生错误。\n这一关系也存在于以基类引用（指针）作为形参的函数。\n","slug":"CPP/派生类与基类之间的特殊关系","published":1,"updated":"2017-05-29T15:22:55.885Z","layout":"post","photos":[],"link":"","_id":"cj3aal9rz000f094ujh7elgph","content":"<ul>\n<li>继承是C++中一项非常重要的特性，继承派生使得C++的代码重用实现可能。基类与其派生类之间也有着较为特殊的关系<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">class person&#123;</div><div class=\"line\">private:</div><div class=\"line\">\tstring name;</div><div class=\"line\">\tdouble height;</div><div class=\"line\">public:</div><div class=\"line\">\tvoid Funciton_One();</div><div class=\"line\">&#125;;</div><div class=\"line\">class student : public person&#123;</div><div class=\"line\">private:</div><div class=\"line\">\tint student_ID;</div><div class=\"line\">public:</div><div class=\"line\">\tvoid Funciton_TWo();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>由上述简要代码可以知道，student类从person类派生出来，继承了person类的实现（存储了基类数据成员）与接口（可以使用基类方法）。<br><b>重点</b><br>基类指针可以在不进行显式转换的情况下，指向派生类对象；同理，<br>基类引用也可以在不进行显式转换的情况下引用派生类对象。<br>但是，反过来确实不允许的，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">person Zhang(……);</div><div class=\"line\">student Lee(……)；</div><div class=\"line\">person * Temp1 = &amp;Lee; // Allowed</div><div class=\"line\">person &amp; Temp2 = Lee;  // Allowed</div><div class=\"line\">student * temp1 = &amp;Zhang; // Not Allowed</div><div class=\"line\">student &amp; temp2 = Zhang;  // Not Allowed</div></pre></td></tr></table></figure></p>\n<p>从上面代码可以看出这一特殊的关系。虽然基类引用和指针可以引用和指向派生类对象，但是基类引用和指针只能调用基类方法。这也正常，你试想，使用基类引用为派生类对象调用基类方法，显然是可以的，因为派生类继承了基类方法；相反，如果使用派生类引用为基类对象调用派生类方法，这明显会发生错误。<br>这一关系也存在于以基类引用（指针）作为形参的函数。</p>\n","excerpt":"","more":"<ul>\n<li>继承是C++中一项非常重要的特性，继承派生使得C++的代码重用实现可能。基类与其派生类之间也有着较为特殊的关系<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">class person&#123;</div><div class=\"line\">private:</div><div class=\"line\">\tstring name;</div><div class=\"line\">\tdouble height;</div><div class=\"line\">public:</div><div class=\"line\">\tvoid Funciton_One();</div><div class=\"line\">&#125;;</div><div class=\"line\">class student : public person&#123;</div><div class=\"line\">private:</div><div class=\"line\">\tint student_ID;</div><div class=\"line\">public:</div><div class=\"line\">\tvoid Funciton_TWo();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>由上述简要代码可以知道，student类从person类派生出来，继承了person类的实现（存储了基类数据成员）与接口（可以使用基类方法）。<br><b>重点</b><br>基类指针可以在不进行显式转换的情况下，指向派生类对象；同理，<br>基类引用也可以在不进行显式转换的情况下引用派生类对象。<br>但是，反过来确实不允许的，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">person Zhang(……);</div><div class=\"line\">student Lee(……)；</div><div class=\"line\">person * Temp1 = &amp;Lee; // Allowed</div><div class=\"line\">person &amp; Temp2 = Lee;  // Allowed</div><div class=\"line\">student * temp1 = &amp;Zhang; // Not Allowed</div><div class=\"line\">student &amp; temp2 = Zhang;  // Not Allowed</div></pre></td></tr></table></figure></p>\n<p>从上面代码可以看出这一特殊的关系。虽然基类引用和指针可以引用和指向派生类对象，但是基类引用和指针只能调用基类方法。这也正常，你试想，使用基类引用为派生类对象调用基类方法，显然是可以的，因为派生类继承了基类方法；相反，如果使用派生类引用为基类对象调用派生类方法，这明显会发生错误。<br>这一关系也存在于以基类引用（指针）作为形参的函数。</p>\n"},{"title":"虚析构函数的作用","date":"2017-03-11T23:09:46.000Z","comments":1,"_content":"+ 为什么要使用虚析构函数？\n如果有这样两个类：\n```\nclass person{\n\tperson(...);\n\tvirtual ~person();\n\tvirtual void show();  //具体定义就不写了，反正和派生类不一样\n};\nclass student : public person{\n\tvirtual void show();  \n};\nperson temp_p(...);\nstudent temp_s(...);\nperson * temp1 = temp_p;\nperson * temp2 = temp_s;\n```\n为了发挥C++多态的特性，我们一般会使用虚函数，采用基类指针或者引用来 对基类对象或者派生类对象进行操作。但是这样会有一个问题，如果析构函数不是虚函数，那么基类指针temp2结束代码段时，就只会调用指针类型(就是基类)的析构函数。如果这个基类指针指向的是派生类对象，那么派生类的析构函数就不会被调用，显然是有一定问题隐患的。\n因此，使用虚析构函数可以确保正确的析构函数序列被调用。\n","source":"_posts/CPP/虚析构函数的作用.md","raw":"---\ntitle: 虚析构函数的作用\ndate: 2017-03-12 07:09:46\ncategories:\n- 技术\ntags:\n- c++\ncomments: true\n---\n+ 为什么要使用虚析构函数？\n如果有这样两个类：\n```\nclass person{\n\tperson(...);\n\tvirtual ~person();\n\tvirtual void show();  //具体定义就不写了，反正和派生类不一样\n};\nclass student : public person{\n\tvirtual void show();  \n};\nperson temp_p(...);\nstudent temp_s(...);\nperson * temp1 = temp_p;\nperson * temp2 = temp_s;\n```\n为了发挥C++多态的特性，我们一般会使用虚函数，采用基类指针或者引用来 对基类对象或者派生类对象进行操作。但是这样会有一个问题，如果析构函数不是虚函数，那么基类指针temp2结束代码段时，就只会调用指针类型(就是基类)的析构函数。如果这个基类指针指向的是派生类对象，那么派生类的析构函数就不会被调用，显然是有一定问题隐患的。\n因此，使用虚析构函数可以确保正确的析构函数序列被调用。\n","slug":"CPP/虚析构函数的作用","published":1,"updated":"2017-05-29T15:22:55.885Z","layout":"post","photos":[],"link":"","_id":"cj3aal9sa000i094ux5th9exl","content":"<ul>\n<li>为什么要使用虚析构函数？<br>如果有这样两个类：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">class person&#123;</div><div class=\"line\">\tperson(...);</div><div class=\"line\">\tvirtual ~person();</div><div class=\"line\">\tvirtual void show();  //具体定义就不写了，反正和派生类不一样</div><div class=\"line\">&#125;;</div><div class=\"line\">class student : public person&#123;</div><div class=\"line\">\tvirtual void show();  </div><div class=\"line\">&#125;;</div><div class=\"line\">person temp_p(...);</div><div class=\"line\">student temp_s(...);</div><div class=\"line\">person * temp1 = temp_p;</div><div class=\"line\">person * temp2 = temp_s;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>为了发挥C++多态的特性，我们一般会使用虚函数，采用基类指针或者引用来 对基类对象或者派生类对象进行操作。但是这样会有一个问题，如果析构函数不是虚函数，那么基类指针temp2结束代码段时，就只会调用指针类型(就是基类)的析构函数。如果这个基类指针指向的是派生类对象，那么派生类的析构函数就不会被调用，显然是有一定问题隐患的。<br>因此，使用虚析构函数可以确保正确的析构函数序列被调用。</p>\n","excerpt":"","more":"<ul>\n<li>为什么要使用虚析构函数？<br>如果有这样两个类：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">class person&#123;</div><div class=\"line\">\tperson(...);</div><div class=\"line\">\tvirtual ~person();</div><div class=\"line\">\tvirtual void show();  //具体定义就不写了，反正和派生类不一样</div><div class=\"line\">&#125;;</div><div class=\"line\">class student : public person&#123;</div><div class=\"line\">\tvirtual void show();  </div><div class=\"line\">&#125;;</div><div class=\"line\">person temp_p(...);</div><div class=\"line\">student temp_s(...);</div><div class=\"line\">person * temp1 = temp_p;</div><div class=\"line\">person * temp2 = temp_s;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>为了发挥C++多态的特性，我们一般会使用虚函数，采用基类指针或者引用来 对基类对象或者派生类对象进行操作。但是这样会有一个问题，如果析构函数不是虚函数，那么基类指针temp2结束代码段时，就只会调用指针类型(就是基类)的析构函数。如果这个基类指针指向的是派生类对象，那么派生类的析构函数就不会被调用，显然是有一定问题隐患的。<br>因此，使用虚析构函数可以确保正确的析构函数序列被调用。</p>\n"},{"title":"C++中如何输出char型指针地址","date":"2017-03-11T23:07:40.000Z","comments":1,"_content":"\n+ C++ 中std::cout对于char类型的指针，将默认输出这个类型指向的字符串，也就是：\n```\nchar * temp = \"Hello, CPP.\\n\";\nstd::cout << temp << endl;\n\nOUTPUT:  Hello, CPP\n```\n那么我们要想输出这个字符串的地址怎么办？？？\n+ 首先，我们要清楚为什么会这样呢，因为如果是int类型的指针就不会呀。这是因为C++标准库中IO类对'<<'运算符进行了重载，因此呢， 在遇到 char * 类型数据的时候，就自动使用相应的重载函数，把那个char型指针指向的字符串输出了。\n+ 那么，How 2 solve this problem? 类型转换呀，你把它转换为int型指针？ 这是可以的， 但是这时下策。使用'static_cast<const void *>',把char型指针转换为无类型指针。如下：\n```\nchar * temp = \"Hello, CPP.\\n\";\nstd::cout << temp << endl;\nstd::cout << static_cast<const void *>(temp) << endl;\nOUTPUT:  \nHello, CPP\n某个地址\n```\n+ 一些学渣还会有疑问，static_cast<>()这是什么鬼？那么拾起那么《C++ primer》，你会发现C++还是很有趣的。\n","source":"_posts/CPP/CPP中如何输出char型指针地址.md","raw":"---\ntitle: C++中如何输出char型指针地址\ndate: 2017-03-12 07:07:40\ncategories:\n- 技术\ntags:\n- c++\ncomments: true\n---\n\n+ C++ 中std::cout对于char类型的指针，将默认输出这个类型指向的字符串，也就是：\n```\nchar * temp = \"Hello, CPP.\\n\";\nstd::cout << temp << endl;\n\nOUTPUT:  Hello, CPP\n```\n那么我们要想输出这个字符串的地址怎么办？？？\n+ 首先，我们要清楚为什么会这样呢，因为如果是int类型的指针就不会呀。这是因为C++标准库中IO类对'<<'运算符进行了重载，因此呢， 在遇到 char * 类型数据的时候，就自动使用相应的重载函数，把那个char型指针指向的字符串输出了。\n+ 那么，How 2 solve this problem? 类型转换呀，你把它转换为int型指针？ 这是可以的， 但是这时下策。使用'static_cast<const void *>',把char型指针转换为无类型指针。如下：\n```\nchar * temp = \"Hello, CPP.\\n\";\nstd::cout << temp << endl;\nstd::cout << static_cast<const void *>(temp) << endl;\nOUTPUT:  \nHello, CPP\n某个地址\n```\n+ 一些学渣还会有疑问，static_cast<>()这是什么鬼？那么拾起那么《C++ primer》，你会发现C++还是很有趣的。\n","slug":"CPP/CPP中如何输出char型指针地址","published":1,"updated":"2017-05-29T15:22:55.885Z","layout":"post","photos":[],"link":"","_id":"cj3aal9sn000l094ur1qvzisy","content":"<ul>\n<li>C++ 中std::cout对于char类型的指针，将默认输出这个类型指向的字符串，也就是：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">char * temp = &quot;Hello, CPP.\\n&quot;;</div><div class=\"line\">std::cout &lt;&lt; temp &lt;&lt; endl;</div><div class=\"line\"></div><div class=\"line\">OUTPUT:  Hello, CPP</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>那么我们要想输出这个字符串的地址怎么办？？？</p>\n<ul>\n<li>首先，我们要清楚为什么会这样呢，因为如果是int类型的指针就不会呀。这是因为C++标准库中IO类对’&lt;&lt;’运算符进行了重载，因此呢， 在遇到 char * 类型数据的时候，就自动使用相应的重载函数，把那个char型指针指向的字符串输出了。</li>\n<li><p>那么，How 2 solve this problem? 类型转换呀，你把它转换为int型指针？ 这是可以的， 但是这时下策。使用’static_cast<const void=\"\" *=\"\">‘,把char型指针转换为无类型指针。如下：</const></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">char * temp = &quot;Hello, CPP.\\n&quot;;</div><div class=\"line\">std::cout &lt;&lt; temp &lt;&lt; endl;</div><div class=\"line\">std::cout &lt;&lt; static_cast&lt;const void *&gt;(temp) &lt;&lt; endl;</div><div class=\"line\">OUTPUT:  </div><div class=\"line\">Hello, CPP</div><div class=\"line\">某个地址</div></pre></td></tr></table></figure>\n</li>\n<li><p>一些学渣还会有疑问，static_cast&lt;&gt;()这是什么鬼？那么拾起那么《C++ primer》，你会发现C++还是很有趣的。</p>\n</li>\n</ul>\n","excerpt":"","more":"<ul>\n<li>C++ 中std::cout对于char类型的指针，将默认输出这个类型指向的字符串，也就是：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">char * temp = &quot;Hello, CPP.\\n&quot;;</div><div class=\"line\">std::cout &lt;&lt; temp &lt;&lt; endl;</div><div class=\"line\"></div><div class=\"line\">OUTPUT:  Hello, CPP</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>那么我们要想输出这个字符串的地址怎么办？？？</p>\n<ul>\n<li>首先，我们要清楚为什么会这样呢，因为如果是int类型的指针就不会呀。这是因为C++标准库中IO类对’&lt;&lt;’运算符进行了重载，因此呢， 在遇到 char * 类型数据的时候，就自动使用相应的重载函数，把那个char型指针指向的字符串输出了。</li>\n<li><p>那么，How 2 solve this problem? 类型转换呀，你把它转换为int型指针？ 这是可以的， 但是这时下策。使用’static_cast<const void *>‘,把char型指针转换为无类型指针。如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">char * temp = &quot;Hello, CPP.\\n&quot;;</div><div class=\"line\">std::cout &lt;&lt; temp &lt;&lt; endl;</div><div class=\"line\">std::cout &lt;&lt; static_cast&lt;const void *&gt;(temp) &lt;&lt; endl;</div><div class=\"line\">OUTPUT:  </div><div class=\"line\">Hello, CPP</div><div class=\"line\">某个地址</div></pre></td></tr></table></figure>\n</li>\n<li><p>一些学渣还会有疑问，static_cast&lt;&gt;()这是什么鬼？那么拾起那么《C++ primer》，你会发现C++还是很有趣的。</p>\n</li>\n</ul>\n"},{"title":"友元、异常和其他相关问题","date":"2017-05-29T12:57:36.000Z","comments":1,"_content":"# 友元\n## 友元类\n友元函数用于类的扩展接口，类并非只能拥有友元函数，还能够将类作为友元类。友元类的所有方法都可以访问原始类的私有成员和保护成员。\n以电视机和遥控器的关系，解释友元的作用以及相关问题\n<!--more-->\n### 友元的声明\n友元声明的位置无关紧要，可以在原始类的私有、公有或保护部分。简单示例如下：\n```\nclass TV\n{\nprivate:\n\tfriend class Remote;\n\t...\n};\nclass Remote\n{\n\t...\npublic:\n\tvoid set_chan(TV & t);\n\t...\n};\n```\n如上面代码所示，只需要在原始类中任意位置`friend class Remote`，就可以声明友元类了。\n1. 但是问题来了，Remote类中提到了TV类，，所以编译器必须先了解TV类，才能处理Remote类。上面的例子就是把TV的定义放在Remote前面。那么如果TV中包含了Remote成员函数，Remote中包含了TV类怎么办呢？？？这就用到前向声明(forward declaration)。【如果让Remote类成为友元类，是不用前向声明的，因为那条语句就说明Remote是个类】\n```\nclass Remote;\nclass TV\n{\nprivate:\n\tfriend void Remote::set_chan(TV & t);\n\t...\n};\nclass Remote\n{\n\t...\npublic:\n\tvoid set_chan(TV & t);\n\t...\n};\n```\n2. 是上述代码这样吗？<b>显然，这样是错误的！！！</b>，因为虽然Remote的声明放在前面，但是编译器并没有看到随后TV类中Remote的那个方法的声明。正确打开方式：\n```\nclass TV;\nclass Remote\n{\n\t...\npublic:\n\tvoid set_chan(TV & t);\n\t...\n};\nclass TV\n{\nprivate:\n\tfriend void Remote::set_chan(TV & t);\n\t...\n};\n```\n3. 那么问题又来了，如果`void set_chan(TV & t) {t.function();}`,这样就会造成2中提到的问题，就循环了。所以这里采用内联函数吧。\n友元还有很多内容，比如两个类互相为友元，两个类有一个共同的友元等，处理原则和上面说的几个点一样：<b>在你使用某个类、某个类的成员函数之前，你声明这个类、这个成员函数了吗？编译器就是看一点。</b>\n# 异常 \n异常就是像我这种程序猿给自己挖的坑，异常处理就是程序猿自己给自己兜底。程序运行会遇到很多异常情况导致程序无法运行下去，为了防止这种情况，就有了C++异常：为处理这些情况强大、灵活的工具。通常情况有这样几种处理方法。\n## 调用abort()\n```\n#include <iostream>\n#include <cstdlib>  // abort() 函数头文件\nusing namespace std;\ndouble hmean(double a, double b);\nint main()\n{\n\tdouble x, y, z;\n\twhile(cin >> x >> y)\n\t{\n\t\tz = hmean(x, y);\n\t\tcout << \"The harmonic mean of \" << x << \" and \" << y  << \" is \" << z << endl;\n\t\tcout << \"Please enter next set of numbers : <q to quit>: \" << endl;\n\t}\n\tcout << \"Done.\\n\";\n\tsystem(\"pause\");\n\treturn 0;\n}\ndouble hmean(double a, double b)\n{\n\tif(a == -b)\n\t{\n\t\tcout << \"untenable arguments to hmean().\\n\";\n\t\tabort();\n\t}\n\treturn 2.0 * a * b / ( a + b );\n}\n```\n这个例子就是求两个数a、b的调和平均数，但是a、b不能为相反数，如果有，程序就崩了，所以如果出现这种情况就调用abort();终止程序运行。【我并没有意识到这个有什么用】\n## 返回错误码\n```\n#include <iostream>\n#include <cfloat>\n\nbool hmean(double a, double b, double * ans);\n\nusing namespace std;\n\nint main()\n{\n\tdouble x, y, z;\n\tcout << \"Please enter one set of number : \";\n\twhile(cin >> x >> y)\n\t{\n\t\tif(hmean(x, y, &z))\n\t\t{\n\t\t\tcout << \"Harmonic mean of \"<< x << \" and \" << y << \" is \" << z << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"One value should not be the negative of the other - try again.\\n\";\n\t\t}\n\t\tcout << \"Please enter next set of numbers <q to quit >: \";\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n\nbool hmean(double a, double b, double * ans)\n{\n\tif(a == -b)\n\t{\n\t\t*ans == DBL_MAX;\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\t*ans = 2.0 * a * b /(a + b);\n\t\treturn true;\n\t}\n}\n```\n这个例子和上面那个例子没有什么区别，就是检测到如果为相反数，不调用abort(),而是返回一个false……………………………………【我也没有感觉这个有什么用】\n## 异常机制 try--catch\nC++异常对异常的处理由3各部分：\n<b>引发异常</b>。程序出现问题时将引发异常，之前两种方法在异常引发后，是调用abort终止了程序，但是throw语句是跳转，即命令程序跳转到另一条语句。throw关键字表示引发异常，参数表示异常的特征，用以指导处理。\n<b>使用处理程序捕获异常</b>。采用异常处理程序捕获异常，catch关键字表示捕获异常，其参数指出异常处理程序要响应的异常类型。异常处理程序也叫catch块。\n<b>使用try块</b>。try块表示可能会引发异常的代码块，表面需要注意这些代码引发的异常；它后面跟多个catch块，表明try块引发的异常由这些catch块处理。\n```\n#include <iostream>\n#include <string>\ndouble hmean(double a, double b);\n\nusing namespace std;\n\nint main()\n{\n\tdouble x, y, z;\n\tcout << \"Enter one set of numbers : \";\n\twhile(cin >> x >> y)\n\t{\n\t\ttry{\n\t\t\tz = hmean(x, y);\n\t\t}\n\t\tcatch(const char * s)\n\t\t{\n\t\t\tcout << s << endl;\n\t\t\tcout << \"Enter next set of numbers : \";\n\t\t\tcontinue;\n\t\t}\n\t\tcout << \"Harmonic mean of \" << x << \" and \" << y << \" is \" << z << endl;\n\t\tcout << \"Enter next set of numbers : \";\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n\ndouble hmean(double a, double b)\n{\n\tif(a == -b)\n\t\tthrow \"bad hmean() arguments\";\n\treturn 2.0 * a * b /(a + b);\n}\n```\n这个例子和前面的两个一样。但是处理方法采用了try-catch的方法，就是检测到是相反数，就抛出异常(throw \"bad hmean() arguments\";),然后根据这个抛出的异常信息，在catch中找到对应的catch处理部分。<b>需要注意的是，执行throw语句类似于执行返回语句，因为它也将终止函数的执行，但是throw不是返回至调用程序的地方，而是使程序沿函数调用序列后退，直至try块函数。</b>在寻找与异常类型匹配的异常处理程序（catch块）。如果没有引发异常，则跳过catch块。\n还有就是，也可以将对象作为异常类型throw掉……………………具体实现方法和上面差不多。\n## 异常规范\nC++11把异常规范从标准中剔除了，感兴趣有时间可以看看。\n# 运行阶段类型识别(RTTI)\nRTTI（Runtime Type Identification）是运行阶段类型识别，简单点就是在运行阶段确定对象的类型的一种标准方法。\n在实际编程中，会遇到这样的情况，在总多类层次结构中，我们会选择使用基类指针来指向其中任意的派生类对象，但是问题来了，我想使用某个类的成员函数，那么这个指针能否直接调用这个函数呢，我们就会搞忘这个指针指向的到底是什么对象类型？？？当然如果这个函数是类层次结构中所有成员都拥有的虚函数，就无所谓了。\n## RTTI的工作原理\nC++有3个支持RTTI的元素：dynamic_cast运算符、typeid运算符、type_info结构。\n1. dynamic_cast\ndynamic_cast运算符，如果可以，使用一个指向基类的指针来生成一个派生类指针；否则，返回空指针。\n假设有如下的类层次结构：\n```\nclass Grand {//has virtual methods};\nclass Superb : public Grand {}\nclass Magnificent : public Superb {}\n```\n有如下指针：\n```\nGrand * pg = new Grand;\nGrand * ps = new Superb;\nGrand * pm = new Magnificent;\n\nMagnificent * p1 = (Magnificent *) pm;  //#1\nMagnificent * p2 = (Magnificent *) pg;  //#2\nSuperb * p3 = (Magnificent *) pm;       //#3\n```\n可以得到的是，以上三种指针转换第一种和第三种是正确的，但是第二种是错误，因为pg是基类指针，强制转换为派生类指针，要求其可以调用派生类方法，显然会导致错误。\n需要注意的是，与“指针指向的是什么类型的对象”相比，问题“类型转换是否安全正确”更加通用。因此来看看dynamic_cast的用法。\n`Superb * pm = dynamic_cast<Super *> pg;`,这各语句就指出pg能否安全的转换为Superb *，，如果可以赋值给pm， 如果不可以，pm被赋值为空指针；\n具体的来看一个详细的例子：：\n```\n// dynamic_case\\<\\> 也可以用于引用，但是与指针用法稍有不同：没有与空指针对于的引用值，无法使用特殊的引用值指示失败，因此dynamic_case将引发bad_cast的异常 P646\n#include <iostream>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\n\nclass Grand{\nprivate:\n\tint hold;\npublic:\n\tGrand(int h = 0) : hold(h) {}\n\tvirtual void Speak() const { cout << \"I am a grand class!\\n\";}\n\tvirtual int Value() const { return hold;}\n};\n\nclass Superb : public Grand\n{\npublic:\n\tSuperb(int h = 0) : Grand(h) {}\n\tvoid Speak() const {cout << \"I am a Superb class!!\\n\";}\n\tvirtual void Say() const { cout << \"I holde the superb value of \" << Value() << \"!!\\n\";}\n};\n\nclass Magnificent : public Superb\n{\nprivate:\n\tchar ch;\npublic:\n\tMagnificent(int h = 0, char c = 'A') : Superb(h), ch(c) {}\n\tvoid Speak() const { cout << \"I am a magnificent class \\n\";}\n\tvoid Say() const { cout << \"I hold the character \" << ch << \"and the integer \" << Value() << \"\\n\";}\n};\n\nGrand * GetOne();\n\nint main()\n{\n\tsrand(time(0));   //srand() cstdlib  time(0) ctime\n\tGrand * pg;\n\tSuperb * ps;\n\tfor(int i = 0; i < 5; i++)\n\t{\n\t\tpg = GetOne();\n\t\tpg->Speak();\n\t\tif(ps = dynamic_cast<Superb * >(pg))\n\t\t\tps->Say();\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n\nGrand * GetOne()\n{\n\tGrand * p;\n\tswitch(rand() % 3)\n\t{\n\tcase 0:\n\t\tp = new Grand(rand() % 100);\n\t\tbreak;\n\tcase 1:\n\t\tp = new Superb(rand() % 100);\n\t\tbreak;\n\tcase 2:\n\t\tp = new Magnificent(rand() % 100, 'A' + rand() % 26);\n\t\tbreak;\n\t} \n\treturn p;\n}\n```\n2. typeid运算符和typeinfo类\ntypeid运算符合sizeof有些相似，结构两种参数：类名、结果为对象的表达式。\ntypeid将返回一个对type_info对象的引用，type_info是在头文件typeinfo中定义的一个类，type_info重载了==和！=运算符，以便对类型进行比较。如果pg指向一个Magnificent对象，则下面结果为true，否则为false：\n`typeid(Magnificent) == typeid(*pg);`,那么问题又来了，如果pg是一个空指针呢，将引发bad_typeid异常。该异常是从exception类派生而来的，在typeinfo中声明的。\ntype_info类的实现随不同厂商而异，但包含一个name()成员，返回一个随实现而异的字符串。具体看下面的例子：\n```\n#include <iostream>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\n\nclass Grand{\nprivate:\n\tint hold;\npublic:\n\tGrand(int h = 0) : hold(h) {}\n\tvirtual void Speak() const { cout << \"I am a grand class!\\n\";}\n\tvirtual int Value() const { return hold;}\n};\n\nclass Superb : public Grand\n{\npublic:\n\tSuperb(int h = 0) : Grand(h) {}\n\tvoid Speak() const {cout << \"I am a Superb class!!\\n\";}\n\tvirtual void Say() const { cout << \"I holde the superb value of \" << Value() << \"!!\\n\";}\n};\n\nclass Magnificent : public Superb\n{\nprivate:\n\tchar ch;\npublic:\n\tMagnificent(int h = 0, char c = 'A') : Superb(h), ch(c) {}\n\tvoid Speak() const { cout << \"I am a magnificent class \\n\";}\n\tvoid Say() const { cout << \"I hold the character \" << ch << \"and the integer \" << Value() << \"\\n\";}\n};\n\nGrand * GetOne();\n\nint main()\n{\n\tsrand(time(0));   //srand() cstdlib  time(0) ctime\n\tGrand * pg;\n\tSuperb * ps;\n\tfor(int i = 0; i < 5; i++)\n\t{\n\t\tpg = GetOne();\n\t\tcout << \"Now processing type \" << typeid(*pg).name() << endl;\n\t\tpg->Speak();\n\t\tif(ps = dynamic_cast<Superb *>(pg))\n\t\t\tps->Say();\n\t\tif(typeid(Magnificent) ==typeid(*pg))\n\t\t\tcout << \"Yes, you're really magnificent.\\n\";\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n\nGrand * GetOne()\n{\n\tGrand * p;\n\tswitch(rand() % 3)\n\t{\n\tcase 0:\n\t\tp = new Grand(rand() % 100);\n\t\tbreak;\n\tcase 1:\n\t\tp = new Superb(rand() % 100);\n\t\tbreak;\n\tcase 2:\n\t\tp = new Magnificent(rand() % 100, 'A' + rand() % 26);\n\t\tbreak;\n\t} \n\treturn p;\n}\n```\n# 其他\n## 嵌套类\n这个内容并没有太多可讲的，需要重点关注的点：<b>嵌套类的作用域和访问控制</b>。\n## 类型转换运算符\n在RTTI中讲了一个类型转换运算符，但是还有几个其他的运算符,用法和dynamic_cast一样，运用的场景不一样而已：\ndynamic_cast: 在类层次结构中进行向上转换，而不允许其他转换\nconst_cast： 用来修改类型的const或volatile属性。但是这个运算符没有很好的理解，可以改变类型，却又不能改变const的值，那么有什么用？？？\nstatic_cast: `static_cast<type-name> (expression)`,仅当type-name可被隐式转换为expression所属类型或expression所属类型可被隐式转换为type-name，转换成立，否则将出错。有些不能隐式转换的也可使用static_cast强制转换，但是可能出错。同时也可以用于数值转换中。\nreinterpret_cast：用于比如将一个long型数据转换为一个结构体（包含两个short型成员），这类危险转换依赖于底层编程技术，不可移植。\n","source":"_posts/CPP/友元、异常和其他问题.md","raw":"---\ntitle: 友元、异常和其他相关问题\ndate: 2017-05-29 20:57:36\ntags: \n- c++\ncategories:\n- 技术\ncomments: true\n---\n# 友元\n## 友元类\n友元函数用于类的扩展接口，类并非只能拥有友元函数，还能够将类作为友元类。友元类的所有方法都可以访问原始类的私有成员和保护成员。\n以电视机和遥控器的关系，解释友元的作用以及相关问题\n<!--more-->\n### 友元的声明\n友元声明的位置无关紧要，可以在原始类的私有、公有或保护部分。简单示例如下：\n```\nclass TV\n{\nprivate:\n\tfriend class Remote;\n\t...\n};\nclass Remote\n{\n\t...\npublic:\n\tvoid set_chan(TV & t);\n\t...\n};\n```\n如上面代码所示，只需要在原始类中任意位置`friend class Remote`，就可以声明友元类了。\n1. 但是问题来了，Remote类中提到了TV类，，所以编译器必须先了解TV类，才能处理Remote类。上面的例子就是把TV的定义放在Remote前面。那么如果TV中包含了Remote成员函数，Remote中包含了TV类怎么办呢？？？这就用到前向声明(forward declaration)。【如果让Remote类成为友元类，是不用前向声明的，因为那条语句就说明Remote是个类】\n```\nclass Remote;\nclass TV\n{\nprivate:\n\tfriend void Remote::set_chan(TV & t);\n\t...\n};\nclass Remote\n{\n\t...\npublic:\n\tvoid set_chan(TV & t);\n\t...\n};\n```\n2. 是上述代码这样吗？<b>显然，这样是错误的！！！</b>，因为虽然Remote的声明放在前面，但是编译器并没有看到随后TV类中Remote的那个方法的声明。正确打开方式：\n```\nclass TV;\nclass Remote\n{\n\t...\npublic:\n\tvoid set_chan(TV & t);\n\t...\n};\nclass TV\n{\nprivate:\n\tfriend void Remote::set_chan(TV & t);\n\t...\n};\n```\n3. 那么问题又来了，如果`void set_chan(TV & t) {t.function();}`,这样就会造成2中提到的问题，就循环了。所以这里采用内联函数吧。\n友元还有很多内容，比如两个类互相为友元，两个类有一个共同的友元等，处理原则和上面说的几个点一样：<b>在你使用某个类、某个类的成员函数之前，你声明这个类、这个成员函数了吗？编译器就是看一点。</b>\n# 异常 \n异常就是像我这种程序猿给自己挖的坑，异常处理就是程序猿自己给自己兜底。程序运行会遇到很多异常情况导致程序无法运行下去，为了防止这种情况，就有了C++异常：为处理这些情况强大、灵活的工具。通常情况有这样几种处理方法。\n## 调用abort()\n```\n#include <iostream>\n#include <cstdlib>  // abort() 函数头文件\nusing namespace std;\ndouble hmean(double a, double b);\nint main()\n{\n\tdouble x, y, z;\n\twhile(cin >> x >> y)\n\t{\n\t\tz = hmean(x, y);\n\t\tcout << \"The harmonic mean of \" << x << \" and \" << y  << \" is \" << z << endl;\n\t\tcout << \"Please enter next set of numbers : <q to quit>: \" << endl;\n\t}\n\tcout << \"Done.\\n\";\n\tsystem(\"pause\");\n\treturn 0;\n}\ndouble hmean(double a, double b)\n{\n\tif(a == -b)\n\t{\n\t\tcout << \"untenable arguments to hmean().\\n\";\n\t\tabort();\n\t}\n\treturn 2.0 * a * b / ( a + b );\n}\n```\n这个例子就是求两个数a、b的调和平均数，但是a、b不能为相反数，如果有，程序就崩了，所以如果出现这种情况就调用abort();终止程序运行。【我并没有意识到这个有什么用】\n## 返回错误码\n```\n#include <iostream>\n#include <cfloat>\n\nbool hmean(double a, double b, double * ans);\n\nusing namespace std;\n\nint main()\n{\n\tdouble x, y, z;\n\tcout << \"Please enter one set of number : \";\n\twhile(cin >> x >> y)\n\t{\n\t\tif(hmean(x, y, &z))\n\t\t{\n\t\t\tcout << \"Harmonic mean of \"<< x << \" and \" << y << \" is \" << z << endl;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcout << \"One value should not be the negative of the other - try again.\\n\";\n\t\t}\n\t\tcout << \"Please enter next set of numbers <q to quit >: \";\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n\nbool hmean(double a, double b, double * ans)\n{\n\tif(a == -b)\n\t{\n\t\t*ans == DBL_MAX;\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\t*ans = 2.0 * a * b /(a + b);\n\t\treturn true;\n\t}\n}\n```\n这个例子和上面那个例子没有什么区别，就是检测到如果为相反数，不调用abort(),而是返回一个false……………………………………【我也没有感觉这个有什么用】\n## 异常机制 try--catch\nC++异常对异常的处理由3各部分：\n<b>引发异常</b>。程序出现问题时将引发异常，之前两种方法在异常引发后，是调用abort终止了程序，但是throw语句是跳转，即命令程序跳转到另一条语句。throw关键字表示引发异常，参数表示异常的特征，用以指导处理。\n<b>使用处理程序捕获异常</b>。采用异常处理程序捕获异常，catch关键字表示捕获异常，其参数指出异常处理程序要响应的异常类型。异常处理程序也叫catch块。\n<b>使用try块</b>。try块表示可能会引发异常的代码块，表面需要注意这些代码引发的异常；它后面跟多个catch块，表明try块引发的异常由这些catch块处理。\n```\n#include <iostream>\n#include <string>\ndouble hmean(double a, double b);\n\nusing namespace std;\n\nint main()\n{\n\tdouble x, y, z;\n\tcout << \"Enter one set of numbers : \";\n\twhile(cin >> x >> y)\n\t{\n\t\ttry{\n\t\t\tz = hmean(x, y);\n\t\t}\n\t\tcatch(const char * s)\n\t\t{\n\t\t\tcout << s << endl;\n\t\t\tcout << \"Enter next set of numbers : \";\n\t\t\tcontinue;\n\t\t}\n\t\tcout << \"Harmonic mean of \" << x << \" and \" << y << \" is \" << z << endl;\n\t\tcout << \"Enter next set of numbers : \";\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n\ndouble hmean(double a, double b)\n{\n\tif(a == -b)\n\t\tthrow \"bad hmean() arguments\";\n\treturn 2.0 * a * b /(a + b);\n}\n```\n这个例子和前面的两个一样。但是处理方法采用了try-catch的方法，就是检测到是相反数，就抛出异常(throw \"bad hmean() arguments\";),然后根据这个抛出的异常信息，在catch中找到对应的catch处理部分。<b>需要注意的是，执行throw语句类似于执行返回语句，因为它也将终止函数的执行，但是throw不是返回至调用程序的地方，而是使程序沿函数调用序列后退，直至try块函数。</b>在寻找与异常类型匹配的异常处理程序（catch块）。如果没有引发异常，则跳过catch块。\n还有就是，也可以将对象作为异常类型throw掉……………………具体实现方法和上面差不多。\n## 异常规范\nC++11把异常规范从标准中剔除了，感兴趣有时间可以看看。\n# 运行阶段类型识别(RTTI)\nRTTI（Runtime Type Identification）是运行阶段类型识别，简单点就是在运行阶段确定对象的类型的一种标准方法。\n在实际编程中，会遇到这样的情况，在总多类层次结构中，我们会选择使用基类指针来指向其中任意的派生类对象，但是问题来了，我想使用某个类的成员函数，那么这个指针能否直接调用这个函数呢，我们就会搞忘这个指针指向的到底是什么对象类型？？？当然如果这个函数是类层次结构中所有成员都拥有的虚函数，就无所谓了。\n## RTTI的工作原理\nC++有3个支持RTTI的元素：dynamic_cast运算符、typeid运算符、type_info结构。\n1. dynamic_cast\ndynamic_cast运算符，如果可以，使用一个指向基类的指针来生成一个派生类指针；否则，返回空指针。\n假设有如下的类层次结构：\n```\nclass Grand {//has virtual methods};\nclass Superb : public Grand {}\nclass Magnificent : public Superb {}\n```\n有如下指针：\n```\nGrand * pg = new Grand;\nGrand * ps = new Superb;\nGrand * pm = new Magnificent;\n\nMagnificent * p1 = (Magnificent *) pm;  //#1\nMagnificent * p2 = (Magnificent *) pg;  //#2\nSuperb * p3 = (Magnificent *) pm;       //#3\n```\n可以得到的是，以上三种指针转换第一种和第三种是正确的，但是第二种是错误，因为pg是基类指针，强制转换为派生类指针，要求其可以调用派生类方法，显然会导致错误。\n需要注意的是，与“指针指向的是什么类型的对象”相比，问题“类型转换是否安全正确”更加通用。因此来看看dynamic_cast的用法。\n`Superb * pm = dynamic_cast<Super *> pg;`,这各语句就指出pg能否安全的转换为Superb *，，如果可以赋值给pm， 如果不可以，pm被赋值为空指针；\n具体的来看一个详细的例子：：\n```\n// dynamic_case\\<\\> 也可以用于引用，但是与指针用法稍有不同：没有与空指针对于的引用值，无法使用特殊的引用值指示失败，因此dynamic_case将引发bad_cast的异常 P646\n#include <iostream>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\n\nclass Grand{\nprivate:\n\tint hold;\npublic:\n\tGrand(int h = 0) : hold(h) {}\n\tvirtual void Speak() const { cout << \"I am a grand class!\\n\";}\n\tvirtual int Value() const { return hold;}\n};\n\nclass Superb : public Grand\n{\npublic:\n\tSuperb(int h = 0) : Grand(h) {}\n\tvoid Speak() const {cout << \"I am a Superb class!!\\n\";}\n\tvirtual void Say() const { cout << \"I holde the superb value of \" << Value() << \"!!\\n\";}\n};\n\nclass Magnificent : public Superb\n{\nprivate:\n\tchar ch;\npublic:\n\tMagnificent(int h = 0, char c = 'A') : Superb(h), ch(c) {}\n\tvoid Speak() const { cout << \"I am a magnificent class \\n\";}\n\tvoid Say() const { cout << \"I hold the character \" << ch << \"and the integer \" << Value() << \"\\n\";}\n};\n\nGrand * GetOne();\n\nint main()\n{\n\tsrand(time(0));   //srand() cstdlib  time(0) ctime\n\tGrand * pg;\n\tSuperb * ps;\n\tfor(int i = 0; i < 5; i++)\n\t{\n\t\tpg = GetOne();\n\t\tpg->Speak();\n\t\tif(ps = dynamic_cast<Superb * >(pg))\n\t\t\tps->Say();\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n\nGrand * GetOne()\n{\n\tGrand * p;\n\tswitch(rand() % 3)\n\t{\n\tcase 0:\n\t\tp = new Grand(rand() % 100);\n\t\tbreak;\n\tcase 1:\n\t\tp = new Superb(rand() % 100);\n\t\tbreak;\n\tcase 2:\n\t\tp = new Magnificent(rand() % 100, 'A' + rand() % 26);\n\t\tbreak;\n\t} \n\treturn p;\n}\n```\n2. typeid运算符和typeinfo类\ntypeid运算符合sizeof有些相似，结构两种参数：类名、结果为对象的表达式。\ntypeid将返回一个对type_info对象的引用，type_info是在头文件typeinfo中定义的一个类，type_info重载了==和！=运算符，以便对类型进行比较。如果pg指向一个Magnificent对象，则下面结果为true，否则为false：\n`typeid(Magnificent) == typeid(*pg);`,那么问题又来了，如果pg是一个空指针呢，将引发bad_typeid异常。该异常是从exception类派生而来的，在typeinfo中声明的。\ntype_info类的实现随不同厂商而异，但包含一个name()成员，返回一个随实现而异的字符串。具体看下面的例子：\n```\n#include <iostream>\n#include <cstdlib>\n#include <ctime>\n\nusing namespace std;\n\nclass Grand{\nprivate:\n\tint hold;\npublic:\n\tGrand(int h = 0) : hold(h) {}\n\tvirtual void Speak() const { cout << \"I am a grand class!\\n\";}\n\tvirtual int Value() const { return hold;}\n};\n\nclass Superb : public Grand\n{\npublic:\n\tSuperb(int h = 0) : Grand(h) {}\n\tvoid Speak() const {cout << \"I am a Superb class!!\\n\";}\n\tvirtual void Say() const { cout << \"I holde the superb value of \" << Value() << \"!!\\n\";}\n};\n\nclass Magnificent : public Superb\n{\nprivate:\n\tchar ch;\npublic:\n\tMagnificent(int h = 0, char c = 'A') : Superb(h), ch(c) {}\n\tvoid Speak() const { cout << \"I am a magnificent class \\n\";}\n\tvoid Say() const { cout << \"I hold the character \" << ch << \"and the integer \" << Value() << \"\\n\";}\n};\n\nGrand * GetOne();\n\nint main()\n{\n\tsrand(time(0));   //srand() cstdlib  time(0) ctime\n\tGrand * pg;\n\tSuperb * ps;\n\tfor(int i = 0; i < 5; i++)\n\t{\n\t\tpg = GetOne();\n\t\tcout << \"Now processing type \" << typeid(*pg).name() << endl;\n\t\tpg->Speak();\n\t\tif(ps = dynamic_cast<Superb *>(pg))\n\t\t\tps->Say();\n\t\tif(typeid(Magnificent) ==typeid(*pg))\n\t\t\tcout << \"Yes, you're really magnificent.\\n\";\n\t}\n\tsystem(\"pause\");\n\treturn 0;\n}\n\nGrand * GetOne()\n{\n\tGrand * p;\n\tswitch(rand() % 3)\n\t{\n\tcase 0:\n\t\tp = new Grand(rand() % 100);\n\t\tbreak;\n\tcase 1:\n\t\tp = new Superb(rand() % 100);\n\t\tbreak;\n\tcase 2:\n\t\tp = new Magnificent(rand() % 100, 'A' + rand() % 26);\n\t\tbreak;\n\t} \n\treturn p;\n}\n```\n# 其他\n## 嵌套类\n这个内容并没有太多可讲的，需要重点关注的点：<b>嵌套类的作用域和访问控制</b>。\n## 类型转换运算符\n在RTTI中讲了一个类型转换运算符，但是还有几个其他的运算符,用法和dynamic_cast一样，运用的场景不一样而已：\ndynamic_cast: 在类层次结构中进行向上转换，而不允许其他转换\nconst_cast： 用来修改类型的const或volatile属性。但是这个运算符没有很好的理解，可以改变类型，却又不能改变const的值，那么有什么用？？？\nstatic_cast: `static_cast<type-name> (expression)`,仅当type-name可被隐式转换为expression所属类型或expression所属类型可被隐式转换为type-name，转换成立，否则将出错。有些不能隐式转换的也可使用static_cast强制转换，但是可能出错。同时也可以用于数值转换中。\nreinterpret_cast：用于比如将一个long型数据转换为一个结构体（包含两个short型成员），这类危险转换依赖于底层编程技术，不可移植。\n","slug":"CPP/友元、异常和其他问题","published":1,"updated":"2017-05-29T14:11:58.437Z","layout":"post","photos":[],"link":"","_id":"cj3aal9sr000o094u8h5710u5","content":"<h1 id=\"友元\"><a href=\"#友元\" class=\"headerlink\" title=\"友元\"></a>友元</h1><h2 id=\"友元类\"><a href=\"#友元类\" class=\"headerlink\" title=\"友元类\"></a>友元类</h2><p>友元函数用于类的扩展接口，类并非只能拥有友元函数，还能够将类作为友元类。友元类的所有方法都可以访问原始类的私有成员和保护成员。<br>以电视机和遥控器的关系，解释友元的作用以及相关问题<br><a id=\"more\"></a></p>\n<h3 id=\"友元的声明\"><a href=\"#友元的声明\" class=\"headerlink\" title=\"友元的声明\"></a>友元的声明</h3><p>友元声明的位置无关紧要，可以在原始类的私有、公有或保护部分。简单示例如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">class TV</div><div class=\"line\">&#123;</div><div class=\"line\">private:</div><div class=\"line\">\tfriend class Remote;</div><div class=\"line\">\t...</div><div class=\"line\">&#125;;</div><div class=\"line\">class Remote</div><div class=\"line\">&#123;</div><div class=\"line\">\t...</div><div class=\"line\">public:</div><div class=\"line\">\tvoid set_chan(TV &amp; t);</div><div class=\"line\">\t...</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>如上面代码所示，只需要在原始类中任意位置<code>friend class Remote</code>，就可以声明友元类了。</p>\n<ol>\n<li><p>但是问题来了，Remote类中提到了TV类，，所以编译器必须先了解TV类，才能处理Remote类。上面的例子就是把TV的定义放在Remote前面。那么如果TV中包含了Remote成员函数，Remote中包含了TV类怎么办呢？？？这就用到前向声明(forward declaration)。【如果让Remote类成为友元类，是不用前向声明的，因为那条语句就说明Remote是个类】</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Remote;</div><div class=\"line\">class TV</div><div class=\"line\">&#123;</div><div class=\"line\">private:</div><div class=\"line\">\tfriend void Remote::set_chan(TV &amp; t);</div><div class=\"line\">\t...</div><div class=\"line\">&#125;;</div><div class=\"line\">class Remote</div><div class=\"line\">&#123;</div><div class=\"line\">\t...</div><div class=\"line\">public:</div><div class=\"line\">\tvoid set_chan(TV &amp; t);</div><div class=\"line\">\t...</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p>是上述代码这样吗？<b>显然，这样是错误的！！！</b>，因为虽然Remote的声明放在前面，但是编译器并没有看到随后TV类中Remote的那个方法的声明。正确打开方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">class TV;</div><div class=\"line\">class Remote</div><div class=\"line\">&#123;</div><div class=\"line\">\t...</div><div class=\"line\">public:</div><div class=\"line\">\tvoid set_chan(TV &amp; t);</div><div class=\"line\">\t...</div><div class=\"line\">&#125;;</div><div class=\"line\">class TV</div><div class=\"line\">&#123;</div><div class=\"line\">private:</div><div class=\"line\">\tfriend void Remote::set_chan(TV &amp; t);</div><div class=\"line\">\t...</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p>那么问题又来了，如果<code>void set_chan(TV &amp; t) {t.function();}</code>,这样就会造成2中提到的问题，就循环了。所以这里采用内联函数吧。<br>友元还有很多内容，比如两个类互相为友元，两个类有一个共同的友元等，处理原则和上面说的几个点一样：<b>在你使用某个类、某个类的成员函数之前，你声明这个类、这个成员函数了吗？编译器就是看一点。</b></p>\n<h1 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h1><p>异常就是像我这种程序猿给自己挖的坑，异常处理就是程序猿自己给自己兜底。程序运行会遇到很多异常情况导致程序无法运行下去，为了防止这种情况，就有了C++异常：为处理这些情况强大、灵活的工具。通常情况有这样几种处理方法。</p>\n<h2 id=\"调用abort\"><a href=\"#调用abort\" class=\"headerlink\" title=\"调用abort()\"></a>调用abort()</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;iostream&gt;</div><div class=\"line\">#include &lt;cstdlib&gt;  // abort() 函数头文件</div><div class=\"line\">using namespace std;</div><div class=\"line\">double hmean(double a, double b);</div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">\tdouble x, y, z;</div><div class=\"line\">\twhile(cin &gt;&gt; x &gt;&gt; y)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tz = hmean(x, y);</div><div class=\"line\">\t\tcout &lt;&lt; &quot;The harmonic mean of &quot; &lt;&lt; x &lt;&lt; &quot; and &quot; &lt;&lt; y  &lt;&lt; &quot; is &quot; &lt;&lt; z &lt;&lt; endl;</div><div class=\"line\">\t\tcout &lt;&lt; &quot;Please enter next set of numbers : &lt;q to quit&gt;: &quot; &lt;&lt; endl;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tcout &lt;&lt; &quot;Done.\\n&quot;;</div><div class=\"line\">\tsystem(&quot;pause&quot;);</div><div class=\"line\">\treturn 0;</div><div class=\"line\">&#125;</div><div class=\"line\">double hmean(double a, double b)</div><div class=\"line\">&#123;</div><div class=\"line\">\tif(a == -b)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tcout &lt;&lt; &quot;untenable arguments to hmean().\\n&quot;;</div><div class=\"line\">\t\tabort();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn 2.0 * a * b / ( a + b );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这个例子就是求两个数a、b的调和平均数，但是a、b不能为相反数，如果有，程序就崩了，所以如果出现这种情况就调用abort();终止程序运行。【我并没有意识到这个有什么用】</p>\n<h2 id=\"返回错误码\"><a href=\"#返回错误码\" class=\"headerlink\" title=\"返回错误码\"></a>返回错误码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;iostream&gt;</div><div class=\"line\">#include &lt;cfloat&gt;</div><div class=\"line\"></div><div class=\"line\">bool hmean(double a, double b, double * ans);</div><div class=\"line\"></div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">\tdouble x, y, z;</div><div class=\"line\">\tcout &lt;&lt; &quot;Please enter one set of number : &quot;;</div><div class=\"line\">\twhile(cin &gt;&gt; x &gt;&gt; y)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tif(hmean(x, y, &amp;z))</div><div class=\"line\">\t\t&#123;</div><div class=\"line\">\t\t\tcout &lt;&lt; &quot;Harmonic mean of &quot;&lt;&lt; x &lt;&lt; &quot; and &quot; &lt;&lt; y &lt;&lt; &quot; is &quot; &lt;&lt; z &lt;&lt; endl;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\telse</div><div class=\"line\">\t\t&#123;</div><div class=\"line\">\t\t\tcout &lt;&lt; &quot;One value should not be the negative of the other - try again.\\n&quot;;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tcout &lt;&lt; &quot;Please enter next set of numbers &lt;q to quit &gt;: &quot;;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tsystem(&quot;pause&quot;);</div><div class=\"line\">\treturn 0;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">bool hmean(double a, double b, double * ans)</div><div class=\"line\">&#123;</div><div class=\"line\">\tif(a == -b)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t*ans == DBL_MAX;</div><div class=\"line\">\t\treturn false;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\telse</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t*ans = 2.0 * a * b /(a + b);</div><div class=\"line\">\t\treturn true;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个例子和上面那个例子没有什么区别，就是检测到如果为相反数，不调用abort(),而是返回一个false……………………………………【我也没有感觉这个有什么用】</p>\n<h2 id=\"异常机制-try–catch\"><a href=\"#异常机制-try–catch\" class=\"headerlink\" title=\"异常机制 try–catch\"></a>异常机制 try–catch</h2><p>C++异常对异常的处理由3各部分：<br><b>引发异常</b>。程序出现问题时将引发异常，之前两种方法在异常引发后，是调用abort终止了程序，但是throw语句是跳转，即命令程序跳转到另一条语句。throw关键字表示引发异常，参数表示异常的特征，用以指导处理。<br><b>使用处理程序捕获异常</b>。采用异常处理程序捕获异常，catch关键字表示捕获异常，其参数指出异常处理程序要响应的异常类型。异常处理程序也叫catch块。<br><b>使用try块</b>。try块表示可能会引发异常的代码块，表面需要注意这些代码引发的异常；它后面跟多个catch块，表明try块引发的异常由这些catch块处理。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;iostream&gt;</div><div class=\"line\">#include &lt;string&gt;</div><div class=\"line\">double hmean(double a, double b);</div><div class=\"line\"></div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">\tdouble x, y, z;</div><div class=\"line\">\tcout &lt;&lt; &quot;Enter one set of numbers : &quot;;</div><div class=\"line\">\twhile(cin &gt;&gt; x &gt;&gt; y)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\ttry&#123;</div><div class=\"line\">\t\t\tz = hmean(x, y);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tcatch(const char * s)</div><div class=\"line\">\t\t&#123;</div><div class=\"line\">\t\t\tcout &lt;&lt; s &lt;&lt; endl;</div><div class=\"line\">\t\t\tcout &lt;&lt; &quot;Enter next set of numbers : &quot;;</div><div class=\"line\">\t\t\tcontinue;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tcout &lt;&lt; &quot;Harmonic mean of &quot; &lt;&lt; x &lt;&lt; &quot; and &quot; &lt;&lt; y &lt;&lt; &quot; is &quot; &lt;&lt; z &lt;&lt; endl;</div><div class=\"line\">\t\tcout &lt;&lt; &quot;Enter next set of numbers : &quot;;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tsystem(&quot;pause&quot;);</div><div class=\"line\">\treturn 0;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">double hmean(double a, double b)</div><div class=\"line\">&#123;</div><div class=\"line\">\tif(a == -b)</div><div class=\"line\">\t\tthrow &quot;bad hmean() arguments&quot;;</div><div class=\"line\">\treturn 2.0 * a * b /(a + b);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个例子和前面的两个一样。但是处理方法采用了try-catch的方法，就是检测到是相反数，就抛出异常(throw “bad hmean() arguments”;),然后根据这个抛出的异常信息，在catch中找到对应的catch处理部分。<b>需要注意的是，执行throw语句类似于执行返回语句，因为它也将终止函数的执行，但是throw不是返回至调用程序的地方，而是使程序沿函数调用序列后退，直至try块函数。</b>在寻找与异常类型匹配的异常处理程序（catch块）。如果没有引发异常，则跳过catch块。<br>还有就是，也可以将对象作为异常类型throw掉……………………具体实现方法和上面差不多。</p>\n<h2 id=\"异常规范\"><a href=\"#异常规范\" class=\"headerlink\" title=\"异常规范\"></a>异常规范</h2><p>C++11把异常规范从标准中剔除了，感兴趣有时间可以看看。</p>\n<h1 id=\"运行阶段类型识别-RTTI\"><a href=\"#运行阶段类型识别-RTTI\" class=\"headerlink\" title=\"运行阶段类型识别(RTTI)\"></a>运行阶段类型识别(RTTI)</h1><p>RTTI（Runtime Type Identification）是运行阶段类型识别，简单点就是在运行阶段确定对象的类型的一种标准方法。<br>在实际编程中，会遇到这样的情况，在总多类层次结构中，我们会选择使用基类指针来指向其中任意的派生类对象，但是问题来了，我想使用某个类的成员函数，那么这个指针能否直接调用这个函数呢，我们就会搞忘这个指针指向的到底是什么对象类型？？？当然如果这个函数是类层次结构中所有成员都拥有的虚函数，就无所谓了。</p>\n<h2 id=\"RTTI的工作原理\"><a href=\"#RTTI的工作原理\" class=\"headerlink\" title=\"RTTI的工作原理\"></a>RTTI的工作原理</h2><p>C++有3个支持RTTI的元素：dynamic_cast运算符、typeid运算符、type_info结构。</p>\n<ol>\n<li>dynamic_cast<br>dynamic_cast运算符，如果可以，使用一个指向基类的指针来生成一个派生类指针；否则，返回空指针。<br>假设有如下的类层次结构：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Grand &#123;//has virtual methods&#125;;</div><div class=\"line\">class Superb : public Grand &#123;&#125;</div><div class=\"line\">class Magnificent : public Superb &#123;&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>有如下指针：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">Grand * pg = new Grand;</div><div class=\"line\">Grand * ps = new Superb;</div><div class=\"line\">Grand * pm = new Magnificent;</div><div class=\"line\"></div><div class=\"line\">Magnificent * p1 = (Magnificent *) pm;  //#1</div><div class=\"line\">Magnificent * p2 = (Magnificent *) pg;  //#2</div><div class=\"line\">Superb * p3 = (Magnificent *) pm;       //#3</div></pre></td></tr></table></figure></p>\n<p>可以得到的是，以上三种指针转换第一种和第三种是正确的，但是第二种是错误，因为pg是基类指针，强制转换为派生类指针，要求其可以调用派生类方法，显然会导致错误。<br>需要注意的是，与“指针指向的是什么类型的对象”相比，问题“类型转换是否安全正确”更加通用。因此来看看dynamic_cast的用法。<br><code>Superb * pm = dynamic_cast&lt;Super *&gt; pg;</code>,这各语句就指出pg能否安全的转换为Superb *，，如果可以赋值给pm， 如果不可以，pm被赋值为空指针；<br>具体的来看一个详细的例子：：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div></pre></td><td class=\"code\"><pre><div class=\"line\">// dynamic_case\\&lt;\\&gt; 也可以用于引用，但是与指针用法稍有不同：没有与空指针对于的引用值，无法使用特殊的引用值指示失败，因此dynamic_case将引发bad_cast的异常 P646</div><div class=\"line\">#include &lt;iostream&gt;</div><div class=\"line\">#include &lt;cstdlib&gt;</div><div class=\"line\">#include &lt;ctime&gt;</div><div class=\"line\"></div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Grand&#123;</div><div class=\"line\">private:</div><div class=\"line\">\tint hold;</div><div class=\"line\">public:</div><div class=\"line\">\tGrand(int h = 0) : hold(h) &#123;&#125;</div><div class=\"line\">\tvirtual void Speak() const &#123; cout &lt;&lt; &quot;I am a grand class!\\n&quot;;&#125;</div><div class=\"line\">\tvirtual int Value() const &#123; return hold;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">class Superb : public Grand</div><div class=\"line\">&#123;</div><div class=\"line\">public:</div><div class=\"line\">\tSuperb(int h = 0) : Grand(h) &#123;&#125;</div><div class=\"line\">\tvoid Speak() const &#123;cout &lt;&lt; &quot;I am a Superb class!!\\n&quot;;&#125;</div><div class=\"line\">\tvirtual void Say() const &#123; cout &lt;&lt; &quot;I holde the superb value of &quot; &lt;&lt; Value() &lt;&lt; &quot;!!\\n&quot;;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">class Magnificent : public Superb</div><div class=\"line\">&#123;</div><div class=\"line\">private:</div><div class=\"line\">\tchar ch;</div><div class=\"line\">public:</div><div class=\"line\">\tMagnificent(int h = 0, char c = &apos;A&apos;) : Superb(h), ch(c) &#123;&#125;</div><div class=\"line\">\tvoid Speak() const &#123; cout &lt;&lt; &quot;I am a magnificent class \\n&quot;;&#125;</div><div class=\"line\">\tvoid Say() const &#123; cout &lt;&lt; &quot;I hold the character &quot; &lt;&lt; ch &lt;&lt; &quot;and the integer &quot; &lt;&lt; Value() &lt;&lt; &quot;\\n&quot;;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Grand * GetOne();</div><div class=\"line\"></div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">\tsrand(time(0));   //srand() cstdlib  time(0) ctime</div><div class=\"line\">\tGrand * pg;</div><div class=\"line\">\tSuperb * ps;</div><div class=\"line\">\tfor(int i = 0; i &lt; 5; i++)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tpg = GetOne();</div><div class=\"line\">\t\tpg-&gt;Speak();</div><div class=\"line\">\t\tif(ps = dynamic_cast&lt;Superb * &gt;(pg))</div><div class=\"line\">\t\t\tps-&gt;Say();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tsystem(&quot;pause&quot;);</div><div class=\"line\">\treturn 0;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Grand * GetOne()</div><div class=\"line\">&#123;</div><div class=\"line\">\tGrand * p;</div><div class=\"line\">\tswitch(rand() % 3)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\tcase 0:</div><div class=\"line\">\t\tp = new Grand(rand() % 100);</div><div class=\"line\">\t\tbreak;</div><div class=\"line\">\tcase 1:</div><div class=\"line\">\t\tp = new Superb(rand() % 100);</div><div class=\"line\">\t\tbreak;</div><div class=\"line\">\tcase 2:</div><div class=\"line\">\t\tp = new Magnificent(rand() % 100, &apos;A&apos; + rand() % 26);</div><div class=\"line\">\t\tbreak;</div><div class=\"line\">\t&#125; </div><div class=\"line\">\treturn p;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ol>\n<li>typeid运算符和typeinfo类<br>typeid运算符合sizeof有些相似，结构两种参数：类名、结果为对象的表达式。<br>typeid将返回一个对type_info对象的引用，type_info是在头文件typeinfo中定义的一个类，type_info重载了==和！=运算符，以便对类型进行比较。如果pg指向一个Magnificent对象，则下面结果为true，否则为false：<br><code>typeid(Magnificent) == typeid(*pg);</code>,那么问题又来了，如果pg是一个空指针呢，将引发bad_typeid异常。该异常是从exception类派生而来的，在typeinfo中声明的。<br>type_info类的实现随不同厂商而异，但包含一个name()成员，返回一个随实现而异的字符串。具体看下面的例子：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;iostream&gt;</div><div class=\"line\">#include &lt;cstdlib&gt;</div><div class=\"line\">#include &lt;ctime&gt;</div><div class=\"line\"></div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Grand&#123;</div><div class=\"line\">private:</div><div class=\"line\">\tint hold;</div><div class=\"line\">public:</div><div class=\"line\">\tGrand(int h = 0) : hold(h) &#123;&#125;</div><div class=\"line\">\tvirtual void Speak() const &#123; cout &lt;&lt; &quot;I am a grand class!\\n&quot;;&#125;</div><div class=\"line\">\tvirtual int Value() const &#123; return hold;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">class Superb : public Grand</div><div class=\"line\">&#123;</div><div class=\"line\">public:</div><div class=\"line\">\tSuperb(int h = 0) : Grand(h) &#123;&#125;</div><div class=\"line\">\tvoid Speak() const &#123;cout &lt;&lt; &quot;I am a Superb class!!\\n&quot;;&#125;</div><div class=\"line\">\tvirtual void Say() const &#123; cout &lt;&lt; &quot;I holde the superb value of &quot; &lt;&lt; Value() &lt;&lt; &quot;!!\\n&quot;;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">class Magnificent : public Superb</div><div class=\"line\">&#123;</div><div class=\"line\">private:</div><div class=\"line\">\tchar ch;</div><div class=\"line\">public:</div><div class=\"line\">\tMagnificent(int h = 0, char c = &apos;A&apos;) : Superb(h), ch(c) &#123;&#125;</div><div class=\"line\">\tvoid Speak() const &#123; cout &lt;&lt; &quot;I am a magnificent class \\n&quot;;&#125;</div><div class=\"line\">\tvoid Say() const &#123; cout &lt;&lt; &quot;I hold the character &quot; &lt;&lt; ch &lt;&lt; &quot;and the integer &quot; &lt;&lt; Value() &lt;&lt; &quot;\\n&quot;;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Grand * GetOne();</div><div class=\"line\"></div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">\tsrand(time(0));   //srand() cstdlib  time(0) ctime</div><div class=\"line\">\tGrand * pg;</div><div class=\"line\">\tSuperb * ps;</div><div class=\"line\">\tfor(int i = 0; i &lt; 5; i++)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tpg = GetOne();</div><div class=\"line\">\t\tcout &lt;&lt; &quot;Now processing type &quot; &lt;&lt; typeid(*pg).name() &lt;&lt; endl;</div><div class=\"line\">\t\tpg-&gt;Speak();</div><div class=\"line\">\t\tif(ps = dynamic_cast&lt;Superb *&gt;(pg))</div><div class=\"line\">\t\t\tps-&gt;Say();</div><div class=\"line\">\t\tif(typeid(Magnificent) ==typeid(*pg))</div><div class=\"line\">\t\t\tcout &lt;&lt; &quot;Yes, you&apos;re really magnificent.\\n&quot;;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tsystem(&quot;pause&quot;);</div><div class=\"line\">\treturn 0;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Grand * GetOne()</div><div class=\"line\">&#123;</div><div class=\"line\">\tGrand * p;</div><div class=\"line\">\tswitch(rand() % 3)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\tcase 0:</div><div class=\"line\">\t\tp = new Grand(rand() % 100);</div><div class=\"line\">\t\tbreak;</div><div class=\"line\">\tcase 1:</div><div class=\"line\">\t\tp = new Superb(rand() % 100);</div><div class=\"line\">\t\tbreak;</div><div class=\"line\">\tcase 2:</div><div class=\"line\">\t\tp = new Magnificent(rand() % 100, &apos;A&apos; + rand() % 26);</div><div class=\"line\">\t\tbreak;</div><div class=\"line\">\t&#125; </div><div class=\"line\">\treturn p;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><h2 id=\"嵌套类\"><a href=\"#嵌套类\" class=\"headerlink\" title=\"嵌套类\"></a>嵌套类</h2><p>这个内容并没有太多可讲的，需要重点关注的点：<b>嵌套类的作用域和访问控制</b>。</p>\n<h2 id=\"类型转换运算符\"><a href=\"#类型转换运算符\" class=\"headerlink\" title=\"类型转换运算符\"></a>类型转换运算符</h2><p>在RTTI中讲了一个类型转换运算符，但是还有几个其他的运算符,用法和dynamic_cast一样，运用的场景不一样而已：<br>dynamic_cast: 在类层次结构中进行向上转换，而不允许其他转换<br>const_cast： 用来修改类型的const或volatile属性。但是这个运算符没有很好的理解，可以改变类型，却又不能改变const的值，那么有什么用？？？<br>static_cast: <code>static_cast&lt;type-name&gt; (expression)</code>,仅当type-name可被隐式转换为expression所属类型或expression所属类型可被隐式转换为type-name，转换成立，否则将出错。有些不能隐式转换的也可使用static_cast强制转换，但是可能出错。同时也可以用于数值转换中。<br>reinterpret_cast：用于比如将一个long型数据转换为一个结构体（包含两个short型成员），这类危险转换依赖于底层编程技术，不可移植。</p>\n","excerpt":"<h1 id=\"友元\"><a href=\"#友元\" class=\"headerlink\" title=\"友元\"></a>友元</h1><h2 id=\"友元类\"><a href=\"#友元类\" class=\"headerlink\" title=\"友元类\"></a>友元类</h2><p>友元函数用于类的扩展接口，类并非只能拥有友元函数，还能够将类作为友元类。友元类的所有方法都可以访问原始类的私有成员和保护成员。<br>以电视机和遥控器的关系，解释友元的作用以及相关问题<br>","more":"</p>\n<h3 id=\"友元的声明\"><a href=\"#友元的声明\" class=\"headerlink\" title=\"友元的声明\"></a>友元的声明</h3><p>友元声明的位置无关紧要，可以在原始类的私有、公有或保护部分。简单示例如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">class TV</div><div class=\"line\">&#123;</div><div class=\"line\">private:</div><div class=\"line\">\tfriend class Remote;</div><div class=\"line\">\t...</div><div class=\"line\">&#125;;</div><div class=\"line\">class Remote</div><div class=\"line\">&#123;</div><div class=\"line\">\t...</div><div class=\"line\">public:</div><div class=\"line\">\tvoid set_chan(TV &amp; t);</div><div class=\"line\">\t...</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>如上面代码所示，只需要在原始类中任意位置<code>friend class Remote</code>，就可以声明友元类了。</p>\n<ol>\n<li><p>但是问题来了，Remote类中提到了TV类，，所以编译器必须先了解TV类，才能处理Remote类。上面的例子就是把TV的定义放在Remote前面。那么如果TV中包含了Remote成员函数，Remote中包含了TV类怎么办呢？？？这就用到前向声明(forward declaration)。【如果让Remote类成为友元类，是不用前向声明的，因为那条语句就说明Remote是个类】</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Remote;</div><div class=\"line\">class TV</div><div class=\"line\">&#123;</div><div class=\"line\">private:</div><div class=\"line\">\tfriend void Remote::set_chan(TV &amp; t);</div><div class=\"line\">\t...</div><div class=\"line\">&#125;;</div><div class=\"line\">class Remote</div><div class=\"line\">&#123;</div><div class=\"line\">\t...</div><div class=\"line\">public:</div><div class=\"line\">\tvoid set_chan(TV &amp; t);</div><div class=\"line\">\t...</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p>是上述代码这样吗？<b>显然，这样是错误的！！！</b>，因为虽然Remote的声明放在前面，但是编译器并没有看到随后TV类中Remote的那个方法的声明。正确打开方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">class TV;</div><div class=\"line\">class Remote</div><div class=\"line\">&#123;</div><div class=\"line\">\t...</div><div class=\"line\">public:</div><div class=\"line\">\tvoid set_chan(TV &amp; t);</div><div class=\"line\">\t...</div><div class=\"line\">&#125;;</div><div class=\"line\">class TV</div><div class=\"line\">&#123;</div><div class=\"line\">private:</div><div class=\"line\">\tfriend void Remote::set_chan(TV &amp; t);</div><div class=\"line\">\t...</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p>那么问题又来了，如果<code>void set_chan(TV &amp; t) {t.function();}</code>,这样就会造成2中提到的问题，就循环了。所以这里采用内联函数吧。<br>友元还有很多内容，比如两个类互相为友元，两个类有一个共同的友元等，处理原则和上面说的几个点一样：<b>在你使用某个类、某个类的成员函数之前，你声明这个类、这个成员函数了吗？编译器就是看一点。</b></p>\n<h1 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h1><p>异常就是像我这种程序猿给自己挖的坑，异常处理就是程序猿自己给自己兜底。程序运行会遇到很多异常情况导致程序无法运行下去，为了防止这种情况，就有了C++异常：为处理这些情况强大、灵活的工具。通常情况有这样几种处理方法。</p>\n<h2 id=\"调用abort\"><a href=\"#调用abort\" class=\"headerlink\" title=\"调用abort()\"></a>调用abort()</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;iostream&gt;</div><div class=\"line\">#include &lt;cstdlib&gt;  // abort() 函数头文件</div><div class=\"line\">using namespace std;</div><div class=\"line\">double hmean(double a, double b);</div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">\tdouble x, y, z;</div><div class=\"line\">\twhile(cin &gt;&gt; x &gt;&gt; y)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tz = hmean(x, y);</div><div class=\"line\">\t\tcout &lt;&lt; &quot;The harmonic mean of &quot; &lt;&lt; x &lt;&lt; &quot; and &quot; &lt;&lt; y  &lt;&lt; &quot; is &quot; &lt;&lt; z &lt;&lt; endl;</div><div class=\"line\">\t\tcout &lt;&lt; &quot;Please enter next set of numbers : &lt;q to quit&gt;: &quot; &lt;&lt; endl;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tcout &lt;&lt; &quot;Done.\\n&quot;;</div><div class=\"line\">\tsystem(&quot;pause&quot;);</div><div class=\"line\">\treturn 0;</div><div class=\"line\">&#125;</div><div class=\"line\">double hmean(double a, double b)</div><div class=\"line\">&#123;</div><div class=\"line\">\tif(a == -b)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tcout &lt;&lt; &quot;untenable arguments to hmean().\\n&quot;;</div><div class=\"line\">\t\tabort();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn 2.0 * a * b / ( a + b );</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这个例子就是求两个数a、b的调和平均数，但是a、b不能为相反数，如果有，程序就崩了，所以如果出现这种情况就调用abort();终止程序运行。【我并没有意识到这个有什么用】</p>\n<h2 id=\"返回错误码\"><a href=\"#返回错误码\" class=\"headerlink\" title=\"返回错误码\"></a>返回错误码</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;iostream&gt;</div><div class=\"line\">#include &lt;cfloat&gt;</div><div class=\"line\"></div><div class=\"line\">bool hmean(double a, double b, double * ans);</div><div class=\"line\"></div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">\tdouble x, y, z;</div><div class=\"line\">\tcout &lt;&lt; &quot;Please enter one set of number : &quot;;</div><div class=\"line\">\twhile(cin &gt;&gt; x &gt;&gt; y)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tif(hmean(x, y, &amp;z))</div><div class=\"line\">\t\t&#123;</div><div class=\"line\">\t\t\tcout &lt;&lt; &quot;Harmonic mean of &quot;&lt;&lt; x &lt;&lt; &quot; and &quot; &lt;&lt; y &lt;&lt; &quot; is &quot; &lt;&lt; z &lt;&lt; endl;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\telse</div><div class=\"line\">\t\t&#123;</div><div class=\"line\">\t\t\tcout &lt;&lt; &quot;One value should not be the negative of the other - try again.\\n&quot;;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tcout &lt;&lt; &quot;Please enter next set of numbers &lt;q to quit &gt;: &quot;;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tsystem(&quot;pause&quot;);</div><div class=\"line\">\treturn 0;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">bool hmean(double a, double b, double * ans)</div><div class=\"line\">&#123;</div><div class=\"line\">\tif(a == -b)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t*ans == DBL_MAX;</div><div class=\"line\">\t\treturn false;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\telse</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\t*ans = 2.0 * a * b /(a + b);</div><div class=\"line\">\t\treturn true;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这个例子和上面那个例子没有什么区别，就是检测到如果为相反数，不调用abort(),而是返回一个false……………………………………【我也没有感觉这个有什么用】</p>\n<h2 id=\"异常机制-try–catch\"><a href=\"#异常机制-try–catch\" class=\"headerlink\" title=\"异常机制 try–catch\"></a>异常机制 try–catch</h2><p>C++异常对异常的处理由3各部分：<br><b>引发异常</b>。程序出现问题时将引发异常，之前两种方法在异常引发后，是调用abort终止了程序，但是throw语句是跳转，即命令程序跳转到另一条语句。throw关键字表示引发异常，参数表示异常的特征，用以指导处理。<br><b>使用处理程序捕获异常</b>。采用异常处理程序捕获异常，catch关键字表示捕获异常，其参数指出异常处理程序要响应的异常类型。异常处理程序也叫catch块。<br><b>使用try块</b>。try块表示可能会引发异常的代码块，表面需要注意这些代码引发的异常；它后面跟多个catch块，表明try块引发的异常由这些catch块处理。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;iostream&gt;</div><div class=\"line\">#include &lt;string&gt;</div><div class=\"line\">double hmean(double a, double b);</div><div class=\"line\"></div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">\tdouble x, y, z;</div><div class=\"line\">\tcout &lt;&lt; &quot;Enter one set of numbers : &quot;;</div><div class=\"line\">\twhile(cin &gt;&gt; x &gt;&gt; y)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\ttry&#123;</div><div class=\"line\">\t\t\tz = hmean(x, y);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tcatch(const char * s)</div><div class=\"line\">\t\t&#123;</div><div class=\"line\">\t\t\tcout &lt;&lt; s &lt;&lt; endl;</div><div class=\"line\">\t\t\tcout &lt;&lt; &quot;Enter next set of numbers : &quot;;</div><div class=\"line\">\t\t\tcontinue;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tcout &lt;&lt; &quot;Harmonic mean of &quot; &lt;&lt; x &lt;&lt; &quot; and &quot; &lt;&lt; y &lt;&lt; &quot; is &quot; &lt;&lt; z &lt;&lt; endl;</div><div class=\"line\">\t\tcout &lt;&lt; &quot;Enter next set of numbers : &quot;;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tsystem(&quot;pause&quot;);</div><div class=\"line\">\treturn 0;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">double hmean(double a, double b)</div><div class=\"line\">&#123;</div><div class=\"line\">\tif(a == -b)</div><div class=\"line\">\t\tthrow &quot;bad hmean() arguments&quot;;</div><div class=\"line\">\treturn 2.0 * a * b /(a + b);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这个例子和前面的两个一样。但是处理方法采用了try-catch的方法，就是检测到是相反数，就抛出异常(throw “bad hmean() arguments”;),然后根据这个抛出的异常信息，在catch中找到对应的catch处理部分。<b>需要注意的是，执行throw语句类似于执行返回语句，因为它也将终止函数的执行，但是throw不是返回至调用程序的地方，而是使程序沿函数调用序列后退，直至try块函数。</b>在寻找与异常类型匹配的异常处理程序（catch块）。如果没有引发异常，则跳过catch块。<br>还有就是，也可以将对象作为异常类型throw掉……………………具体实现方法和上面差不多。</p>\n<h2 id=\"异常规范\"><a href=\"#异常规范\" class=\"headerlink\" title=\"异常规范\"></a>异常规范</h2><p>C++11把异常规范从标准中剔除了，感兴趣有时间可以看看。</p>\n<h1 id=\"运行阶段类型识别-RTTI\"><a href=\"#运行阶段类型识别-RTTI\" class=\"headerlink\" title=\"运行阶段类型识别(RTTI)\"></a>运行阶段类型识别(RTTI)</h1><p>RTTI（Runtime Type Identification）是运行阶段类型识别，简单点就是在运行阶段确定对象的类型的一种标准方法。<br>在实际编程中，会遇到这样的情况，在总多类层次结构中，我们会选择使用基类指针来指向其中任意的派生类对象，但是问题来了，我想使用某个类的成员函数，那么这个指针能否直接调用这个函数呢，我们就会搞忘这个指针指向的到底是什么对象类型？？？当然如果这个函数是类层次结构中所有成员都拥有的虚函数，就无所谓了。</p>\n<h2 id=\"RTTI的工作原理\"><a href=\"#RTTI的工作原理\" class=\"headerlink\" title=\"RTTI的工作原理\"></a>RTTI的工作原理</h2><p>C++有3个支持RTTI的元素：dynamic_cast运算符、typeid运算符、type_info结构。</p>\n<ol>\n<li>dynamic_cast<br>dynamic_cast运算符，如果可以，使用一个指向基类的指针来生成一个派生类指针；否则，返回空指针。<br>假设有如下的类层次结构：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Grand &#123;//has virtual methods&#125;;</div><div class=\"line\">class Superb : public Grand &#123;&#125;</div><div class=\"line\">class Magnificent : public Superb &#123;&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>有如下指针：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">Grand * pg = new Grand;</div><div class=\"line\">Grand * ps = new Superb;</div><div class=\"line\">Grand * pm = new Magnificent;</div><div class=\"line\"></div><div class=\"line\">Magnificent * p1 = (Magnificent *) pm;  //#1</div><div class=\"line\">Magnificent * p2 = (Magnificent *) pg;  //#2</div><div class=\"line\">Superb * p3 = (Magnificent *) pm;       //#3</div></pre></td></tr></table></figure></p>\n<p>可以得到的是，以上三种指针转换第一种和第三种是正确的，但是第二种是错误，因为pg是基类指针，强制转换为派生类指针，要求其可以调用派生类方法，显然会导致错误。<br>需要注意的是，与“指针指向的是什么类型的对象”相比，问题“类型转换是否安全正确”更加通用。因此来看看dynamic_cast的用法。<br><code>Superb * pm = dynamic_cast&lt;Super *&gt; pg;</code>,这各语句就指出pg能否安全的转换为Superb *，，如果可以赋值给pm， 如果不可以，pm被赋值为空指针；<br>具体的来看一个详细的例子：：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div></pre></td><td class=\"code\"><pre><div class=\"line\">// dynamic_case\\&lt;\\&gt; 也可以用于引用，但是与指针用法稍有不同：没有与空指针对于的引用值，无法使用特殊的引用值指示失败，因此dynamic_case将引发bad_cast的异常 P646</div><div class=\"line\">#include &lt;iostream&gt;</div><div class=\"line\">#include &lt;cstdlib&gt;</div><div class=\"line\">#include &lt;ctime&gt;</div><div class=\"line\"></div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Grand&#123;</div><div class=\"line\">private:</div><div class=\"line\">\tint hold;</div><div class=\"line\">public:</div><div class=\"line\">\tGrand(int h = 0) : hold(h) &#123;&#125;</div><div class=\"line\">\tvirtual void Speak() const &#123; cout &lt;&lt; &quot;I am a grand class!\\n&quot;;&#125;</div><div class=\"line\">\tvirtual int Value() const &#123; return hold;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">class Superb : public Grand</div><div class=\"line\">&#123;</div><div class=\"line\">public:</div><div class=\"line\">\tSuperb(int h = 0) : Grand(h) &#123;&#125;</div><div class=\"line\">\tvoid Speak() const &#123;cout &lt;&lt; &quot;I am a Superb class!!\\n&quot;;&#125;</div><div class=\"line\">\tvirtual void Say() const &#123; cout &lt;&lt; &quot;I holde the superb value of &quot; &lt;&lt; Value() &lt;&lt; &quot;!!\\n&quot;;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">class Magnificent : public Superb</div><div class=\"line\">&#123;</div><div class=\"line\">private:</div><div class=\"line\">\tchar ch;</div><div class=\"line\">public:</div><div class=\"line\">\tMagnificent(int h = 0, char c = &apos;A&apos;) : Superb(h), ch(c) &#123;&#125;</div><div class=\"line\">\tvoid Speak() const &#123; cout &lt;&lt; &quot;I am a magnificent class \\n&quot;;&#125;</div><div class=\"line\">\tvoid Say() const &#123; cout &lt;&lt; &quot;I hold the character &quot; &lt;&lt; ch &lt;&lt; &quot;and the integer &quot; &lt;&lt; Value() &lt;&lt; &quot;\\n&quot;;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Grand * GetOne();</div><div class=\"line\"></div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">\tsrand(time(0));   //srand() cstdlib  time(0) ctime</div><div class=\"line\">\tGrand * pg;</div><div class=\"line\">\tSuperb * ps;</div><div class=\"line\">\tfor(int i = 0; i &lt; 5; i++)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tpg = GetOne();</div><div class=\"line\">\t\tpg-&gt;Speak();</div><div class=\"line\">\t\tif(ps = dynamic_cast&lt;Superb * &gt;(pg))</div><div class=\"line\">\t\t\tps-&gt;Say();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tsystem(&quot;pause&quot;);</div><div class=\"line\">\treturn 0;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Grand * GetOne()</div><div class=\"line\">&#123;</div><div class=\"line\">\tGrand * p;</div><div class=\"line\">\tswitch(rand() % 3)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\tcase 0:</div><div class=\"line\">\t\tp = new Grand(rand() % 100);</div><div class=\"line\">\t\tbreak;</div><div class=\"line\">\tcase 1:</div><div class=\"line\">\t\tp = new Superb(rand() % 100);</div><div class=\"line\">\t\tbreak;</div><div class=\"line\">\tcase 2:</div><div class=\"line\">\t\tp = new Magnificent(rand() % 100, &apos;A&apos; + rand() % 26);</div><div class=\"line\">\t\tbreak;</div><div class=\"line\">\t&#125; </div><div class=\"line\">\treturn p;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ol>\n<li>typeid运算符和typeinfo类<br>typeid运算符合sizeof有些相似，结构两种参数：类名、结果为对象的表达式。<br>typeid将返回一个对type_info对象的引用，type_info是在头文件typeinfo中定义的一个类，type_info重载了==和！=运算符，以便对类型进行比较。如果pg指向一个Magnificent对象，则下面结果为true，否则为false：<br><code>typeid(Magnificent) == typeid(*pg);</code>,那么问题又来了，如果pg是一个空指针呢，将引发bad_typeid异常。该异常是从exception类派生而来的，在typeinfo中声明的。<br>type_info类的实现随不同厂商而异，但包含一个name()成员，返回一个随实现而异的字符串。具体看下面的例子：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &lt;iostream&gt;</div><div class=\"line\">#include &lt;cstdlib&gt;</div><div class=\"line\">#include &lt;ctime&gt;</div><div class=\"line\"></div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">class Grand&#123;</div><div class=\"line\">private:</div><div class=\"line\">\tint hold;</div><div class=\"line\">public:</div><div class=\"line\">\tGrand(int h = 0) : hold(h) &#123;&#125;</div><div class=\"line\">\tvirtual void Speak() const &#123; cout &lt;&lt; &quot;I am a grand class!\\n&quot;;&#125;</div><div class=\"line\">\tvirtual int Value() const &#123; return hold;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">class Superb : public Grand</div><div class=\"line\">&#123;</div><div class=\"line\">public:</div><div class=\"line\">\tSuperb(int h = 0) : Grand(h) &#123;&#125;</div><div class=\"line\">\tvoid Speak() const &#123;cout &lt;&lt; &quot;I am a Superb class!!\\n&quot;;&#125;</div><div class=\"line\">\tvirtual void Say() const &#123; cout &lt;&lt; &quot;I holde the superb value of &quot; &lt;&lt; Value() &lt;&lt; &quot;!!\\n&quot;;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">class Magnificent : public Superb</div><div class=\"line\">&#123;</div><div class=\"line\">private:</div><div class=\"line\">\tchar ch;</div><div class=\"line\">public:</div><div class=\"line\">\tMagnificent(int h = 0, char c = &apos;A&apos;) : Superb(h), ch(c) &#123;&#125;</div><div class=\"line\">\tvoid Speak() const &#123; cout &lt;&lt; &quot;I am a magnificent class \\n&quot;;&#125;</div><div class=\"line\">\tvoid Say() const &#123; cout &lt;&lt; &quot;I hold the character &quot; &lt;&lt; ch &lt;&lt; &quot;and the integer &quot; &lt;&lt; Value() &lt;&lt; &quot;\\n&quot;;&#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Grand * GetOne();</div><div class=\"line\"></div><div class=\"line\">int main()</div><div class=\"line\">&#123;</div><div class=\"line\">\tsrand(time(0));   //srand() cstdlib  time(0) ctime</div><div class=\"line\">\tGrand * pg;</div><div class=\"line\">\tSuperb * ps;</div><div class=\"line\">\tfor(int i = 0; i &lt; 5; i++)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\t\tpg = GetOne();</div><div class=\"line\">\t\tcout &lt;&lt; &quot;Now processing type &quot; &lt;&lt; typeid(*pg).name() &lt;&lt; endl;</div><div class=\"line\">\t\tpg-&gt;Speak();</div><div class=\"line\">\t\tif(ps = dynamic_cast&lt;Superb *&gt;(pg))</div><div class=\"line\">\t\t\tps-&gt;Say();</div><div class=\"line\">\t\tif(typeid(Magnificent) ==typeid(*pg))</div><div class=\"line\">\t\t\tcout &lt;&lt; &quot;Yes, you&apos;re really magnificent.\\n&quot;;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tsystem(&quot;pause&quot;);</div><div class=\"line\">\treturn 0;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">Grand * GetOne()</div><div class=\"line\">&#123;</div><div class=\"line\">\tGrand * p;</div><div class=\"line\">\tswitch(rand() % 3)</div><div class=\"line\">\t&#123;</div><div class=\"line\">\tcase 0:</div><div class=\"line\">\t\tp = new Grand(rand() % 100);</div><div class=\"line\">\t\tbreak;</div><div class=\"line\">\tcase 1:</div><div class=\"line\">\t\tp = new Superb(rand() % 100);</div><div class=\"line\">\t\tbreak;</div><div class=\"line\">\tcase 2:</div><div class=\"line\">\t\tp = new Magnificent(rand() % 100, &apos;A&apos; + rand() % 26);</div><div class=\"line\">\t\tbreak;</div><div class=\"line\">\t&#125; </div><div class=\"line\">\treturn p;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><h2 id=\"嵌套类\"><a href=\"#嵌套类\" class=\"headerlink\" title=\"嵌套类\"></a>嵌套类</h2><p>这个内容并没有太多可讲的，需要重点关注的点：<b>嵌套类的作用域和访问控制</b>。</p>\n<h2 id=\"类型转换运算符\"><a href=\"#类型转换运算符\" class=\"headerlink\" title=\"类型转换运算符\"></a>类型转换运算符</h2><p>在RTTI中讲了一个类型转换运算符，但是还有几个其他的运算符,用法和dynamic_cast一样，运用的场景不一样而已：<br>dynamic_cast: 在类层次结构中进行向上转换，而不允许其他转换<br>const_cast： 用来修改类型的const或volatile属性。但是这个运算符没有很好的理解，可以改变类型，却又不能改变const的值，那么有什么用？？？<br>static_cast: <code>static_cast&lt;type-name&gt; (expression)</code>,仅当type-name可被隐式转换为expression所属类型或expression所属类型可被隐式转换为type-name，转换成立，否则将出错。有些不能隐式转换的也可使用static_cast强制转换，但是可能出错。同时也可以用于数值转换中。<br>reinterpret_cast：用于比如将一个long型数据转换为一个结构体（包含两个short型成员），这类危险转换依赖于底层编程技术，不可移植。</p>"},{"title":"虚函数的工作原理","date":"2017-03-11T23:09:16.000Z","comments":1,"_content":"+ 为什么需要虚函数？\n在编写程序的过程中，一定会遇到这样的场景。派生类继承了基类的方法,但是我们希望同一个方法在派生类和基类中的行为不同，就是方法取决于调用的对象（这种复杂的行为就是多态）。实现多态的公有继承有两种重要的机制。\n1. 在派生类中重新定义基类方法 （可以定义不同方法）\n2. 虚函数 （可以使基类引用或指针可以调用派生类新定义的方法）\n\n+ 虚函数基本语法？\n在需要重新定义的方法前添加关键字 virtual，然后分别定义即可。\n\n+ 编译器如何确定作者想使用哪种方法？\n```\nclass person{\n\tvirtual void show();  //具体定义就不写了，反正和派生类不一样\n};\nclass student : public person{\n\tvirtual void show();  \n};\nperson temp_person(……);  //构造函数，实例化一个对象\nstudent temp_student(……);\ntemp_person.show();    //person::show()\ntemp_student.show();   //student::show()\nperson & temp_s = temp_student; \nperson & temp_p = temp_person;\ntemp_s.show();         //person::show()\ntemp_p.show();         //student::show()\n```\n如上述代码所示，基类和派生类有不一样的方法，那么我在使用的时候，我怎么判断调用的是哪个方法。\n如果使用virtual,根据引用或指针指向的对象类型来选择方法。\n如果不是使用virtual，根据引用或指针的类型来选择方法。（这个没有太懂，来自C++ primer plus p493，如果重名了，参数列表还相同……感觉死机了额）\n```\nclass person{\n\tvoid show();  \n};\nclass student : public person{\n\tvoid show();  //这里涉及隐藏规则，具体在 effective C++ third edition p156\n};\nperson temp_person(……);  //构造函数，实例化一个对象\nstudent temp_student(……);\ntemp_person.show();    //person::show()\ntemp_student.show();   //student::show()\nperson & temp_s = temp_student; \nperson & temp_p = temp_person;\ntemp_s.show();         //person::show()  \ntemp_p.show();         //person::show()  这里不确定呀\n```\n+ 实现原理\n如果使用了虚函数，编译器将给<b>每个对象</b>添加一个隐藏成员，这个隐藏成员保存了一个指向函数地址数组的指针。而这个被指向的函数地址数组，我们叫做虚函数表(virtual function table, vtbl)。\n虚函数表存储了为类对象进行申明的虚函数地址。例如基类对象包含一个指针，该指针指向一个装有虚函数地址的数组，这个数组中把每个基类虚函数的地址都存储起来；一个派生类对象也包含一个指针，同样指向装有虚函数地址的数组，这个数组不仅包含了基类的虚函数地址，也包含了派生类的虚函数地址。同时如果派生类对象中虚函数重新定义了，那么派生类的虚函数表中该虚函数的地址被更新；如果派生类中没有对基类虚函数重新定义，那么虚函数表中将存储虚函数原始版本的地址（就是基类版本）；如果派生类对象新定义了虚函数，该虚函数地址将被添加到虚函数表中。\n如果还不明白，如下：\n```\nclass Scientist{\n\t...\n\tchar name[40];\npublic:\n\tvirtual void show_name();\n\tvirtual void show_all();\n\t...\n};\nclass Physicist : public Scientist{\n\t\n\t...\n\tchar field[40];\npublic:\n\tvoid show_all();           //重定义了基类方法，vtbl将改变原本指向的地址\n\tvirtual void show_field(); //new function\n};\n```\n![虚函数工作机制](http://oapeb119y.bkt.clouddn.com/image/CPP/virtual_function%E8%99%9A%E5%87%BD%E6%95%B0%E6%9C%BA%E5%88%B6.png)\n","source":"_posts/CPP/虚函数的工作原理.md","raw":"---\ntitle: 虚函数的工作原理\ndate: 2017-03-12 07:09:16\ncategories:\n- 技术\ntags:\n- c++\ncomments: true\n---\n+ 为什么需要虚函数？\n在编写程序的过程中，一定会遇到这样的场景。派生类继承了基类的方法,但是我们希望同一个方法在派生类和基类中的行为不同，就是方法取决于调用的对象（这种复杂的行为就是多态）。实现多态的公有继承有两种重要的机制。\n1. 在派生类中重新定义基类方法 （可以定义不同方法）\n2. 虚函数 （可以使基类引用或指针可以调用派生类新定义的方法）\n\n+ 虚函数基本语法？\n在需要重新定义的方法前添加关键字 virtual，然后分别定义即可。\n\n+ 编译器如何确定作者想使用哪种方法？\n```\nclass person{\n\tvirtual void show();  //具体定义就不写了，反正和派生类不一样\n};\nclass student : public person{\n\tvirtual void show();  \n};\nperson temp_person(……);  //构造函数，实例化一个对象\nstudent temp_student(……);\ntemp_person.show();    //person::show()\ntemp_student.show();   //student::show()\nperson & temp_s = temp_student; \nperson & temp_p = temp_person;\ntemp_s.show();         //person::show()\ntemp_p.show();         //student::show()\n```\n如上述代码所示，基类和派生类有不一样的方法，那么我在使用的时候，我怎么判断调用的是哪个方法。\n如果使用virtual,根据引用或指针指向的对象类型来选择方法。\n如果不是使用virtual，根据引用或指针的类型来选择方法。（这个没有太懂，来自C++ primer plus p493，如果重名了，参数列表还相同……感觉死机了额）\n```\nclass person{\n\tvoid show();  \n};\nclass student : public person{\n\tvoid show();  //这里涉及隐藏规则，具体在 effective C++ third edition p156\n};\nperson temp_person(……);  //构造函数，实例化一个对象\nstudent temp_student(……);\ntemp_person.show();    //person::show()\ntemp_student.show();   //student::show()\nperson & temp_s = temp_student; \nperson & temp_p = temp_person;\ntemp_s.show();         //person::show()  \ntemp_p.show();         //person::show()  这里不确定呀\n```\n+ 实现原理\n如果使用了虚函数，编译器将给<b>每个对象</b>添加一个隐藏成员，这个隐藏成员保存了一个指向函数地址数组的指针。而这个被指向的函数地址数组，我们叫做虚函数表(virtual function table, vtbl)。\n虚函数表存储了为类对象进行申明的虚函数地址。例如基类对象包含一个指针，该指针指向一个装有虚函数地址的数组，这个数组中把每个基类虚函数的地址都存储起来；一个派生类对象也包含一个指针，同样指向装有虚函数地址的数组，这个数组不仅包含了基类的虚函数地址，也包含了派生类的虚函数地址。同时如果派生类对象中虚函数重新定义了，那么派生类的虚函数表中该虚函数的地址被更新；如果派生类中没有对基类虚函数重新定义，那么虚函数表中将存储虚函数原始版本的地址（就是基类版本）；如果派生类对象新定义了虚函数，该虚函数地址将被添加到虚函数表中。\n如果还不明白，如下：\n```\nclass Scientist{\n\t...\n\tchar name[40];\npublic:\n\tvirtual void show_name();\n\tvirtual void show_all();\n\t...\n};\nclass Physicist : public Scientist{\n\t\n\t...\n\tchar field[40];\npublic:\n\tvoid show_all();           //重定义了基类方法，vtbl将改变原本指向的地址\n\tvirtual void show_field(); //new function\n};\n```\n![虚函数工作机制](http://oapeb119y.bkt.clouddn.com/image/CPP/virtual_function%E8%99%9A%E5%87%BD%E6%95%B0%E6%9C%BA%E5%88%B6.png)\n","slug":"CPP/虚函数的工作原理","published":1,"updated":"2017-05-29T15:22:55.885Z","layout":"post","photos":[],"link":"","_id":"cj3aal9sw000r094uhap299s2","content":"<ul>\n<li>为什么需要虚函数？<br>在编写程序的过程中，一定会遇到这样的场景。派生类继承了基类的方法,但是我们希望同一个方法在派生类和基类中的行为不同，就是方法取决于调用的对象（这种复杂的行为就是多态）。实现多态的公有继承有两种重要的机制。</li>\n</ul>\n<ol>\n<li>在派生类中重新定义基类方法 （可以定义不同方法）</li>\n<li>虚函数 （可以使基类引用或指针可以调用派生类新定义的方法）</li>\n</ol>\n<ul>\n<li><p>虚函数基本语法？<br>在需要重新定义的方法前添加关键字 virtual，然后分别定义即可。</p>\n</li>\n<li><p>编译器如何确定作者想使用哪种方法？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">class person&#123;</div><div class=\"line\">\tvirtual void show();  //具体定义就不写了，反正和派生类不一样</div><div class=\"line\">&#125;;</div><div class=\"line\">class student : public person&#123;</div><div class=\"line\">\tvirtual void show();  </div><div class=\"line\">&#125;;</div><div class=\"line\">person temp_person(……);  //构造函数，实例化一个对象</div><div class=\"line\">student temp_student(……);</div><div class=\"line\">temp_person.show();    //person::show()</div><div class=\"line\">temp_student.show();   //student::show()</div><div class=\"line\">person &amp; temp_s = temp_student; </div><div class=\"line\">person &amp; temp_p = temp_person;</div><div class=\"line\">temp_s.show();         //person::show()</div><div class=\"line\">temp_p.show();         //student::show()</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>如上述代码所示，基类和派生类有不一样的方法，那么我在使用的时候，我怎么判断调用的是哪个方法。<br>如果使用virtual,根据引用或指针指向的对象类型来选择方法。<br>如果不是使用virtual，根据引用或指针的类型来选择方法。（这个没有太懂，来自C++ primer plus p493，如果重名了，参数列表还相同……感觉死机了额）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">class person&#123;</div><div class=\"line\">\tvoid show();  </div><div class=\"line\">&#125;;</div><div class=\"line\">class student : public person&#123;</div><div class=\"line\">\tvoid show();  //这里涉及隐藏规则，具体在 effective C++ third edition p156</div><div class=\"line\">&#125;;</div><div class=\"line\">person temp_person(……);  //构造函数，实例化一个对象</div><div class=\"line\">student temp_student(……);</div><div class=\"line\">temp_person.show();    //person::show()</div><div class=\"line\">temp_student.show();   //student::show()</div><div class=\"line\">person &amp; temp_s = temp_student; </div><div class=\"line\">person &amp; temp_p = temp_person;</div><div class=\"line\">temp_s.show();         //person::show()  </div><div class=\"line\">temp_p.show();         //person::show()  这里不确定呀</div></pre></td></tr></table></figure></p>\n<ul>\n<li>实现原理<br>如果使用了虚函数，编译器将给<b>每个对象</b>添加一个隐藏成员，这个隐藏成员保存了一个指向函数地址数组的指针。而这个被指向的函数地址数组，我们叫做虚函数表(virtual function table, vtbl)。<br>虚函数表存储了为类对象进行申明的虚函数地址。例如基类对象包含一个指针，该指针指向一个装有虚函数地址的数组，这个数组中把每个基类虚函数的地址都存储起来；一个派生类对象也包含一个指针，同样指向装有虚函数地址的数组，这个数组不仅包含了基类的虚函数地址，也包含了派生类的虚函数地址。同时如果派生类对象中虚函数重新定义了，那么派生类的虚函数表中该虚函数的地址被更新；如果派生类中没有对基类虚函数重新定义，那么虚函数表中将存储虚函数原始版本的地址（就是基类版本）；如果派生类对象新定义了虚函数，该虚函数地址将被添加到虚函数表中。<br>如果还不明白，如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Scientist&#123;</div><div class=\"line\">\t...</div><div class=\"line\">\tchar name[40];</div><div class=\"line\">public:</div><div class=\"line\">\tvirtual void show_name();</div><div class=\"line\">\tvirtual void show_all();</div><div class=\"line\">\t...</div><div class=\"line\">&#125;;</div><div class=\"line\">class Physicist : public Scientist&#123;</div><div class=\"line\">\t</div><div class=\"line\">\t...</div><div class=\"line\">\tchar field[40];</div><div class=\"line\">public:</div><div class=\"line\">\tvoid show_all();           //重定义了基类方法，vtbl将改变原本指向的地址</div><div class=\"line\">\tvirtual void show_field(); //new function</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"http://oapeb119y.bkt.clouddn.com/image/CPP/virtual_function%E8%99%9A%E5%87%BD%E6%95%B0%E6%9C%BA%E5%88%B6.png\" alt=\"虚函数工作机制\"></p>\n","excerpt":"","more":"<ul>\n<li>为什么需要虚函数？<br>在编写程序的过程中，一定会遇到这样的场景。派生类继承了基类的方法,但是我们希望同一个方法在派生类和基类中的行为不同，就是方法取决于调用的对象（这种复杂的行为就是多态）。实现多态的公有继承有两种重要的机制。</li>\n</ul>\n<ol>\n<li>在派生类中重新定义基类方法 （可以定义不同方法）</li>\n<li>虚函数 （可以使基类引用或指针可以调用派生类新定义的方法）</li>\n</ol>\n<ul>\n<li><p>虚函数基本语法？<br>在需要重新定义的方法前添加关键字 virtual，然后分别定义即可。</p>\n</li>\n<li><p>编译器如何确定作者想使用哪种方法？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">class person&#123;</div><div class=\"line\">\tvirtual void show();  //具体定义就不写了，反正和派生类不一样</div><div class=\"line\">&#125;;</div><div class=\"line\">class student : public person&#123;</div><div class=\"line\">\tvirtual void show();  </div><div class=\"line\">&#125;;</div><div class=\"line\">person temp_person(……);  //构造函数，实例化一个对象</div><div class=\"line\">student temp_student(……);</div><div class=\"line\">temp_person.show();    //person::show()</div><div class=\"line\">temp_student.show();   //student::show()</div><div class=\"line\">person &amp; temp_s = temp_student; </div><div class=\"line\">person &amp; temp_p = temp_person;</div><div class=\"line\">temp_s.show();         //person::show()</div><div class=\"line\">temp_p.show();         //student::show()</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>如上述代码所示，基类和派生类有不一样的方法，那么我在使用的时候，我怎么判断调用的是哪个方法。<br>如果使用virtual,根据引用或指针指向的对象类型来选择方法。<br>如果不是使用virtual，根据引用或指针的类型来选择方法。（这个没有太懂，来自C++ primer plus p493，如果重名了，参数列表还相同……感觉死机了额）<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">class person&#123;</div><div class=\"line\">\tvoid show();  </div><div class=\"line\">&#125;;</div><div class=\"line\">class student : public person&#123;</div><div class=\"line\">\tvoid show();  //这里涉及隐藏规则，具体在 effective C++ third edition p156</div><div class=\"line\">&#125;;</div><div class=\"line\">person temp_person(……);  //构造函数，实例化一个对象</div><div class=\"line\">student temp_student(……);</div><div class=\"line\">temp_person.show();    //person::show()</div><div class=\"line\">temp_student.show();   //student::show()</div><div class=\"line\">person &amp; temp_s = temp_student; </div><div class=\"line\">person &amp; temp_p = temp_person;</div><div class=\"line\">temp_s.show();         //person::show()  </div><div class=\"line\">temp_p.show();         //person::show()  这里不确定呀</div></pre></td></tr></table></figure></p>\n<ul>\n<li>实现原理<br>如果使用了虚函数，编译器将给<b>每个对象</b>添加一个隐藏成员，这个隐藏成员保存了一个指向函数地址数组的指针。而这个被指向的函数地址数组，我们叫做虚函数表(virtual function table, vtbl)。<br>虚函数表存储了为类对象进行申明的虚函数地址。例如基类对象包含一个指针，该指针指向一个装有虚函数地址的数组，这个数组中把每个基类虚函数的地址都存储起来；一个派生类对象也包含一个指针，同样指向装有虚函数地址的数组，这个数组不仅包含了基类的虚函数地址，也包含了派生类的虚函数地址。同时如果派生类对象中虚函数重新定义了，那么派生类的虚函数表中该虚函数的地址被更新；如果派生类中没有对基类虚函数重新定义，那么虚函数表中将存储虚函数原始版本的地址（就是基类版本）；如果派生类对象新定义了虚函数，该虚函数地址将被添加到虚函数表中。<br>如果还不明白，如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Scientist&#123;</div><div class=\"line\">\t...</div><div class=\"line\">\tchar name[40];</div><div class=\"line\">public:</div><div class=\"line\">\tvirtual void show_name();</div><div class=\"line\">\tvirtual void show_all();</div><div class=\"line\">\t...</div><div class=\"line\">&#125;;</div><div class=\"line\">class Physicist : public Scientist&#123;</div><div class=\"line\">\t</div><div class=\"line\">\t...</div><div class=\"line\">\tchar field[40];</div><div class=\"line\">public:</div><div class=\"line\">\tvoid show_all();           //重定义了基类方法，vtbl将改变原本指向的地址</div><div class=\"line\">\tvirtual void show_field(); //new function</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"http://oapeb119y.bkt.clouddn.com/image/CPP/virtual_function%E8%99%9A%E5%87%BD%E6%95%B0%E6%9C%BA%E5%88%B6.png\" alt=\"虚函数工作机制\"></p>\n"},{"title":"202.happy number","date":"2016-12-23T02:08:24.000Z","comments":1,"_content":"\n+ write an algorithm to determine if a number is 'happy'\n\n+ A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay),or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.\n\n<b>Example:</b> 19 is a happy number\n\n```\n           1^2 + 9^2 = 82\n           8^2 + 2^2 = 68\n           6^2 + 8^2 = 100\n           1^2 + 0^2 + 0^2 = 1\n```\n\n# 解析\n+ <b>翻译</b>： 判断一个正整数是否为一个happy-number，一个正整数各位的平方和代替次正整数，不断迭代，如果迭代出1，则为happy-number，否则不是而且会出现无限循环。\n<!--more-->\n+ <b>思路</b>：写一个函数分离正整数的各位，计算平方和并返回，主函数中需要有两类迭代，一类迭代每次迭代一次，一类迭代两次，这两如果出现无限重复循环肯定OK；循环结束的条件为迭代结果为1（这就是happy number）或者两类迭代结果相等（出现无限重复循环，不是happy number）。\n\n## C/C++\n\n```cpp\n\tint sum(int n) {\n\t    int i=0;\n\t    int sum=0;\n\t    while(n) {\n\t        i=n%10;\n\t        n=n/10;\n\t        sum=sum+i*i;\n\t    }\n\t    return sum;\n\t}\n\n\tbool isHappy(int n) {\n\t    int temp=n;\n\t    bool overflag=true;\n\t    bool flag=true;\n\t    int temp1= temp;   \n\t    while(overflag) {\n\t      temp = sum(temp); \n\t      temp1=sum(temp1);\n\t      temp1=sum(temp1);\n\t      if(temp1==1) {       \n\t          flag=true;\n\t          break;\n\t      }\n\t      if(temp==temp1) {   \n\t          flag=false;\n\t          break;\n\t      }\n\t    }\n\t    return flag;\n\t}\n```\n\n## Python\n## Java\n","source":"_posts/Leetcode/202-happy-number-md.md","raw":"---\ntitle: 202.happy number\ndate: 2016-12-23 10:08:24\ncategories:\n- 技术\ntags:\n- leetcode\n- 数据结构与算法\ncomments: true\n---\n\n+ write an algorithm to determine if a number is 'happy'\n\n+ A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay),or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.\n\n<b>Example:</b> 19 is a happy number\n\n```\n           1^2 + 9^2 = 82\n           8^2 + 2^2 = 68\n           6^2 + 8^2 = 100\n           1^2 + 0^2 + 0^2 = 1\n```\n\n# 解析\n+ <b>翻译</b>： 判断一个正整数是否为一个happy-number，一个正整数各位的平方和代替次正整数，不断迭代，如果迭代出1，则为happy-number，否则不是而且会出现无限循环。\n<!--more-->\n+ <b>思路</b>：写一个函数分离正整数的各位，计算平方和并返回，主函数中需要有两类迭代，一类迭代每次迭代一次，一类迭代两次，这两如果出现无限重复循环肯定OK；循环结束的条件为迭代结果为1（这就是happy number）或者两类迭代结果相等（出现无限重复循环，不是happy number）。\n\n## C/C++\n\n```cpp\n\tint sum(int n) {\n\t    int i=0;\n\t    int sum=0;\n\t    while(n) {\n\t        i=n%10;\n\t        n=n/10;\n\t        sum=sum+i*i;\n\t    }\n\t    return sum;\n\t}\n\n\tbool isHappy(int n) {\n\t    int temp=n;\n\t    bool overflag=true;\n\t    bool flag=true;\n\t    int temp1= temp;   \n\t    while(overflag) {\n\t      temp = sum(temp); \n\t      temp1=sum(temp1);\n\t      temp1=sum(temp1);\n\t      if(temp1==1) {       \n\t          flag=true;\n\t          break;\n\t      }\n\t      if(temp==temp1) {   \n\t          flag=false;\n\t          break;\n\t      }\n\t    }\n\t    return flag;\n\t}\n```\n\n## Python\n## Java\n","slug":"Leetcode/202-happy-number-md","published":1,"updated":"2017-05-29T15:22:55.885Z","layout":"post","photos":[],"link":"","_id":"cj3aal9t1000u094uvf9x8xjp","content":"<ul>\n<li><p>write an algorithm to determine if a number is ‘happy’</p>\n</li>\n<li><p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay),or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p>\n</li>\n</ul>\n<p><b>Example:</b> 19 is a happy number</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">1^2 + 9^2 = 82</div><div class=\"line\">8^2 + 2^2 = 68</div><div class=\"line\">6^2 + 8^2 = 100</div><div class=\"line\">1^2 + 0^2 + 0^2 = 1</div></pre></td></tr></table></figure>\n<h1 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h1><ul>\n<li><b>翻译</b>： 判断一个正整数是否为一个happy-number，一个正整数各位的平方和代替次正整数，不断迭代，如果迭代出1，则为happy-number，否则不是而且会出现无限循环。<a id=\"more\"></a></li>\n<li><b>思路</b>：写一个函数分离正整数的各位，计算平方和并返回，主函数中需要有两类迭代，一类迭代每次迭代一次，一类迭代两次，这两如果出现无限重复循环肯定OK；循环结束的条件为迭代结果为1（这就是happy number）或者两类迭代结果相等（出现无限重复循环，不是happy number）。</li>\n</ul>\n<h2 id=\"C-C\"><a href=\"#C-C\" class=\"headerlink\" title=\"C/C++\"></a>C/C++</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> sum=<span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span>(n) &#123;</div><div class=\"line\">        i=n%<span class=\"number\">10</span>;</div><div class=\"line\">        n=n/<span class=\"number\">10</span>;</div><div class=\"line\">        sum=sum+i*i;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> sum;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isHappy</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> temp=n;</div><div class=\"line\">    <span class=\"keyword\">bool</span> overflag=<span class=\"literal\">true</span>;</div><div class=\"line\">    <span class=\"keyword\">bool</span> flag=<span class=\"literal\">true</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> temp1= temp;   </div><div class=\"line\">    <span class=\"keyword\">while</span>(overflag) &#123;</div><div class=\"line\">      temp = sum(temp); </div><div class=\"line\">      temp1=sum(temp1);</div><div class=\"line\">      temp1=sum(temp1);</div><div class=\"line\">      <span class=\"keyword\">if</span>(temp1==<span class=\"number\">1</span>) &#123;       </div><div class=\"line\">          flag=<span class=\"literal\">true</span>;</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">if</span>(temp==temp1) &#123;   </div><div class=\"line\">          flag=<span class=\"literal\">false</span>;</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> flag;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h2><h2 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h2>","excerpt":"<ul>\n<li><p>write an algorithm to determine if a number is ‘happy’</p>\n</li>\n<li><p>A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay),or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.</p>\n</li>\n</ul>\n<p><b>Example:</b> 19 is a happy number</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">1^2 + 9^2 = 82</div><div class=\"line\">8^2 + 2^2 = 68</div><div class=\"line\">6^2 + 8^2 = 100</div><div class=\"line\">1^2 + 0^2 + 0^2 = 1</div></pre></td></tr></table></figure>\n<h1 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h1><ul>\n<li><b>翻译</b>： 判断一个正整数是否为一个happy-number，一个正整数各位的平方和代替次正整数，不断迭代，如果迭代出1，则为happy-number，否则不是而且会出现无限循环。","more":"</li>\n<li><b>思路</b>：写一个函数分离正整数的各位，计算平方和并返回，主函数中需要有两类迭代，一类迭代每次迭代一次，一类迭代两次，这两如果出现无限重复循环肯定OK；循环结束的条件为迭代结果为1（这就是happy number）或者两类迭代结果相等（出现无限重复循环，不是happy number）。</li>\n</ul>\n<h2 id=\"C-C\"><a href=\"#C-C\" class=\"headerlink\" title=\"C/C++\"></a>C/C++</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> sum=<span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span>(n) &#123;</div><div class=\"line\">        i=n%<span class=\"number\">10</span>;</div><div class=\"line\">        n=n/<span class=\"number\">10</span>;</div><div class=\"line\">        sum=sum+i*i;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> sum;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">isHappy</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> temp=n;</div><div class=\"line\">    <span class=\"keyword\">bool</span> overflag=<span class=\"literal\">true</span>;</div><div class=\"line\">    <span class=\"keyword\">bool</span> flag=<span class=\"literal\">true</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> temp1= temp;   </div><div class=\"line\">    <span class=\"keyword\">while</span>(overflag) &#123;</div><div class=\"line\">      temp = sum(temp); </div><div class=\"line\">      temp1=sum(temp1);</div><div class=\"line\">      temp1=sum(temp1);</div><div class=\"line\">      <span class=\"keyword\">if</span>(temp1==<span class=\"number\">1</span>) &#123;       </div><div class=\"line\">          flag=<span class=\"literal\">true</span>;</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"keyword\">if</span>(temp==temp1) &#123;   </div><div class=\"line\">          flag=<span class=\"literal\">false</span>;</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> flag;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h2><h2 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h2>"},{"title":"412. fizz buzz","date":"2016-12-23T02:09:06.000Z","comments":1,"_content":"\n+ Write a program that outputs the string representation of numbers from 1 to n.\n\n+ But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.\n\n<b>Example:</b>\n```cpp\n\nn = 15,\n\nReturn:\n[\n    \"1\",\n    \"2\",\n    \"Fizz\",\n    \"4\",\n    \"Buzz\",\n    \"Fizz\",\n    \"7\",\n    \"8\",\n    \"Fizz\",\n    \"Buzz\",\n    \"11\",\n    \"Fizz\",\n    \"13\",\n    \"14\",\n    \"FizzBuzz\"\n]\n```\n# 解析\n+ 翻译：写一个程序输出1到n的字符串表达，但是 如果是3的倍数，不输出对应数字的字符串，而是输出“Fizz” ，如果是5的倍数，不输出对应数字的字符串，而是输出“Buzz”， 若同时是3和5的倍数，则输出 “FizzBuzz”。\n<!--more-->\n+ 思路：很简单的一道题，唯一的难点就是这是一个字符串数组，分别对char **和char * 进行malloc。还有就是sprintf把整型转换为字符串。\n## C/C++\n+ c\n\n```c\n/**\n * Return an array of size *returnSize.\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar** fizzBuzz(int n, int* returnSize) {\n     char **returnArray ;  //数组的指针\n     returnArray = (char **)malloc(n*sizeof(char **));\n     for(int i=0;i<n;i++) {\n         returnArray[i] = (char *)malloc(8*sizeof(char *));\n     }\n     for(int i=0;i<n;i++) {\n         if(((i+1)%3==0)&&((i+1)%5!=0)) {\n             returnArray[i] = \"Fizz\";\n         } else if(((i+1)%3!=0)&&((i+1)%5==0)) {\n             returnArray[i] = \"Buzz\";\n         } else if(((i+1)%3==0)&&((i+1)%5==0)) {\n             returnArray[i] =  \"FizzBuzz\";\n         } else {\n             sprintf(returnArray[i],\"%d\",i+1);\n            // returnArray[i] = \"Fizz\";\n         }\n         \n     }\n     *returnSize = n;\n     return returnArray;\n}\n```\n## Python\n## Java\n","source":"_posts/Leetcode/412-fizz-buzz-md.md","raw":"---\ntitle: 412. fizz buzz\ndate: 2016-12-23 10:09:06\ncategories:\n- 技术\ntags:\n- leetcode\n- 数据结构与算法\ncomments: true\n---\n\n+ Write a program that outputs the string representation of numbers from 1 to n.\n\n+ But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.\n\n<b>Example:</b>\n```cpp\n\nn = 15,\n\nReturn:\n[\n    \"1\",\n    \"2\",\n    \"Fizz\",\n    \"4\",\n    \"Buzz\",\n    \"Fizz\",\n    \"7\",\n    \"8\",\n    \"Fizz\",\n    \"Buzz\",\n    \"11\",\n    \"Fizz\",\n    \"13\",\n    \"14\",\n    \"FizzBuzz\"\n]\n```\n# 解析\n+ 翻译：写一个程序输出1到n的字符串表达，但是 如果是3的倍数，不输出对应数字的字符串，而是输出“Fizz” ，如果是5的倍数，不输出对应数字的字符串，而是输出“Buzz”， 若同时是3和5的倍数，则输出 “FizzBuzz”。\n<!--more-->\n+ 思路：很简单的一道题，唯一的难点就是这是一个字符串数组，分别对char **和char * 进行malloc。还有就是sprintf把整型转换为字符串。\n## C/C++\n+ c\n\n```c\n/**\n * Return an array of size *returnSize.\n * Note: The returned array must be malloced, assume caller calls free().\n */\nchar** fizzBuzz(int n, int* returnSize) {\n     char **returnArray ;  //数组的指针\n     returnArray = (char **)malloc(n*sizeof(char **));\n     for(int i=0;i<n;i++) {\n         returnArray[i] = (char *)malloc(8*sizeof(char *));\n     }\n     for(int i=0;i<n;i++) {\n         if(((i+1)%3==0)&&((i+1)%5!=0)) {\n             returnArray[i] = \"Fizz\";\n         } else if(((i+1)%3!=0)&&((i+1)%5==0)) {\n             returnArray[i] = \"Buzz\";\n         } else if(((i+1)%3==0)&&((i+1)%5==0)) {\n             returnArray[i] =  \"FizzBuzz\";\n         } else {\n             sprintf(returnArray[i],\"%d\",i+1);\n            // returnArray[i] = \"Fizz\";\n         }\n         \n     }\n     *returnSize = n;\n     return returnArray;\n}\n```\n## Python\n## Java\n","slug":"Leetcode/412-fizz-buzz-md","published":1,"updated":"2017-05-29T15:22:55.885Z","layout":"post","photos":[],"link":"","_id":"cj3aal9t5000x094uwz4w6g0h","content":"<ul>\n<li><p>Write a program that outputs the string representation of numbers from 1 to n.</p>\n</li>\n<li><p>But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.</p>\n</li>\n</ul>\n<p><b>Example:</b><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">n = <span class=\"number\">15</span>,</div><div class=\"line\"></div><div class=\"line\">Return:</div><div class=\"line\">[</div><div class=\"line\">    <span class=\"string\">\"1\"</span>,</div><div class=\"line\">    <span class=\"string\">\"2\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Fizz\"</span>,</div><div class=\"line\">    <span class=\"string\">\"4\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Buzz\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Fizz\"</span>,</div><div class=\"line\">    <span class=\"string\">\"7\"</span>,</div><div class=\"line\">    <span class=\"string\">\"8\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Fizz\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Buzz\"</span>,</div><div class=\"line\">    <span class=\"string\">\"11\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Fizz\"</span>,</div><div class=\"line\">    <span class=\"string\">\"13\"</span>,</div><div class=\"line\">    <span class=\"string\">\"14\"</span>,</div><div class=\"line\">    <span class=\"string\">\"FizzBuzz\"</span></div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<h1 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h1><ul>\n<li>翻译：写一个程序输出1到n的字符串表达，但是 如果是3的倍数，不输出对应数字的字符串，而是输出“Fizz” ，如果是5的倍数，不输出对应数字的字符串，而是输出“Buzz”， 若同时是3和5的倍数，则输出 “FizzBuzz”。<a id=\"more\"></a></li>\n<li>思路：很简单的一道题，唯一的难点就是这是一个字符串数组，分别对char <em>*和char </em> 进行malloc。还有就是sprintf把整型转换为字符串。<h2 id=\"C-C\"><a href=\"#C-C\" class=\"headerlink\" title=\"C/C++\"></a>C/C++</h2></li>\n<li>c</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Return an array of size *returnSize.</div><div class=\"line\"> * Note: The returned array must be malloced, assume caller calls free().</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span>** <span class=\"title\">fizzBuzz</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span>* returnSize)</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">char</span> **returnArray ;  <span class=\"comment\">//数组的指针</span></div><div class=\"line\">     returnArray = (<span class=\"keyword\">char</span> **)<span class=\"built_in\">malloc</span>(n*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span> **));</div><div class=\"line\">     <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++) &#123;</div><div class=\"line\">         returnArray[i] = (<span class=\"keyword\">char</span> *)<span class=\"built_in\">malloc</span>(<span class=\"number\">8</span>*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span> *));</div><div class=\"line\">     &#125;</div><div class=\"line\">     <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++) &#123;</div><div class=\"line\">         <span class=\"keyword\">if</span>(((i+<span class=\"number\">1</span>)%<span class=\"number\">3</span>==<span class=\"number\">0</span>)&amp;&amp;((i+<span class=\"number\">1</span>)%<span class=\"number\">5</span>!=<span class=\"number\">0</span>)) &#123;</div><div class=\"line\">             returnArray[i] = <span class=\"string\">\"Fizz\"</span>;</div><div class=\"line\">         &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(((i+<span class=\"number\">1</span>)%<span class=\"number\">3</span>!=<span class=\"number\">0</span>)&amp;&amp;((i+<span class=\"number\">1</span>)%<span class=\"number\">5</span>==<span class=\"number\">0</span>)) &#123;</div><div class=\"line\">             returnArray[i] = <span class=\"string\">\"Buzz\"</span>;</div><div class=\"line\">         &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(((i+<span class=\"number\">1</span>)%<span class=\"number\">3</span>==<span class=\"number\">0</span>)&amp;&amp;((i+<span class=\"number\">1</span>)%<span class=\"number\">5</span>==<span class=\"number\">0</span>)) &#123;</div><div class=\"line\">             returnArray[i] =  <span class=\"string\">\"FizzBuzz\"</span>;</div><div class=\"line\">         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">             <span class=\"built_in\">sprintf</span>(returnArray[i],<span class=\"string\">\"%d\"</span>,i+<span class=\"number\">1</span>);</div><div class=\"line\">            <span class=\"comment\">// returnArray[i] = \"Fizz\";</span></div><div class=\"line\">         &#125;</div><div class=\"line\">         </div><div class=\"line\">     &#125;</div><div class=\"line\">     *returnSize = n;</div><div class=\"line\">     <span class=\"keyword\">return</span> returnArray;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h2><h2 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h2>","excerpt":"<ul>\n<li><p>Write a program that outputs the string representation of numbers from 1 to n.</p>\n</li>\n<li><p>But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.</p>\n</li>\n</ul>\n<p><b>Example:</b><br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">n = <span class=\"number\">15</span>,</div><div class=\"line\"></div><div class=\"line\">Return:</div><div class=\"line\">[</div><div class=\"line\">    <span class=\"string\">\"1\"</span>,</div><div class=\"line\">    <span class=\"string\">\"2\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Fizz\"</span>,</div><div class=\"line\">    <span class=\"string\">\"4\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Buzz\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Fizz\"</span>,</div><div class=\"line\">    <span class=\"string\">\"7\"</span>,</div><div class=\"line\">    <span class=\"string\">\"8\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Fizz\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Buzz\"</span>,</div><div class=\"line\">    <span class=\"string\">\"11\"</span>,</div><div class=\"line\">    <span class=\"string\">\"Fizz\"</span>,</div><div class=\"line\">    <span class=\"string\">\"13\"</span>,</div><div class=\"line\">    <span class=\"string\">\"14\"</span>,</div><div class=\"line\">    <span class=\"string\">\"FizzBuzz\"</span></div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<h1 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h1><ul>\n<li>翻译：写一个程序输出1到n的字符串表达，但是 如果是3的倍数，不输出对应数字的字符串，而是输出“Fizz” ，如果是5的倍数，不输出对应数字的字符串，而是输出“Buzz”， 若同时是3和5的倍数，则输出 “FizzBuzz”。","more":"</li>\n<li>思路：很简单的一道题，唯一的难点就是这是一个字符串数组，分别对char <em>*和char </em> 进行malloc。还有就是sprintf把整型转换为字符串。<h2 id=\"C-C\"><a href=\"#C-C\" class=\"headerlink\" title=\"C/C++\"></a>C/C++</h2></li>\n<li>c</li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * Return an array of size *returnSize.</div><div class=\"line\"> * Note: The returned array must be malloced, assume caller calls free().</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span>** <span class=\"title\">fizzBuzz</span><span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span>* returnSize)</span> </span>&#123;</div><div class=\"line\">     <span class=\"keyword\">char</span> **returnArray ;  <span class=\"comment\">//数组的指针</span></div><div class=\"line\">     returnArray = (<span class=\"keyword\">char</span> **)<span class=\"built_in\">malloc</span>(n*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span> **));</div><div class=\"line\">     <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++) &#123;</div><div class=\"line\">         returnArray[i] = (<span class=\"keyword\">char</span> *)<span class=\"built_in\">malloc</span>(<span class=\"number\">8</span>*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span> *));</div><div class=\"line\">     &#125;</div><div class=\"line\">     <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;n;i++) &#123;</div><div class=\"line\">         <span class=\"keyword\">if</span>(((i+<span class=\"number\">1</span>)%<span class=\"number\">3</span>==<span class=\"number\">0</span>)&amp;&amp;((i+<span class=\"number\">1</span>)%<span class=\"number\">5</span>!=<span class=\"number\">0</span>)) &#123;</div><div class=\"line\">             returnArray[i] = <span class=\"string\">\"Fizz\"</span>;</div><div class=\"line\">         &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(((i+<span class=\"number\">1</span>)%<span class=\"number\">3</span>!=<span class=\"number\">0</span>)&amp;&amp;((i+<span class=\"number\">1</span>)%<span class=\"number\">5</span>==<span class=\"number\">0</span>)) &#123;</div><div class=\"line\">             returnArray[i] = <span class=\"string\">\"Buzz\"</span>;</div><div class=\"line\">         &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(((i+<span class=\"number\">1</span>)%<span class=\"number\">3</span>==<span class=\"number\">0</span>)&amp;&amp;((i+<span class=\"number\">1</span>)%<span class=\"number\">5</span>==<span class=\"number\">0</span>)) &#123;</div><div class=\"line\">             returnArray[i] =  <span class=\"string\">\"FizzBuzz\"</span>;</div><div class=\"line\">         &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">             <span class=\"built_in\">sprintf</span>(returnArray[i],<span class=\"string\">\"%d\"</span>,i+<span class=\"number\">1</span>);</div><div class=\"line\">            <span class=\"comment\">// returnArray[i] = \"Fizz\";</span></div><div class=\"line\">         &#125;</div><div class=\"line\">         </div><div class=\"line\">     &#125;</div><div class=\"line\">     *returnSize = n;</div><div class=\"line\">     <span class=\"keyword\">return</span> returnArray;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h2><h2 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h2>"},{"title":"1.two sum","date":"2016-12-26T15:35:23.000Z","comments":1,"_content":"+ Given an array of integers, return indices of the two numbers such that they add up to a specific target.\n\n+ You may assume that each input would have exactly one solution.\n\n<b>Example:</b>\n```c\nGiven nums = [2, 7, 11, 15], target = 9,\n\nBecause nums[0] + nums[1] = 2 + 7 = 9,\nreturn [0, 1].\n```\n\n# 解析\n<!--more-->\n+ 翻译：给定一个整型数组，一个特定目标值，返回两个数组下标，使得对应数组元素相加为特定目标值。\n+ 思路：\n1. 用了一个笨方法，用了2个for循环，最糟糕的情况时间复杂度为O（n^2）.使用两个循环，相加判断是否为特定目标值即可\n## C/C++\n\n```cpp\n\n// Note: The returned array must be malloced, assume caller calls free().\n\nint* twoSum(int* nums, int numsSize, int target) {\n    int *returnArray=NULL;\n    returnArray = (int *)malloc(2*sizeof(int));\n    for(int i=0;i<numsSize;i++) {\n        for(int j=0;j<i;j++) {\n            int temp = nums[i]+nums[j];\n            if(temp==target) {\n                returnArray[0]=j;\n                returnArray[1]=i;\n                return returnArray;\n            }\n        }\n        for(int j=i+1;j<numsSize;j++) {\n            int temp = nums[i]+nums[j];\n            if(temp==target) {\n                returnArray[0]=i;\n                returnArray[1]=j;\n                return returnArray;\n            }\n        }\n        \n    }\n    return 0;\n        \n}\n```\n## Python\n## Java\n","source":"_posts/Leetcode/1-two-sum.md","raw":"---\ntitle: 1.two sum\ndate: 2016-12-26 23:35:23\ncategories:\n- 技术\ntags:\n- leetcode\n- 数据结构与算法\ncomments: true\n---\n+ Given an array of integers, return indices of the two numbers such that they add up to a specific target.\n\n+ You may assume that each input would have exactly one solution.\n\n<b>Example:</b>\n```c\nGiven nums = [2, 7, 11, 15], target = 9,\n\nBecause nums[0] + nums[1] = 2 + 7 = 9,\nreturn [0, 1].\n```\n\n# 解析\n<!--more-->\n+ 翻译：给定一个整型数组，一个特定目标值，返回两个数组下标，使得对应数组元素相加为特定目标值。\n+ 思路：\n1. 用了一个笨方法，用了2个for循环，最糟糕的情况时间复杂度为O（n^2）.使用两个循环，相加判断是否为特定目标值即可\n## C/C++\n\n```cpp\n\n// Note: The returned array must be malloced, assume caller calls free().\n\nint* twoSum(int* nums, int numsSize, int target) {\n    int *returnArray=NULL;\n    returnArray = (int *)malloc(2*sizeof(int));\n    for(int i=0;i<numsSize;i++) {\n        for(int j=0;j<i;j++) {\n            int temp = nums[i]+nums[j];\n            if(temp==target) {\n                returnArray[0]=j;\n                returnArray[1]=i;\n                return returnArray;\n            }\n        }\n        for(int j=i+1;j<numsSize;j++) {\n            int temp = nums[i]+nums[j];\n            if(temp==target) {\n                returnArray[0]=i;\n                returnArray[1]=j;\n                return returnArray;\n            }\n        }\n        \n    }\n    return 0;\n        \n}\n```\n## Python\n## Java\n","slug":"Leetcode/1-two-sum","published":1,"updated":"2017-05-29T15:22:55.885Z","layout":"post","photos":[],"link":"","_id":"cj3aal9tb0010094u0atehkwf","content":"<ul>\n<li><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>\n</li>\n<li><p>You may assume that each input would have exactly one solution.</p>\n</li>\n</ul>\n<p><b>Example:</b><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Given nums = [<span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>], target = <span class=\"number\">9</span>,</div><div class=\"line\"></div><div class=\"line\">Because nums[<span class=\"number\">0</span>] + nums[<span class=\"number\">1</span>] = <span class=\"number\">2</span> + <span class=\"number\">7</span> = <span class=\"number\">9</span>,</div><div class=\"line\"><span class=\"keyword\">return</span> [<span class=\"number\">0</span>, <span class=\"number\">1</span>].</div></pre></td></tr></table></figure></p>\n<h1 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h1><a id=\"more\"></a>\n<ul>\n<li>翻译：给定一个整型数组，一个特定目标值，返回两个数组下标，使得对应数组元素相加为特定目标值。</li>\n<li>思路：</li>\n</ul>\n<ol>\n<li>用了一个笨方法，用了2个for循环，最糟糕的情况时间复杂度为O（n^2）.使用两个循环，相加判断是否为特定目标值即可<h2 id=\"C-C\"><a href=\"#C-C\" class=\"headerlink\" title=\"C/C++\"></a>C/C++</h2></li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Note: The returned array must be malloced, assume caller calls free().</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">twoSum</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize, <span class=\"keyword\">int</span> target)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> *returnArray=<span class=\"literal\">NULL</span>;</div><div class=\"line\">    returnArray = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"number\">2</span>*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;numsSize;i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;i;j++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> temp = nums[i]+nums[j];</div><div class=\"line\">            <span class=\"keyword\">if</span>(temp==target) &#123;</div><div class=\"line\">                returnArray[<span class=\"number\">0</span>]=j;</div><div class=\"line\">                returnArray[<span class=\"number\">1</span>]=i;</div><div class=\"line\">                <span class=\"keyword\">return</span> returnArray;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i+<span class=\"number\">1</span>;j&lt;numsSize;j++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> temp = nums[i]+nums[j];</div><div class=\"line\">            <span class=\"keyword\">if</span>(temp==target) &#123;</div><div class=\"line\">                returnArray[<span class=\"number\">0</span>]=i;</div><div class=\"line\">                returnArray[<span class=\"number\">1</span>]=j;</div><div class=\"line\">                <span class=\"keyword\">return</span> returnArray;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">        </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h2><h2 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h2>","excerpt":"<ul>\n<li><p>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>\n</li>\n<li><p>You may assume that each input would have exactly one solution.</p>\n</li>\n</ul>\n<p><b>Example:</b><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Given nums = [<span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">11</span>, <span class=\"number\">15</span>], target = <span class=\"number\">9</span>,</div><div class=\"line\"></div><div class=\"line\">Because nums[<span class=\"number\">0</span>] + nums[<span class=\"number\">1</span>] = <span class=\"number\">2</span> + <span class=\"number\">7</span> = <span class=\"number\">9</span>,</div><div class=\"line\"><span class=\"keyword\">return</span> [<span class=\"number\">0</span>, <span class=\"number\">1</span>].</div></pre></td></tr></table></figure></p>\n<h1 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h1>","more":"<ul>\n<li>翻译：给定一个整型数组，一个特定目标值，返回两个数组下标，使得对应数组元素相加为特定目标值。</li>\n<li>思路：</li>\n</ul>\n<ol>\n<li>用了一个笨方法，用了2个for循环，最糟糕的情况时间复杂度为O（n^2）.使用两个循环，相加判断是否为特定目标值即可<h2 id=\"C-C\"><a href=\"#C-C\" class=\"headerlink\" title=\"C/C++\"></a>C/C++</h2></li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Note: The returned array must be malloced, assume caller calls free().</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">twoSum</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize, <span class=\"keyword\">int</span> target)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> *returnArray=<span class=\"literal\">NULL</span>;</div><div class=\"line\">    returnArray = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(<span class=\"number\">2</span>*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;numsSize;i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=<span class=\"number\">0</span>;j&lt;i;j++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> temp = nums[i]+nums[j];</div><div class=\"line\">            <span class=\"keyword\">if</span>(temp==target) &#123;</div><div class=\"line\">                returnArray[<span class=\"number\">0</span>]=j;</div><div class=\"line\">                returnArray[<span class=\"number\">1</span>]=i;</div><div class=\"line\">                <span class=\"keyword\">return</span> returnArray;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=i+<span class=\"number\">1</span>;j&lt;numsSize;j++) &#123;</div><div class=\"line\">            <span class=\"keyword\">int</span> temp = nums[i]+nums[j];</div><div class=\"line\">            <span class=\"keyword\">if</span>(temp==target) &#123;</div><div class=\"line\">                returnArray[<span class=\"number\">0</span>]=i;</div><div class=\"line\">                returnArray[<span class=\"number\">1</span>]=j;</div><div class=\"line\">                <span class=\"keyword\">return</span> returnArray;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">        </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h2><h2 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h2>"},{"title":"442.find all duplicates in an array","date":"2016-12-23T02:09:57.000Z","comments":1,"_content":"\n+ Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.\n\n+ Find all the elements that appear twice in this array.\n\n+ Could you do it without extra space and in O(n) runtime?\n\n<b>Example:</b>\n```\nInput:\n[4,3,2,7,8,2,3,1]\n\nOutput:\n[2,3]\n```\n# 解析\n+ 翻译：一个整型数组，[1,n]其中n为数组大小，其中有些元素出现2次，有些出现1次，求出现2次的元素，0(n)复杂度\n<!--more-->\n+ 思路：将数组作为下标，使用正负法\n## C/C++\n```cpp\n/**\n * Return an array of size *returnSize.\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* findDuplicates(int* nums, int numsSize, int* returnSize) {\n    int *result=NULL;\n    result = (int *)malloc(numsSize*sizeof(int));\n    int temp=0;\n    *returnSize=0;\n    for(int i=0;i<numsSize;i++) {\n        if(nums[abs(nums[i])-1]<0) {\n            result[temp]=abs(nums[i]);\n            temp++;\n            *returnSize = temp;\n        } else {\n            nums[abs(nums[i])-1]=-nums[abs(nums[i])-1];\n        }\n    }\n    return result;\n}\n```\n## Python\n## Java\n# 疑问\n不是很明白为什么一下代码在用例[4,3,2,7,8,2,3,1]，程序ok，但是用例[3,11,8,16,4,15,4,17,14,14,6,6,2,8,3,12,15,20,20,5]却失败。\n\n+ <b>原因:</b>之所以这样是在malloc时错误，采用(*returnSize)*sizeof(int)，但是这个时候*returnSize并没有值。所以改为使用正确的numsSize*sizeof(int),但是总觉得这样比较浪费内存。\n```cpp\n/**\n * Return an array of size *returnSize.\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* findDuplicates(int* nums, int numsSize, int* returnSize) {\n    int *result=NULL;\n    result = (int *)malloc((*returnSize)*sizeof(int));\n    int temp=0;\n    *returnSize=0;\n    for(int i=0;i<numsSize;i++) {\n        if(nums[abs(nums[i])-1]<0) {\n            result[temp]=abs(nums[i]);\n            temp++;\n            *returnSize = temp;\n        } else {\n            nums[abs(nums[i])-1]=-nums[abs(nums[i])-1];\n        }\n    }\n    \n    return result;\n}\n```\n","source":"_posts/Leetcode/442-find-all-duplicates-in-an-array-md.md","raw":"---\ntitle: 442.find all duplicates in an array\ndate: 2016-12-23 10:09:57\ncategories:\n- 技术\ntags:\n- leetcode\n- 数据结构与算法\ncomments: true\n---\n\n+ Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.\n\n+ Find all the elements that appear twice in this array.\n\n+ Could you do it without extra space and in O(n) runtime?\n\n<b>Example:</b>\n```\nInput:\n[4,3,2,7,8,2,3,1]\n\nOutput:\n[2,3]\n```\n# 解析\n+ 翻译：一个整型数组，[1,n]其中n为数组大小，其中有些元素出现2次，有些出现1次，求出现2次的元素，0(n)复杂度\n<!--more-->\n+ 思路：将数组作为下标，使用正负法\n## C/C++\n```cpp\n/**\n * Return an array of size *returnSize.\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* findDuplicates(int* nums, int numsSize, int* returnSize) {\n    int *result=NULL;\n    result = (int *)malloc(numsSize*sizeof(int));\n    int temp=0;\n    *returnSize=0;\n    for(int i=0;i<numsSize;i++) {\n        if(nums[abs(nums[i])-1]<0) {\n            result[temp]=abs(nums[i]);\n            temp++;\n            *returnSize = temp;\n        } else {\n            nums[abs(nums[i])-1]=-nums[abs(nums[i])-1];\n        }\n    }\n    return result;\n}\n```\n## Python\n## Java\n# 疑问\n不是很明白为什么一下代码在用例[4,3,2,7,8,2,3,1]，程序ok，但是用例[3,11,8,16,4,15,4,17,14,14,6,6,2,8,3,12,15,20,20,5]却失败。\n\n+ <b>原因:</b>之所以这样是在malloc时错误，采用(*returnSize)*sizeof(int)，但是这个时候*returnSize并没有值。所以改为使用正确的numsSize*sizeof(int),但是总觉得这样比较浪费内存。\n```cpp\n/**\n * Return an array of size *returnSize.\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* findDuplicates(int* nums, int numsSize, int* returnSize) {\n    int *result=NULL;\n    result = (int *)malloc((*returnSize)*sizeof(int));\n    int temp=0;\n    *returnSize=0;\n    for(int i=0;i<numsSize;i++) {\n        if(nums[abs(nums[i])-1]<0) {\n            result[temp]=abs(nums[i]);\n            temp++;\n            *returnSize = temp;\n        } else {\n            nums[abs(nums[i])-1]=-nums[abs(nums[i])-1];\n        }\n    }\n    \n    return result;\n}\n```\n","slug":"Leetcode/442-find-all-duplicates-in-an-array-md","published":1,"updated":"2017-05-29T15:22:55.885Z","layout":"post","photos":[],"link":"","_id":"cj3aal9te0012094ukg8vap1r","content":"<ul>\n<li><p>Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.</p>\n</li>\n<li><p>Find all the elements that appear twice in this array.</p>\n</li>\n<li><p>Could you do it without extra space and in O(n) runtime?</p>\n</li>\n</ul>\n<p><b>Example:</b><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input:</div><div class=\"line\">[4,3,2,7,8,2,3,1]</div><div class=\"line\"></div><div class=\"line\">Output:</div><div class=\"line\">[2,3]</div></pre></td></tr></table></figure></p>\n<h1 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h1><ul>\n<li>翻译：一个整型数组，[1,n]其中n为数组大小，其中有些元素出现2次，有些出现1次，求出现2次的元素，0(n)复杂度<a id=\"more\"></a></li>\n<li>思路：将数组作为下标，使用正负法<h2 id=\"C-C\"><a href=\"#C-C\" class=\"headerlink\" title=\"C/C++\"></a>C/C++</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Return an array of size *returnSize.</div><div class=\"line\"> * Note: The returned array must be malloced, assume caller calls free().</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">findDuplicates</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize, <span class=\"keyword\">int</span>* returnSize)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> *result=<span class=\"literal\">NULL</span>;</div><div class=\"line\">    result = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(numsSize*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</div><div class=\"line\">    <span class=\"keyword\">int</span> temp=<span class=\"number\">0</span>;</div><div class=\"line\">    *returnSize=<span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;numsSize;i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(nums[<span class=\"built_in\">abs</span>(nums[i])<span class=\"number\">-1</span>]&lt;<span class=\"number\">0</span>) &#123;</div><div class=\"line\">            result[temp]=<span class=\"built_in\">abs</span>(nums[i]);</div><div class=\"line\">            temp++;</div><div class=\"line\">            *returnSize = temp;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            nums[<span class=\"built_in\">abs</span>(nums[i])<span class=\"number\">-1</span>]=-nums[<span class=\"built_in\">abs</span>(nums[i])<span class=\"number\">-1</span>];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h2><h2 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h2><h1 id=\"疑问\"><a href=\"#疑问\" class=\"headerlink\" title=\"疑问\"></a>疑问</h1><p>不是很明白为什么一下代码在用例[4,3,2,7,8,2,3,1]，程序ok，但是用例[3,11,8,16,4,15,4,17,14,14,6,6,2,8,3,12,15,20,20,5]却失败。</p>\n<ul>\n<li><b>原因:</b>之所以这样是在malloc时错误，采用(<em>returnSize)</em>sizeof(int)，但是这个时候<em>returnSize并没有值。所以改为使用正确的numsSize</em>sizeof(int),但是总觉得这样比较浪费内存。<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Return an array of size *returnSize.</div><div class=\"line\"> * Note: The returned array must be malloced, assume caller calls free().</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">findDuplicates</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize, <span class=\"keyword\">int</span>* returnSize)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> *result=<span class=\"literal\">NULL</span>;</div><div class=\"line\">    result = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>((*returnSize)*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</div><div class=\"line\">    <span class=\"keyword\">int</span> temp=<span class=\"number\">0</span>;</div><div class=\"line\">    *returnSize=<span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;numsSize;i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(nums[<span class=\"built_in\">abs</span>(nums[i])<span class=\"number\">-1</span>]&lt;<span class=\"number\">0</span>) &#123;</div><div class=\"line\">            result[temp]=<span class=\"built_in\">abs</span>(nums[i]);</div><div class=\"line\">            temp++;</div><div class=\"line\">            *returnSize = temp;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            nums[<span class=\"built_in\">abs</span>(nums[i])<span class=\"number\">-1</span>]=-nums[<span class=\"built_in\">abs</span>(nums[i])<span class=\"number\">-1</span>];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n","excerpt":"<ul>\n<li><p>Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.</p>\n</li>\n<li><p>Find all the elements that appear twice in this array.</p>\n</li>\n<li><p>Could you do it without extra space and in O(n) runtime?</p>\n</li>\n</ul>\n<p><b>Example:</b><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input:</div><div class=\"line\">[4,3,2,7,8,2,3,1]</div><div class=\"line\"></div><div class=\"line\">Output:</div><div class=\"line\">[2,3]</div></pre></td></tr></table></figure></p>\n<h1 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h1><ul>\n<li>翻译：一个整型数组，[1,n]其中n为数组大小，其中有些元素出现2次，有些出现1次，求出现2次的元素，0(n)复杂度","more":"</li>\n<li>思路：将数组作为下标，使用正负法<h2 id=\"C-C\"><a href=\"#C-C\" class=\"headerlink\" title=\"C/C++\"></a>C/C++</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * Return an array of size *returnSize.</div><div class=\"line\"> * Note: The returned array must be malloced, assume caller calls free().</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">findDuplicates</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize, <span class=\"keyword\">int</span>* returnSize)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> *result=<span class=\"literal\">NULL</span>;</div><div class=\"line\">    result = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>(numsSize*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</div><div class=\"line\">    <span class=\"keyword\">int</span> temp=<span class=\"number\">0</span>;</div><div class=\"line\">    *returnSize=<span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;numsSize;i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(nums[<span class=\"built_in\">abs</span>(nums[i])<span class=\"number\">-1</span>]&lt;<span class=\"number\">0</span>) &#123;</div><div class=\"line\">            result[temp]=<span class=\"built_in\">abs</span>(nums[i]);</div><div class=\"line\">            temp++;</div><div class=\"line\">            *returnSize = temp;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            nums[<span class=\"built_in\">abs</span>(nums[i])<span class=\"number\">-1</span>]=-nums[<span class=\"built_in\">abs</span>(nums[i])<span class=\"number\">-1</span>];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h2><h2 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h2><h1 id=\"疑问\"><a href=\"#疑问\" class=\"headerlink\" title=\"疑问\"></a>疑问</h1><p>不是很明白为什么一下代码在用例[4,3,2,7,8,2,3,1]，程序ok，但是用例[3,11,8,16,4,15,4,17,14,14,6,6,2,8,3,12,15,20,20,5]却失败。</p>\n<ul>\n<li><b>原因:</b>之所以这样是在malloc时错误，采用(<em>returnSize)</em>sizeof(int)，但是这个时候<em>returnSize并没有值。所以改为使用正确的numsSize</em>sizeof(int),但是总觉得这样比较浪费内存。<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/**</div><div class=\"line\"> * Return an array of size *returnSize.</div><div class=\"line\"> * Note: The returned array must be malloced, assume caller calls free().</div><div class=\"line\"> */</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>* <span class=\"title\">findDuplicates</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize, <span class=\"keyword\">int</span>* returnSize)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> *result=<span class=\"literal\">NULL</span>;</div><div class=\"line\">    result = (<span class=\"keyword\">int</span> *)<span class=\"built_in\">malloc</span>((*returnSize)*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>));</div><div class=\"line\">    <span class=\"keyword\">int</span> temp=<span class=\"number\">0</span>;</div><div class=\"line\">    *returnSize=<span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;numsSize;i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(nums[<span class=\"built_in\">abs</span>(nums[i])<span class=\"number\">-1</span>]&lt;<span class=\"number\">0</span>) &#123;</div><div class=\"line\">            result[temp]=<span class=\"built_in\">abs</span>(nums[i]);</div><div class=\"line\">            temp++;</div><div class=\"line\">            *returnSize = temp;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            nums[<span class=\"built_in\">abs</span>(nums[i])<span class=\"number\">-1</span>]=-nums[<span class=\"built_in\">abs</span>(nums[i])<span class=\"number\">-1</span>];</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>"},{"title":"461.hamming distance","date":"2016-12-23T02:11:23.000Z","comments":1,"_content":"\n\n+ The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\n\n+ Given two integers x and y, calculate the Hamming distance.\n\n<b>Note</b>:\n0 ≤ x, y < 2^31.\n\n<b>Example</b>\n```\nInput: x = 1, y = 4\n\nOutput: 2\n\nExplanation:\n1   (0 0 0 1)\n4   (0 1 0 0)\n       ↑   ↑\n\nThe above arrows point to positions where the corresponding bits are different.\n```\n\n# 解析\n+ <b>翻译</b>：Hanmming Distance 就是两个整数[0 2^31]二进制表示对应位上不同位数的个数。给定X,Y求取两者的hamming distance\n<!--more-->\n+ <b>思路</b> 用数组表示整数二进制，使用循环比较\n\n## C/C++\n```cpp\nvoid dis(int n,char a[]) {\n    char i=0;\n    while(n) {\n        a[i]=n%2;   //得到低位余数\n        n=n/2;      //得到商\n        i++;\n    }\n}\n\nint hammingDistance(int x, int y) {\n    char x_dis[32]={0};\n    char y_dis[32]={0};\n    int k=0;\n    int temp=0;\n    dis(x,x_dis);\n    dis(y,y_dis);\n        for(int i=0;i<32;i++) {\n            if(x_dis[i]!=y_dis[i]) temp++;\n        }\n    return temp;\n}\n\n```\n## Python\n## Java\n\n# 疑问\n我最开始的思路就是不用指定二进制表示的位数，使用strlen（）来获得数组大小，但是失败，以下为错误代码，希望有人不吝赐教。\n```cpp\nvoid dis(int n,char a[]) {\n    char i=0;\n    while(n) {\n        a[i]=n%2;   //得到低位余数\n        n=n/2;      //得到商\n        i++;\n        if(n==0)\n            a[i]='\\0';\n    }\n    \n}\n\nint hammingDistance(int x, int y) {\n    char x_dis[]={0};\n    char y_dis[]={0};\n    int k=0;\n    int temp=0;\n    dis(x,x_dis);\n    dis(y,y_dis);\n    if((strlen(x_dis))>=(strlen(y_dis))) {\n        for(int i=0;i<strlen(y_dis);i++) {\n            if(x_dis[i]!=y_dis[i]) temp++;\n        }\n        for(int i=strlen(y_dis);i<strlen(x_dis);i++) {\n            if(x_dis[i]!=0) temp++;\n        }\n    } else {\n        for(int i=0;i<strlen(x_dis);i++) {\n            if(y_dis[i]!=y_dis[i]) temp++;\n        }\n        for(int i=strlen(x_dis);i<strlen(y_dis);i++) {\n            if(y_dis[i]!=0) temp++;\n        }\n    }\n    \n    return temp;\n}\n\n\n```\n","source":"_posts/Leetcode/461-hamming-distance-md.md","raw":"---\ntitle: 461.hamming distance \ndate: 2016-12-23 10:11:23\ncategories:\n- 技术\ntags:\n- leetcode\n- 数据结构与算法\ncomments: true\n---\n\n\n+ The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\n\n+ Given two integers x and y, calculate the Hamming distance.\n\n<b>Note</b>:\n0 ≤ x, y < 2^31.\n\n<b>Example</b>\n```\nInput: x = 1, y = 4\n\nOutput: 2\n\nExplanation:\n1   (0 0 0 1)\n4   (0 1 0 0)\n       ↑   ↑\n\nThe above arrows point to positions where the corresponding bits are different.\n```\n\n# 解析\n+ <b>翻译</b>：Hanmming Distance 就是两个整数[0 2^31]二进制表示对应位上不同位数的个数。给定X,Y求取两者的hamming distance\n<!--more-->\n+ <b>思路</b> 用数组表示整数二进制，使用循环比较\n\n## C/C++\n```cpp\nvoid dis(int n,char a[]) {\n    char i=0;\n    while(n) {\n        a[i]=n%2;   //得到低位余数\n        n=n/2;      //得到商\n        i++;\n    }\n}\n\nint hammingDistance(int x, int y) {\n    char x_dis[32]={0};\n    char y_dis[32]={0};\n    int k=0;\n    int temp=0;\n    dis(x,x_dis);\n    dis(y,y_dis);\n        for(int i=0;i<32;i++) {\n            if(x_dis[i]!=y_dis[i]) temp++;\n        }\n    return temp;\n}\n\n```\n## Python\n## Java\n\n# 疑问\n我最开始的思路就是不用指定二进制表示的位数，使用strlen（）来获得数组大小，但是失败，以下为错误代码，希望有人不吝赐教。\n```cpp\nvoid dis(int n,char a[]) {\n    char i=0;\n    while(n) {\n        a[i]=n%2;   //得到低位余数\n        n=n/2;      //得到商\n        i++;\n        if(n==0)\n            a[i]='\\0';\n    }\n    \n}\n\nint hammingDistance(int x, int y) {\n    char x_dis[]={0};\n    char y_dis[]={0};\n    int k=0;\n    int temp=0;\n    dis(x,x_dis);\n    dis(y,y_dis);\n    if((strlen(x_dis))>=(strlen(y_dis))) {\n        for(int i=0;i<strlen(y_dis);i++) {\n            if(x_dis[i]!=y_dis[i]) temp++;\n        }\n        for(int i=strlen(y_dis);i<strlen(x_dis);i++) {\n            if(x_dis[i]!=0) temp++;\n        }\n    } else {\n        for(int i=0;i<strlen(x_dis);i++) {\n            if(y_dis[i]!=y_dis[i]) temp++;\n        }\n        for(int i=strlen(x_dis);i<strlen(y_dis);i++) {\n            if(y_dis[i]!=0) temp++;\n        }\n    }\n    \n    return temp;\n}\n\n\n```\n","slug":"Leetcode/461-hamming-distance-md","published":1,"updated":"2017-05-29T15:22:55.885Z","layout":"post","photos":[],"link":"","_id":"cj3aal9tk0015094u6mh63t2e","content":"<ul>\n<li><p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.</p>\n</li>\n<li><p>Given two integers x and y, calculate the Hamming distance.</p>\n</li>\n</ul>\n<p><b>Note</b>:<br>0 ≤ x, y &lt; 2^31.</p>\n<p><b>Example</b><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input: x = 1, y = 4</div><div class=\"line\"></div><div class=\"line\">Output: 2</div><div class=\"line\"></div><div class=\"line\">Explanation:</div><div class=\"line\">1   (0 0 0 1)</div><div class=\"line\">4   (0 1 0 0)</div><div class=\"line\">       ↑   ↑</div><div class=\"line\"></div><div class=\"line\">The above arrows point to positions where the corresponding bits are different.</div></pre></td></tr></table></figure></p>\n<h1 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h1><ul>\n<li><b>翻译</b>：Hanmming Distance 就是两个整数[0 2^31]二进制表示对应位上不同位数的个数。给定X,Y求取两者的hamming distance<a id=\"more\"></a></li>\n<li><b>思路</b> 用数组表示整数二进制，使用循环比较</li>\n</ul>\n<h2 id=\"C-C\"><a href=\"#C-C\" class=\"headerlink\" title=\"C/C++\"></a>C/C++</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dis</span><span class=\"params\">(<span class=\"keyword\">int</span> n,<span class=\"keyword\">char</span> a[])</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">char</span> i=<span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span>(n) &#123;</div><div class=\"line\">        a[i]=n%<span class=\"number\">2</span>;   <span class=\"comment\">//得到低位余数</span></div><div class=\"line\">        n=n/<span class=\"number\">2</span>;      <span class=\"comment\">//得到商</span></div><div class=\"line\">        i++;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hammingDistance</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">char</span> x_dis[<span class=\"number\">32</span>]=&#123;<span class=\"number\">0</span>&#125;;</div><div class=\"line\">    <span class=\"keyword\">char</span> y_dis[<span class=\"number\">32</span>]=&#123;<span class=\"number\">0</span>&#125;;</div><div class=\"line\">    <span class=\"keyword\">int</span> k=<span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> temp=<span class=\"number\">0</span>;</div><div class=\"line\">    dis(x,x_dis);</div><div class=\"line\">    dis(y,y_dis);</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">32</span>;i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(x_dis[i]!=y_dis[i]) temp++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> temp;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h2><h2 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h2><h1 id=\"疑问\"><a href=\"#疑问\" class=\"headerlink\" title=\"疑问\"></a>疑问</h1><p>我最开始的思路就是不用指定二进制表示的位数，使用strlen（）来获得数组大小，但是失败，以下为错误代码，希望有人不吝赐教。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dis</span><span class=\"params\">(<span class=\"keyword\">int</span> n,<span class=\"keyword\">char</span> a[])</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">char</span> i=<span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span>(n) &#123;</div><div class=\"line\">        a[i]=n%<span class=\"number\">2</span>;   <span class=\"comment\">//得到低位余数</span></div><div class=\"line\">        n=n/<span class=\"number\">2</span>;      <span class=\"comment\">//得到商</span></div><div class=\"line\">        i++;</div><div class=\"line\">        <span class=\"keyword\">if</span>(n==<span class=\"number\">0</span>)</div><div class=\"line\">            a[i]=<span class=\"string\">'\\0'</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hammingDistance</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">char</span> x_dis[]=&#123;<span class=\"number\">0</span>&#125;;</div><div class=\"line\">    <span class=\"keyword\">char</span> y_dis[]=&#123;<span class=\"number\">0</span>&#125;;</div><div class=\"line\">    <span class=\"keyword\">int</span> k=<span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> temp=<span class=\"number\">0</span>;</div><div class=\"line\">    dis(x,x_dis);</div><div class=\"line\">    dis(y,y_dis);</div><div class=\"line\">    <span class=\"keyword\">if</span>((<span class=\"built_in\">strlen</span>(x_dis))&gt;=(<span class=\"built_in\">strlen</span>(y_dis))) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"built_in\">strlen</span>(y_dis);i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(x_dis[i]!=y_dis[i]) temp++;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"built_in\">strlen</span>(y_dis);i&lt;<span class=\"built_in\">strlen</span>(x_dis);i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(x_dis[i]!=<span class=\"number\">0</span>) temp++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"built_in\">strlen</span>(x_dis);i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(y_dis[i]!=y_dis[i]) temp++;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"built_in\">strlen</span>(x_dis);i&lt;<span class=\"built_in\">strlen</span>(y_dis);i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(y_dis[i]!=<span class=\"number\">0</span>) temp++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> temp;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","excerpt":"<ul>\n<li><p>The Hamming distance between two integers is the number of positions at which the corresponding bits are different.</p>\n</li>\n<li><p>Given two integers x and y, calculate the Hamming distance.</p>\n</li>\n</ul>\n<p><b>Note</b>:<br>0 ≤ x, y &lt; 2^31.</p>\n<p><b>Example</b><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input: x = 1, y = 4</div><div class=\"line\"></div><div class=\"line\">Output: 2</div><div class=\"line\"></div><div class=\"line\">Explanation:</div><div class=\"line\">1   (0 0 0 1)</div><div class=\"line\">4   (0 1 0 0)</div><div class=\"line\">       ↑   ↑</div><div class=\"line\"></div><div class=\"line\">The above arrows point to positions where the corresponding bits are different.</div></pre></td></tr></table></figure></p>\n<h1 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h1><ul>\n<li><b>翻译</b>：Hanmming Distance 就是两个整数[0 2^31]二进制表示对应位上不同位数的个数。给定X,Y求取两者的hamming distance","more":"</li>\n<li><b>思路</b> 用数组表示整数二进制，使用循环比较</li>\n</ul>\n<h2 id=\"C-C\"><a href=\"#C-C\" class=\"headerlink\" title=\"C/C++\"></a>C/C++</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dis</span><span class=\"params\">(<span class=\"keyword\">int</span> n,<span class=\"keyword\">char</span> a[])</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">char</span> i=<span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span>(n) &#123;</div><div class=\"line\">        a[i]=n%<span class=\"number\">2</span>;   <span class=\"comment\">//得到低位余数</span></div><div class=\"line\">        n=n/<span class=\"number\">2</span>;      <span class=\"comment\">//得到商</span></div><div class=\"line\">        i++;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hammingDistance</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">char</span> x_dis[<span class=\"number\">32</span>]=&#123;<span class=\"number\">0</span>&#125;;</div><div class=\"line\">    <span class=\"keyword\">char</span> y_dis[<span class=\"number\">32</span>]=&#123;<span class=\"number\">0</span>&#125;;</div><div class=\"line\">    <span class=\"keyword\">int</span> k=<span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> temp=<span class=\"number\">0</span>;</div><div class=\"line\">    dis(x,x_dis);</div><div class=\"line\">    dis(y,y_dis);</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">32</span>;i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(x_dis[i]!=y_dis[i]) temp++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> temp;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h2><h2 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h2><h1 id=\"疑问\"><a href=\"#疑问\" class=\"headerlink\" title=\"疑问\"></a>疑问</h1><p>我最开始的思路就是不用指定二进制表示的位数，使用strlen（）来获得数组大小，但是失败，以下为错误代码，希望有人不吝赐教。<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dis</span><span class=\"params\">(<span class=\"keyword\">int</span> n,<span class=\"keyword\">char</span> a[])</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">char</span> i=<span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">while</span>(n) &#123;</div><div class=\"line\">        a[i]=n%<span class=\"number\">2</span>;   <span class=\"comment\">//得到低位余数</span></div><div class=\"line\">        n=n/<span class=\"number\">2</span>;      <span class=\"comment\">//得到商</span></div><div class=\"line\">        i++;</div><div class=\"line\">        <span class=\"keyword\">if</span>(n==<span class=\"number\">0</span>)</div><div class=\"line\">            a[i]=<span class=\"string\">'\\0'</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hammingDistance</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">char</span> x_dis[]=&#123;<span class=\"number\">0</span>&#125;;</div><div class=\"line\">    <span class=\"keyword\">char</span> y_dis[]=&#123;<span class=\"number\">0</span>&#125;;</div><div class=\"line\">    <span class=\"keyword\">int</span> k=<span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> temp=<span class=\"number\">0</span>;</div><div class=\"line\">    dis(x,x_dis);</div><div class=\"line\">    dis(y,y_dis);</div><div class=\"line\">    <span class=\"keyword\">if</span>((<span class=\"built_in\">strlen</span>(x_dis))&gt;=(<span class=\"built_in\">strlen</span>(y_dis))) &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"built_in\">strlen</span>(y_dis);i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(x_dis[i]!=y_dis[i]) temp++;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"built_in\">strlen</span>(y_dis);i&lt;<span class=\"built_in\">strlen</span>(x_dis);i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(x_dis[i]!=<span class=\"number\">0</span>) temp++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;<span class=\"built_in\">strlen</span>(x_dis);i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(y_dis[i]!=y_dis[i]) temp++;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"built_in\">strlen</span>(x_dis);i&lt;<span class=\"built_in\">strlen</span>(y_dis);i++) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(y_dis[i]!=<span class=\"number\">0</span>) temp++;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">return</span> temp;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>"},{"title":"414. the third maxium number","date":"2016-12-28T15:26:04.000Z","comments":1,"_content":"\n+ Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).\n<b>Example 1:</b>\n```c\nInput: [3, 2, 1]\n\nOutput: 1\n\nExplanation: The third maximum is 1.\n```\n<b>Example 2:</b>\n```c\nInput: [1, 2]\n\nOutput: 2\n\nExplanation: The third maximum does not exist, so the maximum (2) is returned instead.\n```\n<b>Example 3:</b>\n```c\nInput: [2, 2, 3, 1]\n\nOutput: 1\n\nExplanation: Note that the third maximum here means the third maximum distinct number.\nBoth numbers with value 2 are both considered as second maximum.\n```\n\n# 解析\n+ 翻译：给一个非空整型数组，返回第三大的数字，如果不存在则返回最大的数字，要求时间复杂度为0（n）\n<!--more-->\n+ 思路：初始化数组temp[3]，循环比较给定数组中的数字，把循环过程中前三数字放在temp[3]中，最后检查temp数组有没有被填满，如果有就说明第三大的数字存在，如果没有就不存在，按要求返回数值即可。\n## C/C++\n\n```c\nint thirdMax(int* nums, int numsSize) {\n    int flag,flag1,flag2=0;\n    int temp[3]={ -2147483648, -2147483648, -2147483648};\n    for(int i=0;i<numsSize;i++) {\n       if(nums[i]>temp[2]) {\n           if(flag2==1) {\n               if(flag1==1){\n                temp[0] = temp[1];\n                temp[1] = temp[2];\n                temp[2] = nums[i];\n                flag =1;\n               } else {\n                //temp[0] = temp[1];\n                temp[1] = temp[2];\n                temp[2] = nums[i];\n                flag1 =1;   //标记该位被占 \n               }\n           } else {\n              temp[2] = nums[i];\n              flag2=1;\n           }\n       } else if(nums[i]==temp[2]) { \n           flag2=1;   //表示这一位被占\n       } else if((nums[i]<temp[2])&&(nums[i]>temp[1])) {\n           if(flag1==1) {\n               temp[0] = temp[1];\n               temp[1] = nums[i];\n               flag=1;\n           } else {\n               temp[1] = nums[i];\n               flag1=1;\n           }\n       } else if(nums[i]==temp[1]) {\n           flag1=1;    //表示此位被占\n       } else if((nums[i]<temp[1])&&(nums[i]>temp[0])) {\n           if(flag ==1) {\n               temp[0]=nums[i];\n           } else {\n               temp[0]=nums[i];\n               flag=1;\n           }\n       } else if(nums[i]==temp[0]) {\n           flag=1;\n       }\n    }\n    if(flag==1) \n        return temp[0];\n    else\n        return temp[2];\n}\n```\n\n## Python\n## Java\n\n# 注意\n这道题在leetcode中难度级别为easy，但是ac率只有20%多，根据自己做这道题感觉最大的原因不是没有思路，而且细节处理上，特别是如果确定是否存在第三大的数字，还有就是int范围等。\n","source":"_posts/Leetcode/414-the-third-maxium-number.md","raw":"---\ntitle: 414. the third maxium number\ndate: 2016-12-28 23:26:04\ncategories:\n- 技术\ntags:\n- leetcode\n- 数据结构与算法\ncomments: true\n---\n\n+ Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).\n<b>Example 1:</b>\n```c\nInput: [3, 2, 1]\n\nOutput: 1\n\nExplanation: The third maximum is 1.\n```\n<b>Example 2:</b>\n```c\nInput: [1, 2]\n\nOutput: 2\n\nExplanation: The third maximum does not exist, so the maximum (2) is returned instead.\n```\n<b>Example 3:</b>\n```c\nInput: [2, 2, 3, 1]\n\nOutput: 1\n\nExplanation: Note that the third maximum here means the third maximum distinct number.\nBoth numbers with value 2 are both considered as second maximum.\n```\n\n# 解析\n+ 翻译：给一个非空整型数组，返回第三大的数字，如果不存在则返回最大的数字，要求时间复杂度为0（n）\n<!--more-->\n+ 思路：初始化数组temp[3]，循环比较给定数组中的数字，把循环过程中前三数字放在temp[3]中，最后检查temp数组有没有被填满，如果有就说明第三大的数字存在，如果没有就不存在，按要求返回数值即可。\n## C/C++\n\n```c\nint thirdMax(int* nums, int numsSize) {\n    int flag,flag1,flag2=0;\n    int temp[3]={ -2147483648, -2147483648, -2147483648};\n    for(int i=0;i<numsSize;i++) {\n       if(nums[i]>temp[2]) {\n           if(flag2==1) {\n               if(flag1==1){\n                temp[0] = temp[1];\n                temp[1] = temp[2];\n                temp[2] = nums[i];\n                flag =1;\n               } else {\n                //temp[0] = temp[1];\n                temp[1] = temp[2];\n                temp[2] = nums[i];\n                flag1 =1;   //标记该位被占 \n               }\n           } else {\n              temp[2] = nums[i];\n              flag2=1;\n           }\n       } else if(nums[i]==temp[2]) { \n           flag2=1;   //表示这一位被占\n       } else if((nums[i]<temp[2])&&(nums[i]>temp[1])) {\n           if(flag1==1) {\n               temp[0] = temp[1];\n               temp[1] = nums[i];\n               flag=1;\n           } else {\n               temp[1] = nums[i];\n               flag1=1;\n           }\n       } else if(nums[i]==temp[1]) {\n           flag1=1;    //表示此位被占\n       } else if((nums[i]<temp[1])&&(nums[i]>temp[0])) {\n           if(flag ==1) {\n               temp[0]=nums[i];\n           } else {\n               temp[0]=nums[i];\n               flag=1;\n           }\n       } else if(nums[i]==temp[0]) {\n           flag=1;\n       }\n    }\n    if(flag==1) \n        return temp[0];\n    else\n        return temp[2];\n}\n```\n\n## Python\n## Java\n\n# 注意\n这道题在leetcode中难度级别为easy，但是ac率只有20%多，根据自己做这道题感觉最大的原因不是没有思路，而且细节处理上，特别是如果确定是否存在第三大的数字，还有就是int范围等。\n","slug":"Leetcode/414-the-third-maxium-number","published":1,"updated":"2017-05-29T15:22:55.885Z","layout":"post","photos":[],"link":"","_id":"cj3aal9tp0017094u7fqjncz3","content":"<ul>\n<li>Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).<br><b>Example 1:</b><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input: [<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>]</div><div class=\"line\"></div><div class=\"line\">Output: <span class=\"number\">1</span></div><div class=\"line\"></div><div class=\"line\">Explanation: The third maximum is <span class=\"number\">1.</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><b>Example 2:</b><br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input: [1, 2]</div><div class=\"line\"></div><div class=\"line\">Output: 2</div><div class=\"line\"></div><div class=\"line\">Explanation: The third maximum does not exist, so the maximum (2) is returned instead.</div></pre></td></tr></table></figure></p>\n<p><b>Example 3:</b><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input: [<span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>]</div><div class=\"line\"></div><div class=\"line\">Output: <span class=\"number\">1</span></div><div class=\"line\"></div><div class=\"line\">Explanation: Note that the third maximum here means the third maximum distinct number.</div><div class=\"line\">Both numbers with value <span class=\"number\">2</span> are both considered as second maximum.</div></pre></td></tr></table></figure></p>\n<h1 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h1><ul>\n<li>翻译：给一个非空整型数组，返回第三大的数字，如果不存在则返回最大的数字，要求时间复杂度为0（n）<a id=\"more\"></a></li>\n<li>思路：初始化数组temp[3]，循环比较给定数组中的数字，把循环过程中前三数字放在temp[3]中，最后检查temp数组有没有被填满，如果有就说明第三大的数字存在，如果没有就不存在，按要求返回数值即可。<h2 id=\"C-C\"><a href=\"#C-C\" class=\"headerlink\" title=\"C/C++\"></a>C/C++</h2></li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">thirdMax</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> flag,flag1,flag2=<span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> temp[<span class=\"number\">3</span>]=&#123; <span class=\"number\">-2147483648</span>, <span class=\"number\">-2147483648</span>, <span class=\"number\">-2147483648</span>&#125;;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;numsSize;i++) &#123;</div><div class=\"line\">       <span class=\"keyword\">if</span>(nums[i]&gt;temp[<span class=\"number\">2</span>]) &#123;</div><div class=\"line\">           <span class=\"keyword\">if</span>(flag2==<span class=\"number\">1</span>) &#123;</div><div class=\"line\">               <span class=\"keyword\">if</span>(flag1==<span class=\"number\">1</span>)&#123;</div><div class=\"line\">                temp[<span class=\"number\">0</span>] = temp[<span class=\"number\">1</span>];</div><div class=\"line\">                temp[<span class=\"number\">1</span>] = temp[<span class=\"number\">2</span>];</div><div class=\"line\">                temp[<span class=\"number\">2</span>] = nums[i];</div><div class=\"line\">                flag =<span class=\"number\">1</span>;</div><div class=\"line\">               &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"comment\">//temp[0] = temp[1];</span></div><div class=\"line\">                temp[<span class=\"number\">1</span>] = temp[<span class=\"number\">2</span>];</div><div class=\"line\">                temp[<span class=\"number\">2</span>] = nums[i];</div><div class=\"line\">                flag1 =<span class=\"number\">1</span>;   <span class=\"comment\">//标记该位被占 </span></div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">              temp[<span class=\"number\">2</span>] = nums[i];</div><div class=\"line\">              flag2=<span class=\"number\">1</span>;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[i]==temp[<span class=\"number\">2</span>]) &#123; </div><div class=\"line\">           flag2=<span class=\"number\">1</span>;   <span class=\"comment\">//表示这一位被占</span></div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>((nums[i]&lt;temp[<span class=\"number\">2</span>])&amp;&amp;(nums[i]&gt;temp[<span class=\"number\">1</span>])) &#123;</div><div class=\"line\">           <span class=\"keyword\">if</span>(flag1==<span class=\"number\">1</span>) &#123;</div><div class=\"line\">               temp[<span class=\"number\">0</span>] = temp[<span class=\"number\">1</span>];</div><div class=\"line\">               temp[<span class=\"number\">1</span>] = nums[i];</div><div class=\"line\">               flag=<span class=\"number\">1</span>;</div><div class=\"line\">           &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">               temp[<span class=\"number\">1</span>] = nums[i];</div><div class=\"line\">               flag1=<span class=\"number\">1</span>;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[i]==temp[<span class=\"number\">1</span>]) &#123;</div><div class=\"line\">           flag1=<span class=\"number\">1</span>;    <span class=\"comment\">//表示此位被占</span></div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>((nums[i]&lt;temp[<span class=\"number\">1</span>])&amp;&amp;(nums[i]&gt;temp[<span class=\"number\">0</span>])) &#123;</div><div class=\"line\">           <span class=\"keyword\">if</span>(flag ==<span class=\"number\">1</span>) &#123;</div><div class=\"line\">               temp[<span class=\"number\">0</span>]=nums[i];</div><div class=\"line\">           &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">               temp[<span class=\"number\">0</span>]=nums[i];</div><div class=\"line\">               flag=<span class=\"number\">1</span>;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[i]==temp[<span class=\"number\">0</span>]) &#123;</div><div class=\"line\">           flag=<span class=\"number\">1</span>;</div><div class=\"line\">       &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span>(flag==<span class=\"number\">1</span>) </div><div class=\"line\">        <span class=\"keyword\">return</span> temp[<span class=\"number\">0</span>];</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">        <span class=\"keyword\">return</span> temp[<span class=\"number\">2</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h2><h2 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h2><h1 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h1><p>这道题在leetcode中难度级别为easy，但是ac率只有20%多，根据自己做这道题感觉最大的原因不是没有思路，而且细节处理上，特别是如果确定是否存在第三大的数字，还有就是int范围等。</p>\n","excerpt":"<ul>\n<li>Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).<br><b>Example 1:</b><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input: [<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>]</div><div class=\"line\"></div><div class=\"line\">Output: <span class=\"number\">1</span></div><div class=\"line\"></div><div class=\"line\">Explanation: The third maximum is <span class=\"number\">1.</span></div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><b>Example 2:</b><br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input: [1, 2]</div><div class=\"line\"></div><div class=\"line\">Output: 2</div><div class=\"line\"></div><div class=\"line\">Explanation: The third maximum does not exist, so the maximum (2) is returned instead.</div></pre></td></tr></table></figure></p>\n<p><b>Example 3:</b><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Input: [<span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">1</span>]</div><div class=\"line\"></div><div class=\"line\">Output: <span class=\"number\">1</span></div><div class=\"line\"></div><div class=\"line\">Explanation: Note that the third maximum here means the third maximum distinct number.</div><div class=\"line\">Both numbers with value <span class=\"number\">2</span> are both considered as second maximum.</div></pre></td></tr></table></figure></p>\n<h1 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h1><ul>\n<li>翻译：给一个非空整型数组，返回第三大的数字，如果不存在则返回最大的数字，要求时间复杂度为0（n）","more":"</li>\n<li>思路：初始化数组temp[3]，循环比较给定数组中的数字，把循环过程中前三数字放在temp[3]中，最后检查temp数组有没有被填满，如果有就说明第三大的数字存在，如果没有就不存在，按要求返回数值即可。<h2 id=\"C-C\"><a href=\"#C-C\" class=\"headerlink\" title=\"C/C++\"></a>C/C++</h2></li>\n</ul>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">thirdMax</span><span class=\"params\">(<span class=\"keyword\">int</span>* nums, <span class=\"keyword\">int</span> numsSize)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> flag,flag1,flag2=<span class=\"number\">0</span>;</div><div class=\"line\">    <span class=\"keyword\">int</span> temp[<span class=\"number\">3</span>]=&#123; <span class=\"number\">-2147483648</span>, <span class=\"number\">-2147483648</span>, <span class=\"number\">-2147483648</span>&#125;;</div><div class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;numsSize;i++) &#123;</div><div class=\"line\">       <span class=\"keyword\">if</span>(nums[i]&gt;temp[<span class=\"number\">2</span>]) &#123;</div><div class=\"line\">           <span class=\"keyword\">if</span>(flag2==<span class=\"number\">1</span>) &#123;</div><div class=\"line\">               <span class=\"keyword\">if</span>(flag1==<span class=\"number\">1</span>)&#123;</div><div class=\"line\">                temp[<span class=\"number\">0</span>] = temp[<span class=\"number\">1</span>];</div><div class=\"line\">                temp[<span class=\"number\">1</span>] = temp[<span class=\"number\">2</span>];</div><div class=\"line\">                temp[<span class=\"number\">2</span>] = nums[i];</div><div class=\"line\">                flag =<span class=\"number\">1</span>;</div><div class=\"line\">               &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                <span class=\"comment\">//temp[0] = temp[1];</span></div><div class=\"line\">                temp[<span class=\"number\">1</span>] = temp[<span class=\"number\">2</span>];</div><div class=\"line\">                temp[<span class=\"number\">2</span>] = nums[i];</div><div class=\"line\">                flag1 =<span class=\"number\">1</span>;   <span class=\"comment\">//标记该位被占 </span></div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">              temp[<span class=\"number\">2</span>] = nums[i];</div><div class=\"line\">              flag2=<span class=\"number\">1</span>;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[i]==temp[<span class=\"number\">2</span>]) &#123; </div><div class=\"line\">           flag2=<span class=\"number\">1</span>;   <span class=\"comment\">//表示这一位被占</span></div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>((nums[i]&lt;temp[<span class=\"number\">2</span>])&amp;&amp;(nums[i]&gt;temp[<span class=\"number\">1</span>])) &#123;</div><div class=\"line\">           <span class=\"keyword\">if</span>(flag1==<span class=\"number\">1</span>) &#123;</div><div class=\"line\">               temp[<span class=\"number\">0</span>] = temp[<span class=\"number\">1</span>];</div><div class=\"line\">               temp[<span class=\"number\">1</span>] = nums[i];</div><div class=\"line\">               flag=<span class=\"number\">1</span>;</div><div class=\"line\">           &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">               temp[<span class=\"number\">1</span>] = nums[i];</div><div class=\"line\">               flag1=<span class=\"number\">1</span>;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[i]==temp[<span class=\"number\">1</span>]) &#123;</div><div class=\"line\">           flag1=<span class=\"number\">1</span>;    <span class=\"comment\">//表示此位被占</span></div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>((nums[i]&lt;temp[<span class=\"number\">1</span>])&amp;&amp;(nums[i]&gt;temp[<span class=\"number\">0</span>])) &#123;</div><div class=\"line\">           <span class=\"keyword\">if</span>(flag ==<span class=\"number\">1</span>) &#123;</div><div class=\"line\">               temp[<span class=\"number\">0</span>]=nums[i];</div><div class=\"line\">           &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">               temp[<span class=\"number\">0</span>]=nums[i];</div><div class=\"line\">               flag=<span class=\"number\">1</span>;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[i]==temp[<span class=\"number\">0</span>]) &#123;</div><div class=\"line\">           flag=<span class=\"number\">1</span>;</div><div class=\"line\">       &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span>(flag==<span class=\"number\">1</span>) </div><div class=\"line\">        <span class=\"keyword\">return</span> temp[<span class=\"number\">0</span>];</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">        <span class=\"keyword\">return</span> temp[<span class=\"number\">2</span>];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"Python\"><a href=\"#Python\" class=\"headerlink\" title=\"Python\"></a>Python</h2><h2 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h2><h1 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h1><p>这道题在leetcode中难度级别为easy，但是ac率只有20%多，根据自己做这道题感觉最大的原因不是没有思路，而且细节处理上，特别是如果确定是否存在第三大的数字，还有就是int范围等。</p>"},{"title":"菜鸟，新的征程","date":"2016-07-20T08:21:14.000Z","comments":1,"_content":"\n我想首先我要介绍一下我的现状。我目前在北京理工读研究生，研究方向是模式识别与智能系统。<br/>\n2015年07月本科毕业，那个时候自己既没有选择工作，考研也失败了。我非常焦虑和担心，幸好有父母和朋友的支持和帮助，我决定了二战。由于二战，这个网站也关闭了一年多。现在也终于重新上线了，我把他弄成了我个人的博客，分享生活，交流技术。<br/>\n我个人主要会分享`C|C++|Shell|Python|模式识别|ML&&DL|数据结构与算法|Markdown|Git|Linux`等相关方面的内容。你对相关内容有任何看法与见解，非常欢迎一起沟通交流。<br/>\n菜鸟，新的征程。New bird，New beginning。\n\n\n\n","source":"_posts/Summary/New-Begining.md","raw":"---\ntitle: 菜鸟，新的征程\ndate: 2016-07-20 16:21:14\ncategories:\n- 生活\ntags:\n- 随笔\ncomments: true\n---\n\n我想首先我要介绍一下我的现状。我目前在北京理工读研究生，研究方向是模式识别与智能系统。<br/>\n2015年07月本科毕业，那个时候自己既没有选择工作，考研也失败了。我非常焦虑和担心，幸好有父母和朋友的支持和帮助，我决定了二战。由于二战，这个网站也关闭了一年多。现在也终于重新上线了，我把他弄成了我个人的博客，分享生活，交流技术。<br/>\n我个人主要会分享`C|C++|Shell|Python|模式识别|ML&&DL|数据结构与算法|Markdown|Git|Linux`等相关方面的内容。你对相关内容有任何看法与见解，非常欢迎一起沟通交流。<br/>\n菜鸟，新的征程。New bird，New beginning。\n\n\n\n","slug":"Summary/New-Begining","published":1,"updated":"2017-05-29T15:22:55.885Z","layout":"post","photos":[],"link":"","_id":"cj3aal9ts0019094uq9ulnfy6","content":"<p>我想首先我要介绍一下我的现状。我目前在北京理工读研究生，研究方向是模式识别与智能系统。<br><br>2015年07月本科毕业，那个时候自己既没有选择工作，考研也失败了。我非常焦虑和担心，幸好有父母和朋友的支持和帮助，我决定了二战。由于二战，这个网站也关闭了一年多。现在也终于重新上线了，我把他弄成了我个人的博客，分享生活，交流技术。<br><br>我个人主要会分享<code>C|C++|Shell|Python|模式识别|ML&amp;&amp;DL|数据结构与算法|Markdown|Git|Linux</code>等相关方面的内容。你对相关内容有任何看法与见解，非常欢迎一起沟通交流。<br><br>菜鸟，新的征程。New bird，New beginning。</p>\n","excerpt":"","more":"<p>我想首先我要介绍一下我的现状。我目前在北京理工读研究生，研究方向是模式识别与智能系统。<br/><br>2015年07月本科毕业，那个时候自己既没有选择工作，考研也失败了。我非常焦虑和担心，幸好有父母和朋友的支持和帮助，我决定了二战。由于二战，这个网站也关闭了一年多。现在也终于重新上线了，我把他弄成了我个人的博客，分享生活，交流技术。<br/><br>我个人主要会分享<code>C|C++|Shell|Python|模式识别|ML&amp;&amp;DL|数据结构与算法|Markdown|Git|Linux</code>等相关方面的内容。你对相关内容有任何看法与见解，非常欢迎一起沟通交流。<br/><br>菜鸟，新的征程。New bird，New beginning。</p>\n"},{"title":"博客更新日志","date":"2016-09-21T13:05:02.000Z","_content":"\n* 2016.07.01 采用Github+Hexo方案搭建NewBird博客\n* 2016.07.05 采用七牛云作为图片存储方案,采用乐视云作为视频存储方案\n* 2016.08.20 把博客代码分为两个分支，上传至Github，实现在不同设备、平台更新博客\n* 2016.08.23 添加About页面，修改页面\n* 2016.09.21 添加多说评论系统，删除Disqus评论系统\n* 2016.09.22 规范页面，规范文章格式、分类、标签等 \n* 2016.10.20 coding和github双部署\n\n","source":"_posts/Summary/test.md","raw":"---\ntitle: 博客更新日志\ndate: 2016-09-21 21:05:02\ntag: \n - hexo\ncategories: \n - 技术 \n---\n\n* 2016.07.01 采用Github+Hexo方案搭建NewBird博客\n* 2016.07.05 采用七牛云作为图片存储方案,采用乐视云作为视频存储方案\n* 2016.08.20 把博客代码分为两个分支，上传至Github，实现在不同设备、平台更新博客\n* 2016.08.23 添加About页面，修改页面\n* 2016.09.21 添加多说评论系统，删除Disqus评论系统\n* 2016.09.22 规范页面，规范文章格式、分类、标签等 \n* 2016.10.20 coding和github双部署\n\n","slug":"Summary/test","published":1,"updated":"2017-05-29T15:22:55.885Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3aal9ty001d094u4htc2lvd","content":"<ul>\n<li>2016.07.01 采用Github+Hexo方案搭建NewBird博客</li>\n<li>2016.07.05 采用七牛云作为图片存储方案,采用乐视云作为视频存储方案</li>\n<li>2016.08.20 把博客代码分为两个分支，上传至Github，实现在不同设备、平台更新博客</li>\n<li>2016.08.23 添加About页面，修改页面</li>\n<li>2016.09.21 添加多说评论系统，删除Disqus评论系统</li>\n<li>2016.09.22 规范页面，规范文章格式、分类、标签等 </li>\n<li>2016.10.20 coding和github双部署</li>\n</ul>\n","excerpt":"","more":"<ul>\n<li>2016.07.01 采用Github+Hexo方案搭建NewBird博客</li>\n<li>2016.07.05 采用七牛云作为图片存储方案,采用乐视云作为视频存储方案</li>\n<li>2016.08.20 把博客代码分为两个分支，上传至Github，实现在不同设备、平台更新博客</li>\n<li>2016.08.23 添加About页面，修改页面</li>\n<li>2016.09.21 添加多说评论系统，删除Disqus评论系统</li>\n<li>2016.09.22 规范页面，规范文章格式、分类、标签等 </li>\n<li>2016.10.20 coding和github双部署</li>\n</ul>\n"},{"title":"HigtGUI的初识","date":"2017-02-28T22:48:02.000Z","comments":1,"_content":"\n1. <b>imread()函数</b>\n\tMat imread(const string & filename, int flags = 1);\n其中第一个参数表示要读取的图像文件名， const string &类型的filename。值得注意的是图像的路径。支持多种类型的图像载入，主流的有bmp\\jpg\\jpeg\\png\\ppm\\pgm\\ras\\tif等类型。\n第二个参数表示载入标识，就是需要以何种方式把原图像呈现，默认参数为1。可以在OpenCV的图像标识枚举中选取：\n\n```\nenum\n{\n/* 8bit, color or not */\n//新的版本中已经取消，忽略，原通道读取\n    CV_LOAD_IMAGE_UNCHANGED  =-1, \n/* 8bit, gray */\n//原图像转换为灰度图像输出\n    CV_LOAD_IMAGE_GRAYSCALE  =0,\n/* ?, color */\n//原图像转换为彩色图像输出，如果原图像是灰度图像，输出还是灰度\n    CV_LOAD_IMAGE_COLOR      =1,\n/* any depth, ? */\n//如果图像深度为16或者32位，则输出相应深度的图像，否则转换为8位深度图像\n    CV_LOAD_IMAGE_ANYDEPTH   =2,\n/* ?, any color */\n//原图像色彩保持不变\n    CV_LOAD_IMAGE_ANYCOLOR   =4\n};\n```\n但是OpenCV3中这些宏都失效，故采用数字。\n```\nMat img = imread(\"pic.jpg\",2|4)  //载入无损的源图像\n```\n<!--more-->\n2. <b>imshow()函数</b>\nvoid imshow(const string & winname, InputArray mat);\nconst string & winname: 显示到哪个窗口；\nInputArray mat: 图像数据，InputArray类型简单（笼统）理解成Mat类型吧\n\n3. <b>namedWindow()函数</b>\nvoid namedWindow(const string & winname, int flags = WINDOW_AUTOSIZE);\nconst string & winname: 创建这个窗口名字；\nint flags: 窗口属性\n```\nWINDOW_NORMAL: 可以改变窗口大小\nWINDOW_AUTOSIZW: 根据图像大小自动调整，用户不能调整\nWINDOW_OPENGL: 窗口支持OpenGL\n```\n\n4. <b>imwrite()函数</b>\nbool imwrite(const string & filename, InputArray img, const vector<int>& params = vector<int>());\nconst string & filename: 图片另存为 什么格式，什么路径\nInputArray img: 要保存的图像数据\nconst vector<int>& params: 就是图像编码标识（这是一个int类型的vector,默认为空）\n+ 对于JPEG格式图像：表示保存的图像质量（CV_IMWRITE_JPEG_QUALITY） 0-100,越大质量越高，默认95；\n+ 对于PNG： 表示图像压缩级别（CV_IMWRITE_PNG_COMPRESSION） 0-9，越大压缩程度越大， 默认3；\n+ 对于PPM，PGM，PBM：表示二进制格式表示（CV_IMWRITE_PXM_BINARY），0或1，默认1，这个参数没有太懂是什么意思；\n\n5. <b>createTrackbar()函数</b>\nint createTrackbar( const string & trackbarname, const string & winname, int * value, int count,  TrackbarCallback onChange=0, void * userdata=0);\nconst\n\n6. </b>getTrackbarPos()函数</b>\nint getTrackbarPos(const string & trackbarname, cosnt string & winname);\n就是获取当前滑动条的位置。\nconst string & trackbarname: 滑动条名字\nconst string & winname: 窗口名字。\n\n7. <b>setMouseCallBack()函数</b>\nvoid setMouseCallBack(const string & winname, MouseCallback onMouse, void * userdata = 0)\nMousecallback onMouse: 鼠标事件的回调函数，这个函数的格式为 void func(int event, intx, int y, int flags, void * param),其中event是指鼠标事件（是单击左键，右键等），x和y表示鼠标在图像坐标系（不是窗口坐标系）的坐标。\n\n\n\n8. <b>BUG警示</b>\n在键入一个保存图像的程序，在Debug模式下运行，编译、链接都成功，运行阶段程序报错：Openc Error ：Assertion failed <size.width>0 && size.height>0> in cv::imshow file ..\\opencv\\modules\\highgui\\src\\window.cpp line 261\n![程序报错](http://oapeb119y.bkt.clouddn.com/Highgui%E4%B9%8B%E9%93%BE%E6%8E%A5%E5%BA%93%E9%94%99%E8%AF%AF%EF%BD%82.png)\n\n```\n#include<opencv2/opencv.hpp>\n#include <opencv2/highgui/highgui.hpp>\nusing namespace cv;\nusing namespace std;\n\nint main( )\n{\n\t//显示图片\n\ttry{\n\t\t//imwrite(\"透明Alpha值图.PNG\", mat,compression_params);\n\t\tMat a = imread(\"learn.jpg\",1);\n\t\tnamedWindow(\"nima\",WINDOW_AUTOSIZE);\n\t\timshow(\"nima\",a);\n\t\twaitKey(0);\n\t}\n\tcatch(runtime_error& ex) {\n\t\tfprintf(stderr,\"发生错误：%s\\n\", ex.what());\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n```\n原因： 这是Opencv 2.4.1版本以来的一个BUG，编译器将自动优先选择依赖项（就是lib库）。在【属性管理器】->【Debug|Win32】->Microsof.cpp.win32.user【属性】->【链接器】->【输入】->【附加依赖库】中，在安装配置时，添加了两种依赖库，一种是名称后面不带d的（是release模式下链接库），一种是带的（是Debug下的链接库）。但是编译器自动选择放置在前面的链接库作为默认支持的调试方式。我是把不带d的lib库放在前面，导致Debug模式下的各种错误（因为字符串读取问题引起的如图片载入不了、报指针越界、内存错误等）。\n\n解决方法：由于我常在Debug模式下调试，故将带d的lib库放在不带d的lib库前面，重新生成解决方案后，Debug模式下程序正常。但是想在Release模式下怎么办呢？工程切换至Relea模式，【项目】->【属性】->【链接器】->【输入】->【附加依赖库】添加不带d的lib链接库，重新生成解决方案，完美解决。值得欣慰的是，在OpenCV3中这个ＢＵＧ已经修复了。\n\n<b>总结</b>\n主要是熟悉OpenCV简单的图像操作，以及滑动条以及鼠标等交互方式。\n\n","source":"_posts/OpenCV/HigtGUI的初识.md","raw":"---\ntitle: HigtGUI的初识\ndate: 2017-03-01 06:48:02\ncategories:\n- 技术\ntags:\n- OpenCV基础\n- c++\ncomments: true\n---\n\n1. <b>imread()函数</b>\n\tMat imread(const string & filename, int flags = 1);\n其中第一个参数表示要读取的图像文件名， const string &类型的filename。值得注意的是图像的路径。支持多种类型的图像载入，主流的有bmp\\jpg\\jpeg\\png\\ppm\\pgm\\ras\\tif等类型。\n第二个参数表示载入标识，就是需要以何种方式把原图像呈现，默认参数为1。可以在OpenCV的图像标识枚举中选取：\n\n```\nenum\n{\n/* 8bit, color or not */\n//新的版本中已经取消，忽略，原通道读取\n    CV_LOAD_IMAGE_UNCHANGED  =-1, \n/* 8bit, gray */\n//原图像转换为灰度图像输出\n    CV_LOAD_IMAGE_GRAYSCALE  =0,\n/* ?, color */\n//原图像转换为彩色图像输出，如果原图像是灰度图像，输出还是灰度\n    CV_LOAD_IMAGE_COLOR      =1,\n/* any depth, ? */\n//如果图像深度为16或者32位，则输出相应深度的图像，否则转换为8位深度图像\n    CV_LOAD_IMAGE_ANYDEPTH   =2,\n/* ?, any color */\n//原图像色彩保持不变\n    CV_LOAD_IMAGE_ANYCOLOR   =4\n};\n```\n但是OpenCV3中这些宏都失效，故采用数字。\n```\nMat img = imread(\"pic.jpg\",2|4)  //载入无损的源图像\n```\n<!--more-->\n2. <b>imshow()函数</b>\nvoid imshow(const string & winname, InputArray mat);\nconst string & winname: 显示到哪个窗口；\nInputArray mat: 图像数据，InputArray类型简单（笼统）理解成Mat类型吧\n\n3. <b>namedWindow()函数</b>\nvoid namedWindow(const string & winname, int flags = WINDOW_AUTOSIZE);\nconst string & winname: 创建这个窗口名字；\nint flags: 窗口属性\n```\nWINDOW_NORMAL: 可以改变窗口大小\nWINDOW_AUTOSIZW: 根据图像大小自动调整，用户不能调整\nWINDOW_OPENGL: 窗口支持OpenGL\n```\n\n4. <b>imwrite()函数</b>\nbool imwrite(const string & filename, InputArray img, const vector<int>& params = vector<int>());\nconst string & filename: 图片另存为 什么格式，什么路径\nInputArray img: 要保存的图像数据\nconst vector<int>& params: 就是图像编码标识（这是一个int类型的vector,默认为空）\n+ 对于JPEG格式图像：表示保存的图像质量（CV_IMWRITE_JPEG_QUALITY） 0-100,越大质量越高，默认95；\n+ 对于PNG： 表示图像压缩级别（CV_IMWRITE_PNG_COMPRESSION） 0-9，越大压缩程度越大， 默认3；\n+ 对于PPM，PGM，PBM：表示二进制格式表示（CV_IMWRITE_PXM_BINARY），0或1，默认1，这个参数没有太懂是什么意思；\n\n5. <b>createTrackbar()函数</b>\nint createTrackbar( const string & trackbarname, const string & winname, int * value, int count,  TrackbarCallback onChange=0, void * userdata=0);\nconst\n\n6. </b>getTrackbarPos()函数</b>\nint getTrackbarPos(const string & trackbarname, cosnt string & winname);\n就是获取当前滑动条的位置。\nconst string & trackbarname: 滑动条名字\nconst string & winname: 窗口名字。\n\n7. <b>setMouseCallBack()函数</b>\nvoid setMouseCallBack(const string & winname, MouseCallback onMouse, void * userdata = 0)\nMousecallback onMouse: 鼠标事件的回调函数，这个函数的格式为 void func(int event, intx, int y, int flags, void * param),其中event是指鼠标事件（是单击左键，右键等），x和y表示鼠标在图像坐标系（不是窗口坐标系）的坐标。\n\n\n\n8. <b>BUG警示</b>\n在键入一个保存图像的程序，在Debug模式下运行，编译、链接都成功，运行阶段程序报错：Openc Error ：Assertion failed <size.width>0 && size.height>0> in cv::imshow file ..\\opencv\\modules\\highgui\\src\\window.cpp line 261\n![程序报错](http://oapeb119y.bkt.clouddn.com/Highgui%E4%B9%8B%E9%93%BE%E6%8E%A5%E5%BA%93%E9%94%99%E8%AF%AF%EF%BD%82.png)\n\n```\n#include<opencv2/opencv.hpp>\n#include <opencv2/highgui/highgui.hpp>\nusing namespace cv;\nusing namespace std;\n\nint main( )\n{\n\t//显示图片\n\ttry{\n\t\t//imwrite(\"透明Alpha值图.PNG\", mat,compression_params);\n\t\tMat a = imread(\"learn.jpg\",1);\n\t\tnamedWindow(\"nima\",WINDOW_AUTOSIZE);\n\t\timshow(\"nima\",a);\n\t\twaitKey(0);\n\t}\n\tcatch(runtime_error& ex) {\n\t\tfprintf(stderr,\"发生错误：%s\\n\", ex.what());\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n```\n原因： 这是Opencv 2.4.1版本以来的一个BUG，编译器将自动优先选择依赖项（就是lib库）。在【属性管理器】->【Debug|Win32】->Microsof.cpp.win32.user【属性】->【链接器】->【输入】->【附加依赖库】中，在安装配置时，添加了两种依赖库，一种是名称后面不带d的（是release模式下链接库），一种是带的（是Debug下的链接库）。但是编译器自动选择放置在前面的链接库作为默认支持的调试方式。我是把不带d的lib库放在前面，导致Debug模式下的各种错误（因为字符串读取问题引起的如图片载入不了、报指针越界、内存错误等）。\n\n解决方法：由于我常在Debug模式下调试，故将带d的lib库放在不带d的lib库前面，重新生成解决方案后，Debug模式下程序正常。但是想在Release模式下怎么办呢？工程切换至Relea模式，【项目】->【属性】->【链接器】->【输入】->【附加依赖库】添加不带d的lib链接库，重新生成解决方案，完美解决。值得欣慰的是，在OpenCV3中这个ＢＵＧ已经修复了。\n\n<b>总结</b>\n主要是熟悉OpenCV简单的图像操作，以及滑动条以及鼠标等交互方式。\n\n","slug":"OpenCV/HigtGUI的初识","published":1,"updated":"2017-05-29T15:22:55.885Z","layout":"post","photos":[],"link":"","_id":"cj3aal9u3001h094umcvbxlq8","content":"<ol>\n<li><b>imread()函数</b><br> Mat imread(const string &amp; filename, int flags = 1);<br>其中第一个参数表示要读取的图像文件名， const string &amp;类型的filename。值得注意的是图像的路径。支持多种类型的图像载入，主流的有bmp\\jpg\\jpeg\\png\\ppm\\pgm\\ras\\tif等类型。<br>第二个参数表示载入标识，就是需要以何种方式把原图像呈现，默认参数为1。可以在OpenCV的图像标识枚举中选取：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">enum</div><div class=\"line\">&#123;</div><div class=\"line\">/* 8bit, color or not */</div><div class=\"line\">//新的版本中已经取消，忽略，原通道读取</div><div class=\"line\">    CV_LOAD_IMAGE_UNCHANGED  =-1, </div><div class=\"line\">/* 8bit, gray */</div><div class=\"line\">//原图像转换为灰度图像输出</div><div class=\"line\">    CV_LOAD_IMAGE_GRAYSCALE  =0,</div><div class=\"line\">/* ?, color */</div><div class=\"line\">//原图像转换为彩色图像输出，如果原图像是灰度图像，输出还是灰度</div><div class=\"line\">    CV_LOAD_IMAGE_COLOR      =1,</div><div class=\"line\">/* any depth, ? */</div><div class=\"line\">//如果图像深度为16或者32位，则输出相应深度的图像，否则转换为8位深度图像</div><div class=\"line\">    CV_LOAD_IMAGE_ANYDEPTH   =2,</div><div class=\"line\">/* ?, any color */</div><div class=\"line\">//原图像色彩保持不变</div><div class=\"line\">    CV_LOAD_IMAGE_ANYCOLOR   =4</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>但是OpenCV3中这些宏都失效，故采用数字。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Mat img = imread(&quot;pic.jpg&quot;,2|4)  //载入无损的源图像</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<ol>\n<li><p><b>imshow()函数</b><br>void imshow(const string &amp; winname, InputArray mat);<br>const string &amp; winname: 显示到哪个窗口；<br>InputArray mat: 图像数据，InputArray类型简单（笼统）理解成Mat类型吧</p>\n</li>\n<li><p><b>namedWindow()函数</b><br>void namedWindow(const string &amp; winname, int flags = WINDOW_AUTOSIZE);<br>const string &amp; winname: 创建这个窗口名字；<br>int flags: 窗口属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">WINDOW_NORMAL: 可以改变窗口大小</div><div class=\"line\">WINDOW_AUTOSIZW: 根据图像大小自动调整，用户不能调整</div><div class=\"line\">WINDOW_OPENGL: 窗口支持OpenGL</div></pre></td></tr></table></figure>\n</li>\n<li><p><b>imwrite()函数</b><br>bool imwrite(const string &amp; filename, InputArray img, const vector<int>&amp; params = vector<int>());<br>const string &amp; filename: 图片另存为 什么格式，什么路径<br>InputArray img: 要保存的图像数据<br>const vector<int>&amp; params: 就是图像编码标识（这是一个int类型的vector,默认为空）</int></int></int></p>\n</li>\n</ol>\n<ul>\n<li>对于JPEG格式图像：表示保存的图像质量（CV_IMWRITE_JPEG_QUALITY） 0-100,越大质量越高，默认95；</li>\n<li>对于PNG： 表示图像压缩级别（CV_IMWRITE_PNG_COMPRESSION） 0-9，越大压缩程度越大， 默认3；</li>\n<li>对于PPM，PGM，PBM：表示二进制格式表示（CV_IMWRITE_PXM_BINARY），0或1，默认1，这个参数没有太懂是什么意思；</li>\n</ul>\n<ol>\n<li><p><b>createTrackbar()函数</b><br>int createTrackbar( const string &amp; trackbarname, const string &amp; winname, int <em> value, int count,  TrackbarCallback onChange=0, void </em> userdata=0);<br>const</p>\n</li>\n<li><p>getTrackbarPos()函数<br>int getTrackbarPos(const string &amp; trackbarname, cosnt string &amp; winname);<br>就是获取当前滑动条的位置。<br>const string &amp; trackbarname: 滑动条名字<br>const string &amp; winname: 窗口名字。</p>\n</li>\n<li><p><b>setMouseCallBack()函数</b><br>void setMouseCallBack(const string &amp; winname, MouseCallback onMouse, void <em> userdata = 0)<br>Mousecallback onMouse: 鼠标事件的回调函数，这个函数的格式为 void func(int event, intx, int y, int flags, void </em> param),其中event是指鼠标事件（是单击左键，右键等），x和y表示鼠标在图像坐标系（不是窗口坐标系）的坐标。</p>\n</li>\n</ol>\n<ol>\n<li><b>BUG警示</b><br>在键入一个保存图像的程序，在Debug模式下运行，编译、链接都成功，运行阶段程序报错：Openc Error ：Assertion failed <size.width>0 &amp;&amp; size.height&gt;0&gt; in cv::imshow file ..\\opencv\\modules\\highgui\\src\\window.cpp line 261<br><img src=\"http://oapeb119y.bkt.clouddn.com/Highgui%E4%B9%8B%E9%93%BE%E6%8E%A5%E5%BA%93%E9%94%99%E8%AF%AF%EF%BD%82.png\" alt=\"程序报错\"></size.width></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include&lt;opencv2/opencv.hpp&gt;</div><div class=\"line\">#include &lt;opencv2/highgui/highgui.hpp&gt;</div><div class=\"line\">using namespace cv;</div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">int main( )</div><div class=\"line\">&#123;</div><div class=\"line\">\t//显示图片</div><div class=\"line\">\ttry&#123;</div><div class=\"line\">\t\t//imwrite(&quot;透明Alpha值图.PNG&quot;, mat,compression_params);</div><div class=\"line\">\t\tMat a = imread(&quot;learn.jpg&quot;,1);</div><div class=\"line\">\t\tnamedWindow(&quot;nima&quot;,WINDOW_AUTOSIZE);</div><div class=\"line\">\t\timshow(&quot;nima&quot;,a);</div><div class=\"line\">\t\twaitKey(0);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tcatch(runtime_error&amp; ex) &#123;</div><div class=\"line\">\t\tfprintf(stderr,&quot;发生错误：%s\\n&quot;, ex.what());</div><div class=\"line\">\t\treturn 1;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\treturn 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>原因： 这是Opencv 2.4.1版本以来的一个BUG，编译器将自动优先选择依赖项（就是lib库）。在【属性管理器】-&gt;【Debug|Win32】-&gt;Microsof.cpp.win32.user【属性】-&gt;【链接器】-&gt;【输入】-&gt;【附加依赖库】中，在安装配置时，添加了两种依赖库，一种是名称后面不带d的（是release模式下链接库），一种是带的（是Debug下的链接库）。但是编译器自动选择放置在前面的链接库作为默认支持的调试方式。我是把不带d的lib库放在前面，导致Debug模式下的各种错误（因为字符串读取问题引起的如图片载入不了、报指针越界、内存错误等）。</p>\n<p>解决方法：由于我常在Debug模式下调试，故将带d的lib库放在不带d的lib库前面，重新生成解决方案后，Debug模式下程序正常。但是想在Release模式下怎么办呢？工程切换至Relea模式，【项目】-&gt;【属性】-&gt;【链接器】-&gt;【输入】-&gt;【附加依赖库】添加不带d的lib链接库，重新生成解决方案，完美解决。值得欣慰的是，在OpenCV3中这个ＢＵＧ已经修复了。</p>\n<p><b>总结</b><br>主要是熟悉OpenCV简单的图像操作，以及滑动条以及鼠标等交互方式。</p>\n","excerpt":"<ol>\n<li><b>imread()函数</b><br> Mat imread(const string &amp; filename, int flags = 1);<br>其中第一个参数表示要读取的图像文件名， const string &amp;类型的filename。值得注意的是图像的路径。支持多种类型的图像载入，主流的有bmp\\jpg\\jpeg\\png\\ppm\\pgm\\ras\\tif等类型。<br>第二个参数表示载入标识，就是需要以何种方式把原图像呈现，默认参数为1。可以在OpenCV的图像标识枚举中选取：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">enum</div><div class=\"line\">&#123;</div><div class=\"line\">/* 8bit, color or not */</div><div class=\"line\">//新的版本中已经取消，忽略，原通道读取</div><div class=\"line\">    CV_LOAD_IMAGE_UNCHANGED  =-1, </div><div class=\"line\">/* 8bit, gray */</div><div class=\"line\">//原图像转换为灰度图像输出</div><div class=\"line\">    CV_LOAD_IMAGE_GRAYSCALE  =0,</div><div class=\"line\">/* ?, color */</div><div class=\"line\">//原图像转换为彩色图像输出，如果原图像是灰度图像，输出还是灰度</div><div class=\"line\">    CV_LOAD_IMAGE_COLOR      =1,</div><div class=\"line\">/* any depth, ? */</div><div class=\"line\">//如果图像深度为16或者32位，则输出相应深度的图像，否则转换为8位深度图像</div><div class=\"line\">    CV_LOAD_IMAGE_ANYDEPTH   =2,</div><div class=\"line\">/* ?, any color */</div><div class=\"line\">//原图像色彩保持不变</div><div class=\"line\">    CV_LOAD_IMAGE_ANYCOLOR   =4</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>但是OpenCV3中这些宏都失效，故采用数字。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Mat img = imread(&quot;pic.jpg&quot;,2|4)  //载入无损的源图像</div></pre></td></tr></table></figure></p>","more":"<ol>\n<li><p><b>imshow()函数</b><br>void imshow(const string &amp; winname, InputArray mat);<br>const string &amp; winname: 显示到哪个窗口；<br>InputArray mat: 图像数据，InputArray类型简单（笼统）理解成Mat类型吧</p>\n</li>\n<li><p><b>namedWindow()函数</b><br>void namedWindow(const string &amp; winname, int flags = WINDOW_AUTOSIZE);<br>const string &amp; winname: 创建这个窗口名字；<br>int flags: 窗口属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">WINDOW_NORMAL: 可以改变窗口大小</div><div class=\"line\">WINDOW_AUTOSIZW: 根据图像大小自动调整，用户不能调整</div><div class=\"line\">WINDOW_OPENGL: 窗口支持OpenGL</div></pre></td></tr></table></figure>\n</li>\n<li><p><b>imwrite()函数</b><br>bool imwrite(const string &amp; filename, InputArray img, const vector<int>&amp; params = vector<int>());<br>const string &amp; filename: 图片另存为 什么格式，什么路径<br>InputArray img: 要保存的图像数据<br>const vector<int>&amp; params: 就是图像编码标识（这是一个int类型的vector,默认为空）</p>\n</li>\n</ol>\n<ul>\n<li>对于JPEG格式图像：表示保存的图像质量（CV_IMWRITE_JPEG_QUALITY） 0-100,越大质量越高，默认95；</li>\n<li>对于PNG： 表示图像压缩级别（CV_IMWRITE_PNG_COMPRESSION） 0-9，越大压缩程度越大， 默认3；</li>\n<li>对于PPM，PGM，PBM：表示二进制格式表示（CV_IMWRITE_PXM_BINARY），0或1，默认1，这个参数没有太懂是什么意思；</li>\n</ul>\n<ol>\n<li><p><b>createTrackbar()函数</b><br>int createTrackbar( const string &amp; trackbarname, const string &amp; winname, int <em> value, int count,  TrackbarCallback onChange=0, void </em> userdata=0);<br>const</p>\n</li>\n<li><p></b>getTrackbarPos()函数</b><br>int getTrackbarPos(const string &amp; trackbarname, cosnt string &amp; winname);<br>就是获取当前滑动条的位置。<br>const string &amp; trackbarname: 滑动条名字<br>const string &amp; winname: 窗口名字。</p>\n</li>\n<li><p><b>setMouseCallBack()函数</b><br>void setMouseCallBack(const string &amp; winname, MouseCallback onMouse, void <em> userdata = 0)<br>Mousecallback onMouse: 鼠标事件的回调函数，这个函数的格式为 void func(int event, intx, int y, int flags, void </em> param),其中event是指鼠标事件（是单击左键，右键等），x和y表示鼠标在图像坐标系（不是窗口坐标系）的坐标。</p>\n</li>\n</ol>\n<ol>\n<li><b>BUG警示</b><br>在键入一个保存图像的程序，在Debug模式下运行，编译、链接都成功，运行阶段程序报错：Openc Error ：Assertion failed <size.width>0 &amp;&amp; size.height&gt;0&gt; in cv::imshow file ..\\opencv\\modules\\highgui\\src\\window.cpp line 261<br><img src=\"http://oapeb119y.bkt.clouddn.com/Highgui%E4%B9%8B%E9%93%BE%E6%8E%A5%E5%BA%93%E9%94%99%E8%AF%AF%EF%BD%82.png\" alt=\"程序报错\"></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include&lt;opencv2/opencv.hpp&gt;</div><div class=\"line\">#include &lt;opencv2/highgui/highgui.hpp&gt;</div><div class=\"line\">using namespace cv;</div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">int main( )</div><div class=\"line\">&#123;</div><div class=\"line\">\t//显示图片</div><div class=\"line\">\ttry&#123;</div><div class=\"line\">\t\t//imwrite(&quot;透明Alpha值图.PNG&quot;, mat,compression_params);</div><div class=\"line\">\t\tMat a = imread(&quot;learn.jpg&quot;,1);</div><div class=\"line\">\t\tnamedWindow(&quot;nima&quot;,WINDOW_AUTOSIZE);</div><div class=\"line\">\t\timshow(&quot;nima&quot;,a);</div><div class=\"line\">\t\twaitKey(0);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tcatch(runtime_error&amp; ex) &#123;</div><div class=\"line\">\t\tfprintf(stderr,&quot;发生错误：%s\\n&quot;, ex.what());</div><div class=\"line\">\t\treturn 1;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\treturn 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>原因： 这是Opencv 2.4.1版本以来的一个BUG，编译器将自动优先选择依赖项（就是lib库）。在【属性管理器】-&gt;【Debug|Win32】-&gt;Microsof.cpp.win32.user【属性】-&gt;【链接器】-&gt;【输入】-&gt;【附加依赖库】中，在安装配置时，添加了两种依赖库，一种是名称后面不带d的（是release模式下链接库），一种是带的（是Debug下的链接库）。但是编译器自动选择放置在前面的链接库作为默认支持的调试方式。我是把不带d的lib库放在前面，导致Debug模式下的各种错误（因为字符串读取问题引起的如图片载入不了、报指针越界、内存错误等）。</p>\n<p>解决方法：由于我常在Debug模式下调试，故将带d的lib库放在不带d的lib库前面，重新生成解决方案后，Debug模式下程序正常。但是想在Release模式下怎么办呢？工程切换至Relea模式，【项目】-&gt;【属性】-&gt;【链接器】-&gt;【输入】-&gt;【附加依赖库】添加不带d的lib链接库，重新生成解决方案，完美解决。值得欣慰的是，在OpenCV3中这个ＢＵＧ已经修复了。</p>\n<p><b>总结</b><br>主要是熟悉OpenCV简单的图像操作，以及滑动条以及鼠标等交互方式。</p>"},{"title":"OpenCV数据结构与基本绘图","date":"2017-03-28T14:54:20.000Z","comments":1,"_content":"1. IplImage与Mat\n在最开始，OpenCV使用基于C语言接口构建，因此在较早版本的OpenCV中使用IplImage存储图像数据。这就造成了一定的问题，在调试了的时候，需要程序员手动release为IplImage分配的内存，不然可能造成内存泄漏。\n在OpenCV2.0以来，就引入了C++接口，也就产生了基于C++的Mat数据结构，没错，它是可以自动内存管理的，因此我们现在用的最多的就是Mat数据结构了。Mat类很方便，不用手动分配内存、释放内存。\n那么为什么IplImage还继续顽强存在呢，那就是因为大部分嵌入式系统只支持C语言.\n\n2. Mat类 包含两个数据部分，一个部分是矩阵头（矩阵尺寸、存储方法、存储地址等），另一部分指向存储所有像素值得矩阵。\n\n需要记住的是，大多时候复制Mat类，只是引用矩阵头，而不是复制整个像素矩阵，这将导致巨大的时间成本。因此，OpenCV采用引用计数机制，每个Mat对象都有独自的矩阵头，但是共享一个像素矩阵。常见的复制构造函数、赋值符号都是只复制矩阵头，而不是复制整个像素矩阵。\n\n```\n//以下三个Mat对象有不同的矩阵头，但是共享一个矩阵\nMat A;   //创建矩阵头部分\nA = imread(const string & filename, 1);  // 为矩阵开辟空间\nMat B(A);  //采用复制构造函数\nMat C = A;\n```\n\n+ 引用计数机制在上面的例子中有很好的说明，矩阵的引用次数为3，当Mat C的矩阵头被释放后，引用计数就减1，当引用次数为0时，矩阵空间就会被释放。\n\n+ 那么如果想复制整个矩阵，就需要使用clone()和copyTo()函数。\n\n```\nMat D = A.clone();\nMat E;\nA.copyTo(E);\n```\n\n+ 简要小结\n++ OpenCV函数中C++接口，图像的内存都自动分配、释放；\n++ 复制构造函数和赋值运算符只复制矩阵头；\n++ clone(),copyTo()函数可以复制矩阵。\n\n\n3. Mat对象的创建和显式\nMat类型有多种创建方法，\n+ 采用默认构造函数\n+ 使用构造函数初始化\n+ 为IplImage对象创建Mat信息头\n+ 使用Create（）成员函数\n+ 采用Matlab方式初始化\n+ 采用逗号分隔符方式初始化\n+ 为已存在的Mat对象创建新信息头\n具体初始化代码如下：\n```\n   //方法1：使用Mat（）构造函数\n\tMat M(2, 2, CV_8UC3, Scalar(0,0,255));\n\tcout << \"M = \" << endl << \" \" << M << endl;\n\n\t//way2 没有太懂，由于这是多维的数组，使用cout出错\n\tint sz[3] = {2, 2, 2};\n\tMat L(3, sz, CV_8UC3, Scalar::all(0));\n\t\n\t//way3 为IplImage创建信息头\n\tIplImage* img = cvLoadImage(\"D:\\\\C++程序联系文件夹（可选择性删除）\\\\OpenCV_Exercise\\\\learn.jpg\",1);\n\tMat mtx(img);\n\n\t//way4 使用Create()函数\n\tMat K;\n\tK.create(4,4,CV_8UC(2));\n\tcout << \"K = \" << endl << \" \" << K << endl << endl;\n\t//way5 Matlab大法好\n\tMat E = Mat::eye(4,4,CV_64F);\n\tcout << \"E = \" << endl << \" \" << E << endl << endl;\n\n\tMat O = Mat::ones(2,2,CV_32F);\n\tcout << \"O = \" << endl << \" \" << O << endl << endl;\n\n\tMat Z = Mat::zeros(3,3,CV_8UC1);\n\tcout << \"Z = \" << endl << \" \" << Z << endl << endl;\n\n\t//way6 \n\tMat C = (Mat_<double>(3,3) << 0, -1, 2, -1, 5, -1, 0, -1, 0);\n\tcout << \"C = \" << endl << \" \" << C << endl << endl;\n\n\t//way7 为已存在的对象创建新的信息头\n\tMat RowClone = C.row(0).clone();\n\tcout << \"RowClone = \" << endl << \" \" << RowClone << endl << endl;\n```\nMat类型的格式化输出方法，\n+ OpenCV默认方式\n+ Python输出风格\n+ 逗号分隔风格（CSV）\n+ Numpy风格\n+ C语言风格\n例程如下：\n```\n\tMat r = Mat(3, 3, CV_8UC3);\n\trandu(r, Scalar::all(0), Scalar::all(255));\n\t//OpenCV格式化输出\n\t//way1 Opencv默认输出格式\n\tcout << \"r 默认输出格式: \" << endl << r << endl;\n\n\t//way2 python风格思密达\n\tcout << \"r Python风格: \" << endl << format(r, \"python\") << endl;\n\n\t//way3 CSV风格\n\tcout << \"r CSV风格: \"  << endl << format(r, \"csv\") << endl;\n\n\t//way4 Numpy风格\n\tcout << \"r Numpy风格: \" << endl << format(r, \"numpy\") << endl;\n\n\t//way5 C style\n\tcout << \"r C style: \" << endl << format(r, \"C\") << endl;\n```\n![输出格式](http://oapeb119y.bkt.clouddn.com/image/opencv/Mat%E8%BE%93%E5%87%BA%E9%A3%8E%E6%A0%BC.png)\n\n4. OpenCV中常用基于图像的数据结构与函数介绍\n+ 点的表示：Point 类\n二维坐标系下的点\n```\n\tPoint2f p(6,2);\n\tcout << \"[二维点] p = \" << p << endl;\n\n\tPoint3f l(1,2,3);\n\tcout << \"[三维点] l = \" << l << endl;\n\n\tvector<float> v;\n\tv.push_back(3);\n\tv.push_back(5);\n\tv.push_back(4);\n\tcout << \"[基于Mat的Vector] v = \" << Mat(v) << endl;\n\n\tvector<Point2f> points(20);\n\tfor(size_t i = 0; i < points.size(); ++i)\n\t{\n\t\tpoints[i] = Point2f((float)(i*5),(float)(i%7));\n\t}\n\tcout << \"[二维点向量] points = \" << points << \";\";\n```\nPoint2f、Point3f等等其实都是一个类模板Point_<typename T>.具体定义core.hpp中。\n```\ntemplate<typename _Tp> class Point_\n{\npublic:\n    typedef _Tp value_type;\n\n    // various constructors\n    Point_();\n    Point_(_Tp _x, _Tp _y);\n    Point_(const Point_& pt);\n    Point_(const CvPoint& pt);\n    Point_(const CvPoint2D32f& pt);\n    Point_(const Size_<_Tp>& sz);\n    Point_(const Vec<_Tp, 2>& v);\n\n    Point_& operator = (const Point_& pt);\n    //! conversion to another data type\n    template<typename _Tp2> operator Point_<_Tp2>() const;\n\n    //! conversion to the old-style C structures\n    operator CvPoint() const;\n    operator CvPoint2D32f() const;\n    operator Vec<_Tp, 2>() const;\n\n    //! dot product\n    _Tp dot(const Point_& pt) const;\n    //! dot product computed in double-precision arithmetics\n    double ddot(const Point_& pt) const;\n    //! cross-product\n    double cross(const Point_& pt) const;\n    //! checks whether the point is inside the specified rectangle\n    bool inside(const Rect_<_Tp>& r) const;\n\n    _Tp x, y; //< the point coordinates\n}; \n\ntypedef Point_<int> Point2i;\ntypedef Point2i Point;\ntypedef Point_<float> Point2f;\n\n```\n从这个二维点的类模板可以看出Point_<float> Point2f 都等价。\n\n+ 颜色的表示： Scalar 类\n这个也是OpenCV中实现的类模板，其实可以简单的看成包含4个元素的Vector,不过一般我们都是用RGB表示颜色，因此只用到三个元素。<b>需要注意的是，OpenCV默认的图片通道存储顺序不是我们熟悉的RGB，而是BGR。<\\b>下面为Scalar模板类的源码，位于core.hpp中。\n```\ntemplate<typename _Tp> class Scalar_ : public Vec<_Tp, 4>\n{\npublic:\n    //! various constructors\n    Scalar_();\n    Scalar_(_Tp v0, _Tp v1, _Tp v2=0, _Tp v3=0);\n    Scalar_(const CvScalar& s);\n    Scalar_(_Tp v0);\n\n    //! returns a scalar with all elements set to v0\n    static Scalar_<_Tp> all(_Tp v0);\n    //! conversion to the old-style CvScalar\n    operator CvScalar() const;\n\n    //! conversion to another data type\n    template<typename T2> operator Scalar_<T2>() const;\n\n    //! per-element product\n    Scalar_<_Tp> mul(const Scalar_<_Tp>& t, double scale=1 ) const;\n\n    // returns (v0, -v1, -v2, -v3)\n    Scalar_<_Tp> conj() const;\n\n    // returns true iff v1 == v2 == v3 == 0\n    bool isReal() const;\n};\n\ntypedef Scalar_<double> Scalar;\n```\n+ 尺寸的表示： Size 类\n与以上的基本都一样，也是一个类模板，此处不详细描述。常用：' Size(5, 6) // width 5, height 6 '.\n+ 矩阵的表示： Rect 类\n同上。\n+ 颜色的空间转换： cvtColor() 函数\n`void cvtColor(InputArray src, OutputArray dst, int code, int dstCn = 0);`\nInputArray src：输入图像\nOutputArray dst: 输出图像\nint code: 颜色空间转换标识符，是一堆枚举值，具体见`.../imgproc/types_c.h`\nint dstCn: 目标图像的通道数，默认值为0，取原图像的通道数\n\n\n\n","source":"_posts/OpenCV/OpenCV数据结构与基本绘图.md","raw":"---\ntitle: OpenCV数据结构与基本绘图\ndate: 2017-03-28 22:54:20\ncategories:\n- 技术\ntags:\n- OpenCV基础\n- c++\ncomments: true\n---\n1. IplImage与Mat\n在最开始，OpenCV使用基于C语言接口构建，因此在较早版本的OpenCV中使用IplImage存储图像数据。这就造成了一定的问题，在调试了的时候，需要程序员手动release为IplImage分配的内存，不然可能造成内存泄漏。\n在OpenCV2.0以来，就引入了C++接口，也就产生了基于C++的Mat数据结构，没错，它是可以自动内存管理的，因此我们现在用的最多的就是Mat数据结构了。Mat类很方便，不用手动分配内存、释放内存。\n那么为什么IplImage还继续顽强存在呢，那就是因为大部分嵌入式系统只支持C语言.\n\n2. Mat类 包含两个数据部分，一个部分是矩阵头（矩阵尺寸、存储方法、存储地址等），另一部分指向存储所有像素值得矩阵。\n\n需要记住的是，大多时候复制Mat类，只是引用矩阵头，而不是复制整个像素矩阵，这将导致巨大的时间成本。因此，OpenCV采用引用计数机制，每个Mat对象都有独自的矩阵头，但是共享一个像素矩阵。常见的复制构造函数、赋值符号都是只复制矩阵头，而不是复制整个像素矩阵。\n\n```\n//以下三个Mat对象有不同的矩阵头，但是共享一个矩阵\nMat A;   //创建矩阵头部分\nA = imread(const string & filename, 1);  // 为矩阵开辟空间\nMat B(A);  //采用复制构造函数\nMat C = A;\n```\n\n+ 引用计数机制在上面的例子中有很好的说明，矩阵的引用次数为3，当Mat C的矩阵头被释放后，引用计数就减1，当引用次数为0时，矩阵空间就会被释放。\n\n+ 那么如果想复制整个矩阵，就需要使用clone()和copyTo()函数。\n\n```\nMat D = A.clone();\nMat E;\nA.copyTo(E);\n```\n\n+ 简要小结\n++ OpenCV函数中C++接口，图像的内存都自动分配、释放；\n++ 复制构造函数和赋值运算符只复制矩阵头；\n++ clone(),copyTo()函数可以复制矩阵。\n\n\n3. Mat对象的创建和显式\nMat类型有多种创建方法，\n+ 采用默认构造函数\n+ 使用构造函数初始化\n+ 为IplImage对象创建Mat信息头\n+ 使用Create（）成员函数\n+ 采用Matlab方式初始化\n+ 采用逗号分隔符方式初始化\n+ 为已存在的Mat对象创建新信息头\n具体初始化代码如下：\n```\n   //方法1：使用Mat（）构造函数\n\tMat M(2, 2, CV_8UC3, Scalar(0,0,255));\n\tcout << \"M = \" << endl << \" \" << M << endl;\n\n\t//way2 没有太懂，由于这是多维的数组，使用cout出错\n\tint sz[3] = {2, 2, 2};\n\tMat L(3, sz, CV_8UC3, Scalar::all(0));\n\t\n\t//way3 为IplImage创建信息头\n\tIplImage* img = cvLoadImage(\"D:\\\\C++程序联系文件夹（可选择性删除）\\\\OpenCV_Exercise\\\\learn.jpg\",1);\n\tMat mtx(img);\n\n\t//way4 使用Create()函数\n\tMat K;\n\tK.create(4,4,CV_8UC(2));\n\tcout << \"K = \" << endl << \" \" << K << endl << endl;\n\t//way5 Matlab大法好\n\tMat E = Mat::eye(4,4,CV_64F);\n\tcout << \"E = \" << endl << \" \" << E << endl << endl;\n\n\tMat O = Mat::ones(2,2,CV_32F);\n\tcout << \"O = \" << endl << \" \" << O << endl << endl;\n\n\tMat Z = Mat::zeros(3,3,CV_8UC1);\n\tcout << \"Z = \" << endl << \" \" << Z << endl << endl;\n\n\t//way6 \n\tMat C = (Mat_<double>(3,3) << 0, -1, 2, -1, 5, -1, 0, -1, 0);\n\tcout << \"C = \" << endl << \" \" << C << endl << endl;\n\n\t//way7 为已存在的对象创建新的信息头\n\tMat RowClone = C.row(0).clone();\n\tcout << \"RowClone = \" << endl << \" \" << RowClone << endl << endl;\n```\nMat类型的格式化输出方法，\n+ OpenCV默认方式\n+ Python输出风格\n+ 逗号分隔风格（CSV）\n+ Numpy风格\n+ C语言风格\n例程如下：\n```\n\tMat r = Mat(3, 3, CV_8UC3);\n\trandu(r, Scalar::all(0), Scalar::all(255));\n\t//OpenCV格式化输出\n\t//way1 Opencv默认输出格式\n\tcout << \"r 默认输出格式: \" << endl << r << endl;\n\n\t//way2 python风格思密达\n\tcout << \"r Python风格: \" << endl << format(r, \"python\") << endl;\n\n\t//way3 CSV风格\n\tcout << \"r CSV风格: \"  << endl << format(r, \"csv\") << endl;\n\n\t//way4 Numpy风格\n\tcout << \"r Numpy风格: \" << endl << format(r, \"numpy\") << endl;\n\n\t//way5 C style\n\tcout << \"r C style: \" << endl << format(r, \"C\") << endl;\n```\n![输出格式](http://oapeb119y.bkt.clouddn.com/image/opencv/Mat%E8%BE%93%E5%87%BA%E9%A3%8E%E6%A0%BC.png)\n\n4. OpenCV中常用基于图像的数据结构与函数介绍\n+ 点的表示：Point 类\n二维坐标系下的点\n```\n\tPoint2f p(6,2);\n\tcout << \"[二维点] p = \" << p << endl;\n\n\tPoint3f l(1,2,3);\n\tcout << \"[三维点] l = \" << l << endl;\n\n\tvector<float> v;\n\tv.push_back(3);\n\tv.push_back(5);\n\tv.push_back(4);\n\tcout << \"[基于Mat的Vector] v = \" << Mat(v) << endl;\n\n\tvector<Point2f> points(20);\n\tfor(size_t i = 0; i < points.size(); ++i)\n\t{\n\t\tpoints[i] = Point2f((float)(i*5),(float)(i%7));\n\t}\n\tcout << \"[二维点向量] points = \" << points << \";\";\n```\nPoint2f、Point3f等等其实都是一个类模板Point_<typename T>.具体定义core.hpp中。\n```\ntemplate<typename _Tp> class Point_\n{\npublic:\n    typedef _Tp value_type;\n\n    // various constructors\n    Point_();\n    Point_(_Tp _x, _Tp _y);\n    Point_(const Point_& pt);\n    Point_(const CvPoint& pt);\n    Point_(const CvPoint2D32f& pt);\n    Point_(const Size_<_Tp>& sz);\n    Point_(const Vec<_Tp, 2>& v);\n\n    Point_& operator = (const Point_& pt);\n    //! conversion to another data type\n    template<typename _Tp2> operator Point_<_Tp2>() const;\n\n    //! conversion to the old-style C structures\n    operator CvPoint() const;\n    operator CvPoint2D32f() const;\n    operator Vec<_Tp, 2>() const;\n\n    //! dot product\n    _Tp dot(const Point_& pt) const;\n    //! dot product computed in double-precision arithmetics\n    double ddot(const Point_& pt) const;\n    //! cross-product\n    double cross(const Point_& pt) const;\n    //! checks whether the point is inside the specified rectangle\n    bool inside(const Rect_<_Tp>& r) const;\n\n    _Tp x, y; //< the point coordinates\n}; \n\ntypedef Point_<int> Point2i;\ntypedef Point2i Point;\ntypedef Point_<float> Point2f;\n\n```\n从这个二维点的类模板可以看出Point_<float> Point2f 都等价。\n\n+ 颜色的表示： Scalar 类\n这个也是OpenCV中实现的类模板，其实可以简单的看成包含4个元素的Vector,不过一般我们都是用RGB表示颜色，因此只用到三个元素。<b>需要注意的是，OpenCV默认的图片通道存储顺序不是我们熟悉的RGB，而是BGR。<\\b>下面为Scalar模板类的源码，位于core.hpp中。\n```\ntemplate<typename _Tp> class Scalar_ : public Vec<_Tp, 4>\n{\npublic:\n    //! various constructors\n    Scalar_();\n    Scalar_(_Tp v0, _Tp v1, _Tp v2=0, _Tp v3=0);\n    Scalar_(const CvScalar& s);\n    Scalar_(_Tp v0);\n\n    //! returns a scalar with all elements set to v0\n    static Scalar_<_Tp> all(_Tp v0);\n    //! conversion to the old-style CvScalar\n    operator CvScalar() const;\n\n    //! conversion to another data type\n    template<typename T2> operator Scalar_<T2>() const;\n\n    //! per-element product\n    Scalar_<_Tp> mul(const Scalar_<_Tp>& t, double scale=1 ) const;\n\n    // returns (v0, -v1, -v2, -v3)\n    Scalar_<_Tp> conj() const;\n\n    // returns true iff v1 == v2 == v3 == 0\n    bool isReal() const;\n};\n\ntypedef Scalar_<double> Scalar;\n```\n+ 尺寸的表示： Size 类\n与以上的基本都一样，也是一个类模板，此处不详细描述。常用：' Size(5, 6) // width 5, height 6 '.\n+ 矩阵的表示： Rect 类\n同上。\n+ 颜色的空间转换： cvtColor() 函数\n`void cvtColor(InputArray src, OutputArray dst, int code, int dstCn = 0);`\nInputArray src：输入图像\nOutputArray dst: 输出图像\nint code: 颜色空间转换标识符，是一堆枚举值，具体见`.../imgproc/types_c.h`\nint dstCn: 目标图像的通道数，默认值为0，取原图像的通道数\n\n\n\n","slug":"OpenCV/OpenCV数据结构与基本绘图","published":1,"updated":"2017-05-29T15:22:55.885Z","layout":"post","photos":[],"link":"","_id":"cj3aal9u7001k094u5q7rkzse","content":"<ol>\n<li><p>IplImage与Mat<br>在最开始，OpenCV使用基于C语言接口构建，因此在较早版本的OpenCV中使用IplImage存储图像数据。这就造成了一定的问题，在调试了的时候，需要程序员手动release为IplImage分配的内存，不然可能造成内存泄漏。<br>在OpenCV2.0以来，就引入了C++接口，也就产生了基于C++的Mat数据结构，没错，它是可以自动内存管理的，因此我们现在用的最多的就是Mat数据结构了。Mat类很方便，不用手动分配内存、释放内存。<br>那么为什么IplImage还继续顽强存在呢，那就是因为大部分嵌入式系统只支持C语言.</p>\n</li>\n<li><p>Mat类 包含两个数据部分，一个部分是矩阵头（矩阵尺寸、存储方法、存储地址等），另一部分指向存储所有像素值得矩阵。</p>\n</li>\n</ol>\n<p>需要记住的是，大多时候复制Mat类，只是引用矩阵头，而不是复制整个像素矩阵，这将导致巨大的时间成本。因此，OpenCV采用引用计数机制，每个Mat对象都有独自的矩阵头，但是共享一个像素矩阵。常见的复制构造函数、赋值符号都是只复制矩阵头，而不是复制整个像素矩阵。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//以下三个Mat对象有不同的矩阵头，但是共享一个矩阵</div><div class=\"line\">Mat A;   //创建矩阵头部分</div><div class=\"line\">A = imread(const string &amp; filename, 1);  // 为矩阵开辟空间</div><div class=\"line\">Mat B(A);  //采用复制构造函数</div><div class=\"line\">Mat C = A;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>引用计数机制在上面的例子中有很好的说明，矩阵的引用次数为3，当Mat C的矩阵头被释放后，引用计数就减1，当引用次数为0时，矩阵空间就会被释放。</p>\n</li>\n<li><p>那么如果想复制整个矩阵，就需要使用clone()和copyTo()函数。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Mat D = A.clone();</div><div class=\"line\">Mat E;</div><div class=\"line\">A.copyTo(E);</div></pre></td></tr></table></figure>\n<ul>\n<li>简要小结<br>++ OpenCV函数中C++接口，图像的内存都自动分配、释放；<br>++ 复制构造函数和赋值运算符只复制矩阵头；<br>++ clone(),copyTo()函数可以复制矩阵。</li>\n</ul>\n<ol>\n<li>Mat对象的创建和显式<br>Mat类型有多种创建方法，</li>\n</ol>\n<ul>\n<li>采用默认构造函数</li>\n<li>使用构造函数初始化</li>\n<li>为IplImage对象创建Mat信息头</li>\n<li>使用Create（）成员函数</li>\n<li>采用Matlab方式初始化</li>\n<li>采用逗号分隔符方式初始化</li>\n<li>为已存在的Mat对象创建新信息头<br>具体初始化代码如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">  //方法1：使用Mat（）构造函数</div><div class=\"line\">Mat M(2, 2, CV_8UC3, Scalar(0,0,255));</div><div class=\"line\">cout &lt;&lt; &quot;M = &quot; &lt;&lt; endl &lt;&lt; &quot; &quot; &lt;&lt; M &lt;&lt; endl;</div><div class=\"line\"></div><div class=\"line\">//way2 没有太懂，由于这是多维的数组，使用cout出错</div><div class=\"line\">int sz[3] = &#123;2, 2, 2&#125;;</div><div class=\"line\">Mat L(3, sz, CV_8UC3, Scalar::all(0));</div><div class=\"line\"></div><div class=\"line\">//way3 为IplImage创建信息头</div><div class=\"line\">IplImage* img = cvLoadImage(&quot;D:\\\\C++程序联系文件夹（可选择性删除）\\\\OpenCV_Exercise\\\\learn.jpg&quot;,1);</div><div class=\"line\">Mat mtx(img);</div><div class=\"line\"></div><div class=\"line\">//way4 使用Create()函数</div><div class=\"line\">Mat K;</div><div class=\"line\">K.create(4,4,CV_8UC(2));</div><div class=\"line\">cout &lt;&lt; &quot;K = &quot; &lt;&lt; endl &lt;&lt; &quot; &quot; &lt;&lt; K &lt;&lt; endl &lt;&lt; endl;</div><div class=\"line\">//way5 Matlab大法好</div><div class=\"line\">Mat E = Mat::eye(4,4,CV_64F);</div><div class=\"line\">cout &lt;&lt; &quot;E = &quot; &lt;&lt; endl &lt;&lt; &quot; &quot; &lt;&lt; E &lt;&lt; endl &lt;&lt; endl;</div><div class=\"line\"></div><div class=\"line\">Mat O = Mat::ones(2,2,CV_32F);</div><div class=\"line\">cout &lt;&lt; &quot;O = &quot; &lt;&lt; endl &lt;&lt; &quot; &quot; &lt;&lt; O &lt;&lt; endl &lt;&lt; endl;</div><div class=\"line\"></div><div class=\"line\">Mat Z = Mat::zeros(3,3,CV_8UC1);</div><div class=\"line\">cout &lt;&lt; &quot;Z = &quot; &lt;&lt; endl &lt;&lt; &quot; &quot; &lt;&lt; Z &lt;&lt; endl &lt;&lt; endl;</div><div class=\"line\"></div><div class=\"line\">//way6 </div><div class=\"line\">Mat C = (Mat_&lt;double&gt;(3,3) &lt;&lt; 0, -1, 2, -1, 5, -1, 0, -1, 0);</div><div class=\"line\">cout &lt;&lt; &quot;C = &quot; &lt;&lt; endl &lt;&lt; &quot; &quot; &lt;&lt; C &lt;&lt; endl &lt;&lt; endl;</div><div class=\"line\"></div><div class=\"line\">//way7 为已存在的对象创建新的信息头</div><div class=\"line\">Mat RowClone = C.row(0).clone();</div><div class=\"line\">cout &lt;&lt; &quot;RowClone = &quot; &lt;&lt; endl &lt;&lt; &quot; &quot; &lt;&lt; RowClone &lt;&lt; endl &lt;&lt; endl;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Mat类型的格式化输出方法，</p>\n<ul>\n<li>OpenCV默认方式</li>\n<li>Python输出风格</li>\n<li>逗号分隔风格（CSV）</li>\n<li>Numpy风格</li>\n<li>C语言风格<br>例程如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">Mat r = Mat(3, 3, CV_8UC3);</div><div class=\"line\">randu(r, Scalar::all(0), Scalar::all(255));</div><div class=\"line\">//OpenCV格式化输出</div><div class=\"line\">//way1 Opencv默认输出格式</div><div class=\"line\">cout &lt;&lt; &quot;r 默认输出格式: &quot; &lt;&lt; endl &lt;&lt; r &lt;&lt; endl;</div><div class=\"line\"></div><div class=\"line\">//way2 python风格思密达</div><div class=\"line\">cout &lt;&lt; &quot;r Python风格: &quot; &lt;&lt; endl &lt;&lt; format(r, &quot;python&quot;) &lt;&lt; endl;</div><div class=\"line\"></div><div class=\"line\">//way3 CSV风格</div><div class=\"line\">cout &lt;&lt; &quot;r CSV风格: &quot;  &lt;&lt; endl &lt;&lt; format(r, &quot;csv&quot;) &lt;&lt; endl;</div><div class=\"line\"></div><div class=\"line\">//way4 Numpy风格</div><div class=\"line\">cout &lt;&lt; &quot;r Numpy风格: &quot; &lt;&lt; endl &lt;&lt; format(r, &quot;numpy&quot;) &lt;&lt; endl;</div><div class=\"line\"></div><div class=\"line\">//way5 C style</div><div class=\"line\">cout &lt;&lt; &quot;r C style: &quot; &lt;&lt; endl &lt;&lt; format(r, &quot;C&quot;) &lt;&lt; endl;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"http://oapeb119y.bkt.clouddn.com/image/opencv/Mat%E8%BE%93%E5%87%BA%E9%A3%8E%E6%A0%BC.png\" alt=\"输出格式\"></p>\n<ol>\n<li>OpenCV中常用基于图像的数据结构与函数介绍</li>\n</ol>\n<ul>\n<li>点的表示：Point 类<br>二维坐标系下的点<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">Point2f p(6,2);</div><div class=\"line\">cout &lt;&lt; &quot;[二维点] p = &quot; &lt;&lt; p &lt;&lt; endl;</div><div class=\"line\"></div><div class=\"line\">Point3f l(1,2,3);</div><div class=\"line\">cout &lt;&lt; &quot;[三维点] l = &quot; &lt;&lt; l &lt;&lt; endl;</div><div class=\"line\"></div><div class=\"line\">vector&lt;float&gt; v;</div><div class=\"line\">v.push_back(3);</div><div class=\"line\">v.push_back(5);</div><div class=\"line\">v.push_back(4);</div><div class=\"line\">cout &lt;&lt; &quot;[基于Mat的Vector] v = &quot; &lt;&lt; Mat(v) &lt;&lt; endl;</div><div class=\"line\"></div><div class=\"line\">vector&lt;Point2f&gt; points(20);</div><div class=\"line\">for(size_t i = 0; i &lt; points.size(); ++i)</div><div class=\"line\">&#123;</div><div class=\"line\">\tpoints[i] = Point2f((float)(i*5),(float)(i%7));</div><div class=\"line\">&#125;</div><div class=\"line\">cout &lt;&lt; &quot;[二维点向量] points = &quot; &lt;&lt; points &lt;&lt; &quot;;&quot;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Point2f、Point3f等等其实都是一个类模板Point_<typename t=\"\">.具体定义core.hpp中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">template&lt;typename _Tp&gt; class Point_</div><div class=\"line\">&#123;</div><div class=\"line\">public:</div><div class=\"line\">    typedef _Tp value_type;</div><div class=\"line\"></div><div class=\"line\">    // various constructors</div><div class=\"line\">    Point_();</div><div class=\"line\">    Point_(_Tp _x, _Tp _y);</div><div class=\"line\">    Point_(const Point_&amp; pt);</div><div class=\"line\">    Point_(const CvPoint&amp; pt);</div><div class=\"line\">    Point_(const CvPoint2D32f&amp; pt);</div><div class=\"line\">    Point_(const Size_&lt;_Tp&gt;&amp; sz);</div><div class=\"line\">    Point_(const Vec&lt;_Tp, 2&gt;&amp; v);</div><div class=\"line\"></div><div class=\"line\">    Point_&amp; operator = (const Point_&amp; pt);</div><div class=\"line\">    //! conversion to another data type</div><div class=\"line\">    template&lt;typename _Tp2&gt; operator Point_&lt;_Tp2&gt;() const;</div><div class=\"line\"></div><div class=\"line\">    //! conversion to the old-style C structures</div><div class=\"line\">    operator CvPoint() const;</div><div class=\"line\">    operator CvPoint2D32f() const;</div><div class=\"line\">    operator Vec&lt;_Tp, 2&gt;() const;</div><div class=\"line\"></div><div class=\"line\">    //! dot product</div><div class=\"line\">    _Tp dot(const Point_&amp; pt) const;</div><div class=\"line\">    //! dot product computed in double-precision arithmetics</div><div class=\"line\">    double ddot(const Point_&amp; pt) const;</div><div class=\"line\">    //! cross-product</div><div class=\"line\">    double cross(const Point_&amp; pt) const;</div><div class=\"line\">    //! checks whether the point is inside the specified rectangle</div><div class=\"line\">    bool inside(const Rect_&lt;_Tp&gt;&amp; r) const;</div><div class=\"line\"></div><div class=\"line\">    _Tp x, y; //&lt; the point coordinates</div><div class=\"line\">&#125;; </div><div class=\"line\"></div><div class=\"line\">typedef Point_&lt;int&gt; Point2i;</div><div class=\"line\">typedef Point2i Point;</div><div class=\"line\">typedef Point_&lt;float&gt; Point2f;</div></pre></td></tr></table></figure></typename></p>\n<p>从这个二维点的类模板可以看出Point_<float> Point2f 都等价。</float></p>\n<ul>\n<li><p>颜色的表示： Scalar 类<br>这个也是OpenCV中实现的类模板，其实可以简单的看成包含4个元素的Vector,不过一般我们都是用RGB表示颜色，因此只用到三个元素。<b>需要注意的是，OpenCV默认的图片通道存储顺序不是我们熟悉的RGB，而是BGR。&lt;\\b&gt;下面为Scalar模板类的源码，位于core.hpp中。</b></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">template&lt;typename _Tp&gt; class Scalar_ : public Vec&lt;_Tp, 4&gt;</div><div class=\"line\">&#123;</div><div class=\"line\">public:</div><div class=\"line\">    //! various constructors</div><div class=\"line\">    Scalar_();</div><div class=\"line\">    Scalar_(_Tp v0, _Tp v1, _Tp v2=0, _Tp v3=0);</div><div class=\"line\">    Scalar_(const CvScalar&amp; s);</div><div class=\"line\">    Scalar_(_Tp v0);</div><div class=\"line\"></div><div class=\"line\">    //! returns a scalar with all elements set to v0</div><div class=\"line\">    static Scalar_&lt;_Tp&gt; all(_Tp v0);</div><div class=\"line\">    //! conversion to the old-style CvScalar</div><div class=\"line\">    operator CvScalar() const;</div><div class=\"line\"></div><div class=\"line\">    //! conversion to another data type</div><div class=\"line\">    template&lt;typename T2&gt; operator Scalar_&lt;T2&gt;() const;</div><div class=\"line\"></div><div class=\"line\">    //! per-element product</div><div class=\"line\">    Scalar_&lt;_Tp&gt; mul(const Scalar_&lt;_Tp&gt;&amp; t, double scale=1 ) const;</div><div class=\"line\"></div><div class=\"line\">    // returns (v0, -v1, -v2, -v3)</div><div class=\"line\">    Scalar_&lt;_Tp&gt; conj() const;</div><div class=\"line\"></div><div class=\"line\">    // returns true iff v1 == v2 == v3 == 0</div><div class=\"line\">    bool isReal() const;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">typedef Scalar_&lt;double&gt; Scalar;</div></pre></td></tr></table></figure>\n</li>\n<li><p>尺寸的表示： Size 类<br>与以上的基本都一样，也是一个类模板，此处不详细描述。常用：’ Size(5, 6) // width 5, height 6 ‘.</p>\n</li>\n<li>矩阵的表示： Rect 类<br>同上。</li>\n<li>颜色的空间转换： cvtColor() 函数<br><code>void cvtColor(InputArray src, OutputArray dst, int code, int dstCn = 0);</code><br>InputArray src：输入图像<br>OutputArray dst: 输出图像<br>int code: 颜色空间转换标识符，是一堆枚举值，具体见<code>.../imgproc/types_c.h</code><br>int dstCn: 目标图像的通道数，默认值为0，取原图像的通道数</li>\n</ul>\n","excerpt":"","more":"<ol>\n<li><p>IplImage与Mat<br>在最开始，OpenCV使用基于C语言接口构建，因此在较早版本的OpenCV中使用IplImage存储图像数据。这就造成了一定的问题，在调试了的时候，需要程序员手动release为IplImage分配的内存，不然可能造成内存泄漏。<br>在OpenCV2.0以来，就引入了C++接口，也就产生了基于C++的Mat数据结构，没错，它是可以自动内存管理的，因此我们现在用的最多的就是Mat数据结构了。Mat类很方便，不用手动分配内存、释放内存。<br>那么为什么IplImage还继续顽强存在呢，那就是因为大部分嵌入式系统只支持C语言.</p>\n</li>\n<li><p>Mat类 包含两个数据部分，一个部分是矩阵头（矩阵尺寸、存储方法、存储地址等），另一部分指向存储所有像素值得矩阵。</p>\n</li>\n</ol>\n<p>需要记住的是，大多时候复制Mat类，只是引用矩阵头，而不是复制整个像素矩阵，这将导致巨大的时间成本。因此，OpenCV采用引用计数机制，每个Mat对象都有独自的矩阵头，但是共享一个像素矩阵。常见的复制构造函数、赋值符号都是只复制矩阵头，而不是复制整个像素矩阵。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">//以下三个Mat对象有不同的矩阵头，但是共享一个矩阵</div><div class=\"line\">Mat A;   //创建矩阵头部分</div><div class=\"line\">A = imread(const string &amp; filename, 1);  // 为矩阵开辟空间</div><div class=\"line\">Mat B(A);  //采用复制构造函数</div><div class=\"line\">Mat C = A;</div></pre></td></tr></table></figure>\n<ul>\n<li><p>引用计数机制在上面的例子中有很好的说明，矩阵的引用次数为3，当Mat C的矩阵头被释放后，引用计数就减1，当引用次数为0时，矩阵空间就会被释放。</p>\n</li>\n<li><p>那么如果想复制整个矩阵，就需要使用clone()和copyTo()函数。</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Mat D = A.clone();</div><div class=\"line\">Mat E;</div><div class=\"line\">A.copyTo(E);</div></pre></td></tr></table></figure>\n<ul>\n<li>简要小结<br>++ OpenCV函数中C++接口，图像的内存都自动分配、释放；<br>++ 复制构造函数和赋值运算符只复制矩阵头；<br>++ clone(),copyTo()函数可以复制矩阵。</li>\n</ul>\n<ol>\n<li>Mat对象的创建和显式<br>Mat类型有多种创建方法，</li>\n</ol>\n<ul>\n<li>采用默认构造函数</li>\n<li>使用构造函数初始化</li>\n<li>为IplImage对象创建Mat信息头</li>\n<li>使用Create（）成员函数</li>\n<li>采用Matlab方式初始化</li>\n<li>采用逗号分隔符方式初始化</li>\n<li>为已存在的Mat对象创建新信息头<br>具体初始化代码如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">  //方法1：使用Mat（）构造函数</div><div class=\"line\">Mat M(2, 2, CV_8UC3, Scalar(0,0,255));</div><div class=\"line\">cout &lt;&lt; &quot;M = &quot; &lt;&lt; endl &lt;&lt; &quot; &quot; &lt;&lt; M &lt;&lt; endl;</div><div class=\"line\"></div><div class=\"line\">//way2 没有太懂，由于这是多维的数组，使用cout出错</div><div class=\"line\">int sz[3] = &#123;2, 2, 2&#125;;</div><div class=\"line\">Mat L(3, sz, CV_8UC3, Scalar::all(0));</div><div class=\"line\"></div><div class=\"line\">//way3 为IplImage创建信息头</div><div class=\"line\">IplImage* img = cvLoadImage(&quot;D:\\\\C++程序联系文件夹（可选择性删除）\\\\OpenCV_Exercise\\\\learn.jpg&quot;,1);</div><div class=\"line\">Mat mtx(img);</div><div class=\"line\"></div><div class=\"line\">//way4 使用Create()函数</div><div class=\"line\">Mat K;</div><div class=\"line\">K.create(4,4,CV_8UC(2));</div><div class=\"line\">cout &lt;&lt; &quot;K = &quot; &lt;&lt; endl &lt;&lt; &quot; &quot; &lt;&lt; K &lt;&lt; endl &lt;&lt; endl;</div><div class=\"line\">//way5 Matlab大法好</div><div class=\"line\">Mat E = Mat::eye(4,4,CV_64F);</div><div class=\"line\">cout &lt;&lt; &quot;E = &quot; &lt;&lt; endl &lt;&lt; &quot; &quot; &lt;&lt; E &lt;&lt; endl &lt;&lt; endl;</div><div class=\"line\"></div><div class=\"line\">Mat O = Mat::ones(2,2,CV_32F);</div><div class=\"line\">cout &lt;&lt; &quot;O = &quot; &lt;&lt; endl &lt;&lt; &quot; &quot; &lt;&lt; O &lt;&lt; endl &lt;&lt; endl;</div><div class=\"line\"></div><div class=\"line\">Mat Z = Mat::zeros(3,3,CV_8UC1);</div><div class=\"line\">cout &lt;&lt; &quot;Z = &quot; &lt;&lt; endl &lt;&lt; &quot; &quot; &lt;&lt; Z &lt;&lt; endl &lt;&lt; endl;</div><div class=\"line\"></div><div class=\"line\">//way6 </div><div class=\"line\">Mat C = (Mat_&lt;double&gt;(3,3) &lt;&lt; 0, -1, 2, -1, 5, -1, 0, -1, 0);</div><div class=\"line\">cout &lt;&lt; &quot;C = &quot; &lt;&lt; endl &lt;&lt; &quot; &quot; &lt;&lt; C &lt;&lt; endl &lt;&lt; endl;</div><div class=\"line\"></div><div class=\"line\">//way7 为已存在的对象创建新的信息头</div><div class=\"line\">Mat RowClone = C.row(0).clone();</div><div class=\"line\">cout &lt;&lt; &quot;RowClone = &quot; &lt;&lt; endl &lt;&lt; &quot; &quot; &lt;&lt; RowClone &lt;&lt; endl &lt;&lt; endl;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Mat类型的格式化输出方法，</p>\n<ul>\n<li>OpenCV默认方式</li>\n<li>Python输出风格</li>\n<li>逗号分隔风格（CSV）</li>\n<li>Numpy风格</li>\n<li>C语言风格<br>例程如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">Mat r = Mat(3, 3, CV_8UC3);</div><div class=\"line\">randu(r, Scalar::all(0), Scalar::all(255));</div><div class=\"line\">//OpenCV格式化输出</div><div class=\"line\">//way1 Opencv默认输出格式</div><div class=\"line\">cout &lt;&lt; &quot;r 默认输出格式: &quot; &lt;&lt; endl &lt;&lt; r &lt;&lt; endl;</div><div class=\"line\"></div><div class=\"line\">//way2 python风格思密达</div><div class=\"line\">cout &lt;&lt; &quot;r Python风格: &quot; &lt;&lt; endl &lt;&lt; format(r, &quot;python&quot;) &lt;&lt; endl;</div><div class=\"line\"></div><div class=\"line\">//way3 CSV风格</div><div class=\"line\">cout &lt;&lt; &quot;r CSV风格: &quot;  &lt;&lt; endl &lt;&lt; format(r, &quot;csv&quot;) &lt;&lt; endl;</div><div class=\"line\"></div><div class=\"line\">//way4 Numpy风格</div><div class=\"line\">cout &lt;&lt; &quot;r Numpy风格: &quot; &lt;&lt; endl &lt;&lt; format(r, &quot;numpy&quot;) &lt;&lt; endl;</div><div class=\"line\"></div><div class=\"line\">//way5 C style</div><div class=\"line\">cout &lt;&lt; &quot;r C style: &quot; &lt;&lt; endl &lt;&lt; format(r, &quot;C&quot;) &lt;&lt; endl;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"http://oapeb119y.bkt.clouddn.com/image/opencv/Mat%E8%BE%93%E5%87%BA%E9%A3%8E%E6%A0%BC.png\" alt=\"输出格式\"></p>\n<ol>\n<li>OpenCV中常用基于图像的数据结构与函数介绍</li>\n</ol>\n<ul>\n<li>点的表示：Point 类<br>二维坐标系下的点<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">Point2f p(6,2);</div><div class=\"line\">cout &lt;&lt; &quot;[二维点] p = &quot; &lt;&lt; p &lt;&lt; endl;</div><div class=\"line\"></div><div class=\"line\">Point3f l(1,2,3);</div><div class=\"line\">cout &lt;&lt; &quot;[三维点] l = &quot; &lt;&lt; l &lt;&lt; endl;</div><div class=\"line\"></div><div class=\"line\">vector&lt;float&gt; v;</div><div class=\"line\">v.push_back(3);</div><div class=\"line\">v.push_back(5);</div><div class=\"line\">v.push_back(4);</div><div class=\"line\">cout &lt;&lt; &quot;[基于Mat的Vector] v = &quot; &lt;&lt; Mat(v) &lt;&lt; endl;</div><div class=\"line\"></div><div class=\"line\">vector&lt;Point2f&gt; points(20);</div><div class=\"line\">for(size_t i = 0; i &lt; points.size(); ++i)</div><div class=\"line\">&#123;</div><div class=\"line\">\tpoints[i] = Point2f((float)(i*5),(float)(i%7));</div><div class=\"line\">&#125;</div><div class=\"line\">cout &lt;&lt; &quot;[二维点向量] points = &quot; &lt;&lt; points &lt;&lt; &quot;;&quot;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>Point2f、Point3f等等其实都是一个类模板Point_<typename T>.具体定义core.hpp中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">template&lt;typename _Tp&gt; class Point_</div><div class=\"line\">&#123;</div><div class=\"line\">public:</div><div class=\"line\">    typedef _Tp value_type;</div><div class=\"line\"></div><div class=\"line\">    // various constructors</div><div class=\"line\">    Point_();</div><div class=\"line\">    Point_(_Tp _x, _Tp _y);</div><div class=\"line\">    Point_(const Point_&amp; pt);</div><div class=\"line\">    Point_(const CvPoint&amp; pt);</div><div class=\"line\">    Point_(const CvPoint2D32f&amp; pt);</div><div class=\"line\">    Point_(const Size_&lt;_Tp&gt;&amp; sz);</div><div class=\"line\">    Point_(const Vec&lt;_Tp, 2&gt;&amp; v);</div><div class=\"line\"></div><div class=\"line\">    Point_&amp; operator = (const Point_&amp; pt);</div><div class=\"line\">    //! conversion to another data type</div><div class=\"line\">    template&lt;typename _Tp2&gt; operator Point_&lt;_Tp2&gt;() const;</div><div class=\"line\"></div><div class=\"line\">    //! conversion to the old-style C structures</div><div class=\"line\">    operator CvPoint() const;</div><div class=\"line\">    operator CvPoint2D32f() const;</div><div class=\"line\">    operator Vec&lt;_Tp, 2&gt;() const;</div><div class=\"line\"></div><div class=\"line\">    //! dot product</div><div class=\"line\">    _Tp dot(const Point_&amp; pt) const;</div><div class=\"line\">    //! dot product computed in double-precision arithmetics</div><div class=\"line\">    double ddot(const Point_&amp; pt) const;</div><div class=\"line\">    //! cross-product</div><div class=\"line\">    double cross(const Point_&amp; pt) const;</div><div class=\"line\">    //! checks whether the point is inside the specified rectangle</div><div class=\"line\">    bool inside(const Rect_&lt;_Tp&gt;&amp; r) const;</div><div class=\"line\"></div><div class=\"line\">    _Tp x, y; //&lt; the point coordinates</div><div class=\"line\">&#125;; </div><div class=\"line\"></div><div class=\"line\">typedef Point_&lt;int&gt; Point2i;</div><div class=\"line\">typedef Point2i Point;</div><div class=\"line\">typedef Point_&lt;float&gt; Point2f;</div></pre></td></tr></table></figure></p>\n<p>从这个二维点的类模板可以看出Point_<float> Point2f 都等价。</p>\n<ul>\n<li><p>颜色的表示： Scalar 类<br>这个也是OpenCV中实现的类模板，其实可以简单的看成包含4个元素的Vector,不过一般我们都是用RGB表示颜色，因此只用到三个元素。<b>需要注意的是，OpenCV默认的图片通道存储顺序不是我们熟悉的RGB，而是BGR。&lt;\\b&gt;下面为Scalar模板类的源码，位于core.hpp中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">template&lt;typename _Tp&gt; class Scalar_ : public Vec&lt;_Tp, 4&gt;</div><div class=\"line\">&#123;</div><div class=\"line\">public:</div><div class=\"line\">    //! various constructors</div><div class=\"line\">    Scalar_();</div><div class=\"line\">    Scalar_(_Tp v0, _Tp v1, _Tp v2=0, _Tp v3=0);</div><div class=\"line\">    Scalar_(const CvScalar&amp; s);</div><div class=\"line\">    Scalar_(_Tp v0);</div><div class=\"line\"></div><div class=\"line\">    //! returns a scalar with all elements set to v0</div><div class=\"line\">    static Scalar_&lt;_Tp&gt; all(_Tp v0);</div><div class=\"line\">    //! conversion to the old-style CvScalar</div><div class=\"line\">    operator CvScalar() const;</div><div class=\"line\"></div><div class=\"line\">    //! conversion to another data type</div><div class=\"line\">    template&lt;typename T2&gt; operator Scalar_&lt;T2&gt;() const;</div><div class=\"line\"></div><div class=\"line\">    //! per-element product</div><div class=\"line\">    Scalar_&lt;_Tp&gt; mul(const Scalar_&lt;_Tp&gt;&amp; t, double scale=1 ) const;</div><div class=\"line\"></div><div class=\"line\">    // returns (v0, -v1, -v2, -v3)</div><div class=\"line\">    Scalar_&lt;_Tp&gt; conj() const;</div><div class=\"line\"></div><div class=\"line\">    // returns true iff v1 == v2 == v3 == 0</div><div class=\"line\">    bool isReal() const;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">typedef Scalar_&lt;double&gt; Scalar;</div></pre></td></tr></table></figure>\n</li>\n<li><p>尺寸的表示： Size 类<br>与以上的基本都一样，也是一个类模板，此处不详细描述。常用：’ Size(5, 6) // width 5, height 6 ‘.</p>\n</li>\n<li>矩阵的表示： Rect 类<br>同上。</li>\n<li>颜色的空间转换： cvtColor() 函数<br><code>void cvtColor(InputArray src, OutputArray dst, int code, int dstCn = 0);</code><br>InputArray src：输入图像<br>OutputArray dst: 输出图像<br>int code: 颜色空间转换标识符，是一堆枚举值，具体见<code>.../imgproc/types_c.h</code><br>int dstCn: 目标图像的通道数，默认值为0，取原图像的通道数</li>\n</ul>\n"},{"title":"Linux下gedit打开文件产生带波浪号（～）的备份文件","date":"2016-12-20T00:00:17.000Z","_content":"  在ubuntu系统下，使用gedit编辑器打开文件（如test.md），会自动生成一个备份文件，文件名字为（原文件名＋波浪号 test.md~）,这种情况是为了防止系统或者编辑器突然崩溃，以恢复文件使用。但是有时候看着特别繁琐和凌乱。所以一下为解决办法，相反也可以开启自动备份功能。\n# 如何快速删除此类备份文件\n\trm -rf *.*~\n\n+ -f --force 忽略不存在文件，强制删除并不提示\n+ -r --recursive 删除该目录及其子目录下所有符合条件的文件\n+ *.*~ *代表任意，任意文件名+'.'+任意文件类型后缀+'~',满足该条件的文件都删除\n\n# 如何设置取消生成自动备份文件\n+ gedit编辑器：　最大化窗口->Edit->Preferences->Editor->file saving->取消'Creat a backup copy of files before saving'选项，中文系统同理。\n+ Vi/Vim编辑器: \n\tvi ~/.vimrc\n\tset nobackup\n通过以上方法可以实现删除或者取消自动备份文件功能，相反可以开启自动备份功能。\n","source":"_posts/Linux_shell/Linux下gedit打开文件产生带波浪号（～）的备份文件.md","raw":"---\ntitle: Linux下gedit打开文件产生带波浪号（～）的备份文件\ndate: 2016-12-20 08:00:17\ntag: \n - Linux\ncategories: \n - 技术 \n---\n  在ubuntu系统下，使用gedit编辑器打开文件（如test.md），会自动生成一个备份文件，文件名字为（原文件名＋波浪号 test.md~）,这种情况是为了防止系统或者编辑器突然崩溃，以恢复文件使用。但是有时候看着特别繁琐和凌乱。所以一下为解决办法，相反也可以开启自动备份功能。\n# 如何快速删除此类备份文件\n\trm -rf *.*~\n\n+ -f --force 忽略不存在文件，强制删除并不提示\n+ -r --recursive 删除该目录及其子目录下所有符合条件的文件\n+ *.*~ *代表任意，任意文件名+'.'+任意文件类型后缀+'~',满足该条件的文件都删除\n\n# 如何设置取消生成自动备份文件\n+ gedit编辑器：　最大化窗口->Edit->Preferences->Editor->file saving->取消'Creat a backup copy of files before saving'选项，中文系统同理。\n+ Vi/Vim编辑器: \n\tvi ~/.vimrc\n\tset nobackup\n通过以上方法可以实现删除或者取消自动备份文件功能，相反可以开启自动备份功能。\n","slug":"Linux_shell/Linux下gedit打开文件产生带波浪号（～）的备份文件","published":1,"updated":"2017-05-29T15:22:55.885Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3aal9uc001n094uvxodhpht","content":"<p>  在ubuntu系统下，使用gedit编辑器打开文件（如test.md），会自动生成一个备份文件，文件名字为（原文件名＋波浪号 test.md~）,这种情况是为了防止系统或者编辑器突然崩溃，以恢复文件使用。但是有时候看着特别繁琐和凌乱。所以一下为解决办法，相反也可以开启自动备份功能。</p>\n<h1 id=\"如何快速删除此类备份文件\"><a href=\"#如何快速删除此类备份文件\" class=\"headerlink\" title=\"如何快速删除此类备份文件\"></a>如何快速删除此类备份文件</h1><pre><code>rm -rf *.*~\n</code></pre><ul>\n<li>-f –force 忽略不存在文件，强制删除并不提示</li>\n<li>-r –recursive 删除该目录及其子目录下所有符合条件的文件</li>\n<li><em>.</em>~ *代表任意，任意文件名+’.’+任意文件类型后缀+’~’,满足该条件的文件都删除</li>\n</ul>\n<h1 id=\"如何设置取消生成自动备份文件\"><a href=\"#如何设置取消生成自动备份文件\" class=\"headerlink\" title=\"如何设置取消生成自动备份文件\"></a>如何设置取消生成自动备份文件</h1><ul>\n<li>gedit编辑器：　最大化窗口-&gt;Edit-&gt;Preferences-&gt;Editor-&gt;file saving-&gt;取消’Creat a backup copy of files before saving’选项，中文系统同理。</li>\n<li>Vi/Vim编辑器:<br>  vi ~/.vimrc<br>  set nobackup<br>通过以上方法可以实现删除或者取消自动备份文件功能，相反可以开启自动备份功能。</li>\n</ul>\n","excerpt":"","more":"<p>  在ubuntu系统下，使用gedit编辑器打开文件（如test.md），会自动生成一个备份文件，文件名字为（原文件名＋波浪号 test.md~）,这种情况是为了防止系统或者编辑器突然崩溃，以恢复文件使用。但是有时候看着特别繁琐和凌乱。所以一下为解决办法，相反也可以开启自动备份功能。</p>\n<h1 id=\"如何快速删除此类备份文件\"><a href=\"#如何快速删除此类备份文件\" class=\"headerlink\" title=\"如何快速删除此类备份文件\"></a>如何快速删除此类备份文件</h1><pre><code>rm -rf *.*~\n</code></pre><ul>\n<li>-f –force 忽略不存在文件，强制删除并不提示</li>\n<li>-r –recursive 删除该目录及其子目录下所有符合条件的文件</li>\n<li><em>.</em>~ *代表任意，任意文件名+’.’+任意文件类型后缀+’~’,满足该条件的文件都删除</li>\n</ul>\n<h1 id=\"如何设置取消生成自动备份文件\"><a href=\"#如何设置取消生成自动备份文件\" class=\"headerlink\" title=\"如何设置取消生成自动备份文件\"></a>如何设置取消生成自动备份文件</h1><ul>\n<li>gedit编辑器：　最大化窗口-&gt;Edit-&gt;Preferences-&gt;Editor-&gt;file saving-&gt;取消’Creat a backup copy of files before saving’选项，中文系统同理。</li>\n<li>Vi/Vim编辑器:<br>  vi ~/.vimrc<br>  set nobackup<br>通过以上方法可以实现删除或者取消自动备份文件功能，相反可以开启自动备份功能。</li>\n</ul>\n"},{"title":"VS2010+OpenCV2.4.10的安装与配置","date":"2016-09-24T22:56:32.000Z","_content":"由于本人最近要做图像处理的一些工作，因此将相应的流程记录备份，方便自己，也为他人提供一个思路吧。<br/>\n平台操作系统： Win7 32位 旗舰版<br/>\n## 1、VS2010的安装\n直接点击 AutoRun.exe或者Setup.exe按照提示一步步安装即可。需要选择安装那些模块，按自己的开发需要选择，如果实在不懂，全部安装。<br/>\n## 2、OpenCV的安装\n我用的是OpenCV2.4.10，安装非常简单。只要选择安装位置就可以自动完成，如图1。需要记住该安装地址（本文假设安装在D盘根目录下 D:\\）。\n![图1](http://oapeb119y.bkt.clouddn.com/1.png)\n![图2](http://oapeb119y.bkt.clouddn.com/2.png)\n## 3、OpenCV的配置\n<!--more-->\n### 3.1、系统环境变量的配置\nOpenCV其实就是开源视觉库，要让开发环境找到并使用这个库，需要将OpenCV的路径添加到系统的PATH环境变量。具体方法：<b>我的电脑——>属性——>高级——>环境变量——PATH变量<b><br/>\n编辑PATH环境变量，在最后加入 Opencv的路径(本文假设安装在D:\\下面，需要根据自己安装路径更改)\n```\n;D:\\opencv\\build\\x86\\vc10\\bin\n```\n<b>不要遗忘分号 ；<b/>\n## 3.2、VS2010工程的相关配置\n工程要使用OpenCV库，就需要在工程中把库的相关路径包含进去。\n有两种方法，一种是在某个工程下包含相应路径，但是这样每建一个目录就需要重新包含一次，非常繁琐。<b>本文采用第二种方法,包含一次，以后建立工程就不用反复添加<b/>：\n* 新建项目：<b>文件-->新建-->项目-->选择Win32控制台程序-->确定<b/>（本文项目名叫做test，后文要用）\n![图3](http://oapeb119y.bkt.clouddn.com/3.png)\n![图4](http://oapeb119y.bkt.clouddn.com/4.png)\n* 包含目录和库目录配置: 在新建的工程页面 <b>菜单栏-->视图-->属性管理器-->Debug|Microsoft.cpp.win32.user(右键属性)，弹出属性页-->VC++目录<b/>，分别修改包含目录和库目录。\n![图5](http://oapeb119y.bkt.clouddn.com/5.png)\n![图6](http://oapeb119y.bkt.clouddn.com/6.png)\n![图7](http://oapeb119y.bkt.clouddn.com/7.png)\n![图8](http://oapeb119y.bkt.clouddn.com/8.png)\n* 包含目录配置<>\n添加\n```\nD:\\opencv\\build\\include\nD:\\opencv\\build\\include\\opencv\nD:\\opencv\\build\\include\\opencv2 \n```\n这三个路径，如图九所示。\n注意，根据自己不同的路径修改。\n![图9](http://oapeb119y.bkt.clouddn.com/9.png)\n* <b>库目录配置\n添加\n```\nD:\\opencv\\build\\x86\\vc10\\lib\n```\n这个路径。\n* 链接器配置\n在<b>属性页-->链接器-->输入-->附加依赖项<b>添加\n```\nopencv_calib3d2410.lib\nopencv_contrib2410.lib\nopencv_core2410.lib\nopencv_features2d2410.lib\nopencv_flann2410.lib\nopencv_gpu2410.lib\nopencv_highgui2410.lib\nopencv_imgproc2410.lib\nopencv_legacy2410.lib\nopencv_ml2410.lib\nopencv_nonfree2410.lib\nopencv_objdetect2410.lib\nopencv_ocl2410.lib\nopencv_photo2410.lib\nopencv_stitching2410.lib\nopencv_superres2410.lib\nopencv_ts2410.lib\nopencv_video2410.lib\nopencv_videostab2410.lib\nopencv_calib3d2410d.lib\nopencv_contrib2410d.lib\nopencv_core2410d.lib\nopencv_features2d2410d.lib\nopencv_flann2410d.lib\nopencv_gpu2410d.lib\nopencv_highgui2410d.lib\nopencv_imgproc2410d.lib\nopencv_legacy2410d.lib\nopencv_ml2410d.lib\nopencv_nonfree2410d.lib\nopencv_objdetect2410d.lib\nopencv_ocl2410d.lib\nopencv_photo2410d.lib\nopencv_stitching2410d.lib\nopencv_superres2410d.lib\nopencv_ts2410d.lib\nopencv_video2410d.lib\nopencv_videostab2410d.lib\n```\n即可。至此所有配置都完成。\n![图10](http://oapeb119y.bkt.clouddn.com/10.png)\n## 测试安装和配置是否成功\n在之前创建test项目，打开test.cpp,编写如下测试程序：\n\n```\n/***********************************************************************\n* OpenCV 2.4.10 测试例程\n* 梁泽浪提供\n***********************************************************************/\n#include\"stdafx.h\"\n#include <opencv2/opencv.hpp>\nusing namespace std;\n\nusing namespace cv;\n\nint main(int argc, char*argv[])\n{\n\tIplImage* pImg;  \n\n    if ((pImg = cvLoadImage(\"C:\\\\Users\\\\liangzelang\\\\Desktop\\\\lena.jpg\", 1)) != 0)  \n    {  \n        cvNamedWindow (\"Image\", 1);  \n        cvMoveWindow (\"Image\", 0, 0);  \n        cvShowImage (\"Image\", pImg);  \n        cvWaitKey (0);  \n        cvDestroyWindow (\"Image\");  \n        cvReleaseImage (&pImg);  \n    }\n}\n```\n需要注意的是cvLoadImage(\"C:\\\\Users\\\\liangzelang\\\\Desktop\\\\lena.jpg\",1)中的图片地址的写法。<br/>\n![图11](http://oapeb119y.bkt.clouddn.com/11.png)\n![图12](http://oapeb119y.bkt.clouddn.com/12.png)\n最后,一切OK。尽情享受OpenCV吧。\n","source":"_posts/OpenCV/VS2010+OpenCV2.4.10的安装与配置.md","raw":"---\ntitle: VS2010+OpenCV2.4.10的安装与配置\ndate: 2016-09-25 06:56:32\ntag: \n - OpenCV基础\n - VS2010\ncategories: \n - 技术 \n---\n由于本人最近要做图像处理的一些工作，因此将相应的流程记录备份，方便自己，也为他人提供一个思路吧。<br/>\n平台操作系统： Win7 32位 旗舰版<br/>\n## 1、VS2010的安装\n直接点击 AutoRun.exe或者Setup.exe按照提示一步步安装即可。需要选择安装那些模块，按自己的开发需要选择，如果实在不懂，全部安装。<br/>\n## 2、OpenCV的安装\n我用的是OpenCV2.4.10，安装非常简单。只要选择安装位置就可以自动完成，如图1。需要记住该安装地址（本文假设安装在D盘根目录下 D:\\）。\n![图1](http://oapeb119y.bkt.clouddn.com/1.png)\n![图2](http://oapeb119y.bkt.clouddn.com/2.png)\n## 3、OpenCV的配置\n<!--more-->\n### 3.1、系统环境变量的配置\nOpenCV其实就是开源视觉库，要让开发环境找到并使用这个库，需要将OpenCV的路径添加到系统的PATH环境变量。具体方法：<b>我的电脑——>属性——>高级——>环境变量——PATH变量<b><br/>\n编辑PATH环境变量，在最后加入 Opencv的路径(本文假设安装在D:\\下面，需要根据自己安装路径更改)\n```\n;D:\\opencv\\build\\x86\\vc10\\bin\n```\n<b>不要遗忘分号 ；<b/>\n## 3.2、VS2010工程的相关配置\n工程要使用OpenCV库，就需要在工程中把库的相关路径包含进去。\n有两种方法，一种是在某个工程下包含相应路径，但是这样每建一个目录就需要重新包含一次，非常繁琐。<b>本文采用第二种方法,包含一次，以后建立工程就不用反复添加<b/>：\n* 新建项目：<b>文件-->新建-->项目-->选择Win32控制台程序-->确定<b/>（本文项目名叫做test，后文要用）\n![图3](http://oapeb119y.bkt.clouddn.com/3.png)\n![图4](http://oapeb119y.bkt.clouddn.com/4.png)\n* 包含目录和库目录配置: 在新建的工程页面 <b>菜单栏-->视图-->属性管理器-->Debug|Microsoft.cpp.win32.user(右键属性)，弹出属性页-->VC++目录<b/>，分别修改包含目录和库目录。\n![图5](http://oapeb119y.bkt.clouddn.com/5.png)\n![图6](http://oapeb119y.bkt.clouddn.com/6.png)\n![图7](http://oapeb119y.bkt.clouddn.com/7.png)\n![图8](http://oapeb119y.bkt.clouddn.com/8.png)\n* 包含目录配置<>\n添加\n```\nD:\\opencv\\build\\include\nD:\\opencv\\build\\include\\opencv\nD:\\opencv\\build\\include\\opencv2 \n```\n这三个路径，如图九所示。\n注意，根据自己不同的路径修改。\n![图9](http://oapeb119y.bkt.clouddn.com/9.png)\n* <b>库目录配置\n添加\n```\nD:\\opencv\\build\\x86\\vc10\\lib\n```\n这个路径。\n* 链接器配置\n在<b>属性页-->链接器-->输入-->附加依赖项<b>添加\n```\nopencv_calib3d2410.lib\nopencv_contrib2410.lib\nopencv_core2410.lib\nopencv_features2d2410.lib\nopencv_flann2410.lib\nopencv_gpu2410.lib\nopencv_highgui2410.lib\nopencv_imgproc2410.lib\nopencv_legacy2410.lib\nopencv_ml2410.lib\nopencv_nonfree2410.lib\nopencv_objdetect2410.lib\nopencv_ocl2410.lib\nopencv_photo2410.lib\nopencv_stitching2410.lib\nopencv_superres2410.lib\nopencv_ts2410.lib\nopencv_video2410.lib\nopencv_videostab2410.lib\nopencv_calib3d2410d.lib\nopencv_contrib2410d.lib\nopencv_core2410d.lib\nopencv_features2d2410d.lib\nopencv_flann2410d.lib\nopencv_gpu2410d.lib\nopencv_highgui2410d.lib\nopencv_imgproc2410d.lib\nopencv_legacy2410d.lib\nopencv_ml2410d.lib\nopencv_nonfree2410d.lib\nopencv_objdetect2410d.lib\nopencv_ocl2410d.lib\nopencv_photo2410d.lib\nopencv_stitching2410d.lib\nopencv_superres2410d.lib\nopencv_ts2410d.lib\nopencv_video2410d.lib\nopencv_videostab2410d.lib\n```\n即可。至此所有配置都完成。\n![图10](http://oapeb119y.bkt.clouddn.com/10.png)\n## 测试安装和配置是否成功\n在之前创建test项目，打开test.cpp,编写如下测试程序：\n\n```\n/***********************************************************************\n* OpenCV 2.4.10 测试例程\n* 梁泽浪提供\n***********************************************************************/\n#include\"stdafx.h\"\n#include <opencv2/opencv.hpp>\nusing namespace std;\n\nusing namespace cv;\n\nint main(int argc, char*argv[])\n{\n\tIplImage* pImg;  \n\n    if ((pImg = cvLoadImage(\"C:\\\\Users\\\\liangzelang\\\\Desktop\\\\lena.jpg\", 1)) != 0)  \n    {  \n        cvNamedWindow (\"Image\", 1);  \n        cvMoveWindow (\"Image\", 0, 0);  \n        cvShowImage (\"Image\", pImg);  \n        cvWaitKey (0);  \n        cvDestroyWindow (\"Image\");  \n        cvReleaseImage (&pImg);  \n    }\n}\n```\n需要注意的是cvLoadImage(\"C:\\\\Users\\\\liangzelang\\\\Desktop\\\\lena.jpg\",1)中的图片地址的写法。<br/>\n![图11](http://oapeb119y.bkt.clouddn.com/11.png)\n![图12](http://oapeb119y.bkt.clouddn.com/12.png)\n最后,一切OK。尽情享受OpenCV吧。\n","slug":"OpenCV/VS2010+OpenCV2.4.10的安装与配置","published":1,"updated":"2017-05-29T15:22:55.885Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj3aal9ur001r094uxkdi77n4","content":"<p>由于本人最近要做图像处理的一些工作，因此将相应的流程记录备份，方便自己，也为他人提供一个思路吧。<br><br>平台操作系统： Win7 32位 旗舰版<br></p>\n<h2 id=\"1、VS2010的安装\"><a href=\"#1、VS2010的安装\" class=\"headerlink\" title=\"1、VS2010的安装\"></a>1、VS2010的安装</h2><p>直接点击 AutoRun.exe或者Setup.exe按照提示一步步安装即可。需要选择安装那些模块，按自己的开发需要选择，如果实在不懂，全部安装。<br></p>\n<h2 id=\"2、OpenCV的安装\"><a href=\"#2、OpenCV的安装\" class=\"headerlink\" title=\"2、OpenCV的安装\"></a>2、OpenCV的安装</h2><p>我用的是OpenCV2.4.10，安装非常简单。只要选择安装位置就可以自动完成，如图1。需要记住该安装地址（本文假设安装在D盘根目录下 D:\\）。<br><img src=\"http://oapeb119y.bkt.clouddn.com/1.png\" alt=\"图1\"><br><img src=\"http://oapeb119y.bkt.clouddn.com/2.png\" alt=\"图2\"></p>\n<h2 id=\"3、OpenCV的配置\"><a href=\"#3、OpenCV的配置\" class=\"headerlink\" title=\"3、OpenCV的配置\"></a>3、OpenCV的配置</h2><a id=\"more\"></a>\n<h3 id=\"3-1、系统环境变量的配置\"><a href=\"#3-1、系统环境变量的配置\" class=\"headerlink\" title=\"3.1、系统环境变量的配置\"></a>3.1、系统环境变量的配置</h3><p>OpenCV其实就是开源视觉库，要让开发环境找到并使用这个库，需要将OpenCV的路径添加到系统的PATH环境变量。具体方法：<b>我的电脑——&gt;属性——&gt;高级——&gt;环境变量——PATH变量<b><br><br>编辑PATH环境变量，在最后加入 Opencv的路径(本文假设安装在D:\\下面，需要根据自己安装路径更改)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">;D:\\opencv\\build\\x86\\vc10\\bin</div></pre></td></tr></table></figure></b></b></p>\n<p><b>不要遗忘分号 ；<b></b></b></p>\n<h2 id=\"3-2、VS2010工程的相关配置\"><a href=\"#3-2、VS2010工程的相关配置\" class=\"headerlink\" title=\"3.2、VS2010工程的相关配置\"></a>3.2、VS2010工程的相关配置</h2><p>工程要使用OpenCV库，就需要在工程中把库的相关路径包含进去。<br>有两种方法，一种是在某个工程下包含相应路径，但是这样每建一个目录就需要重新包含一次，非常繁琐。<b>本文采用第二种方法,包含一次，以后建立工程就不用反复添加<b>：</b></b></p>\n<ul>\n<li>新建项目：<b>文件–&gt;新建–&gt;项目–&gt;选择Win32控制台程序–&gt;确定<b>（本文项目名叫做test，后文要用）<br><img src=\"http://oapeb119y.bkt.clouddn.com/3.png\" alt=\"图3\"><br><img src=\"http://oapeb119y.bkt.clouddn.com/4.png\" alt=\"图4\"></b></b></li>\n<li>包含目录和库目录配置: 在新建的工程页面 <b>菜单栏–&gt;视图–&gt;属性管理器–&gt;Debug|Microsoft.cpp.win32.user(右键属性)，弹出属性页–&gt;VC++目录<b>，分别修改包含目录和库目录。<br><img src=\"http://oapeb119y.bkt.clouddn.com/5.png\" alt=\"图5\"><br><img src=\"http://oapeb119y.bkt.clouddn.com/6.png\" alt=\"图6\"><br><img src=\"http://oapeb119y.bkt.clouddn.com/7.png\" alt=\"图7\"><br><img src=\"http://oapeb119y.bkt.clouddn.com/8.png\" alt=\"图8\"></b></b></li>\n<li>包含目录配置&lt;&gt;<br>添加<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">D:\\opencv\\build\\include</div><div class=\"line\">D:\\opencv\\build\\include\\opencv</div><div class=\"line\">D:\\opencv\\build\\include\\opencv2</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这三个路径，如图九所示。<br>注意，根据自己不同的路径修改。<br><img src=\"http://oapeb119y.bkt.clouddn.com/9.png\" alt=\"图9\"></p>\n<ul>\n<li><b>库目录配置<br>添加<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">D:\\opencv\\build\\x86\\vc10\\lib</div></pre></td></tr></table></figure>\n</b></li>\n</ul>\n<p>这个路径。</p>\n<ul>\n<li>链接器配置<br>在<b>属性页–&gt;链接器–&gt;输入–&gt;附加依赖项<b>添加<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">opencv_calib3d2410.lib</div><div class=\"line\">opencv_contrib2410.lib</div><div class=\"line\">opencv_core2410.lib</div><div class=\"line\">opencv_features2d2410.lib</div><div class=\"line\">opencv_flann2410.lib</div><div class=\"line\">opencv_gpu2410.lib</div><div class=\"line\">opencv_highgui2410.lib</div><div class=\"line\">opencv_imgproc2410.lib</div><div class=\"line\">opencv_legacy2410.lib</div><div class=\"line\">opencv_ml2410.lib</div><div class=\"line\">opencv_nonfree2410.lib</div><div class=\"line\">opencv_objdetect2410.lib</div><div class=\"line\">opencv_ocl2410.lib</div><div class=\"line\">opencv_photo2410.lib</div><div class=\"line\">opencv_stitching2410.lib</div><div class=\"line\">opencv_superres2410.lib</div><div class=\"line\">opencv_ts2410.lib</div><div class=\"line\">opencv_video2410.lib</div><div class=\"line\">opencv_videostab2410.lib</div><div class=\"line\">opencv_calib3d2410d.lib</div><div class=\"line\">opencv_contrib2410d.lib</div><div class=\"line\">opencv_core2410d.lib</div><div class=\"line\">opencv_features2d2410d.lib</div><div class=\"line\">opencv_flann2410d.lib</div><div class=\"line\">opencv_gpu2410d.lib</div><div class=\"line\">opencv_highgui2410d.lib</div><div class=\"line\">opencv_imgproc2410d.lib</div><div class=\"line\">opencv_legacy2410d.lib</div><div class=\"line\">opencv_ml2410d.lib</div><div class=\"line\">opencv_nonfree2410d.lib</div><div class=\"line\">opencv_objdetect2410d.lib</div><div class=\"line\">opencv_ocl2410d.lib</div><div class=\"line\">opencv_photo2410d.lib</div><div class=\"line\">opencv_stitching2410d.lib</div><div class=\"line\">opencv_superres2410d.lib</div><div class=\"line\">opencv_ts2410d.lib</div><div class=\"line\">opencv_video2410d.lib</div><div class=\"line\">opencv_videostab2410d.lib</div></pre></td></tr></table></figure>\n</b></b></li>\n</ul>\n<p>即可。至此所有配置都完成。<br><img src=\"http://oapeb119y.bkt.clouddn.com/10.png\" alt=\"图10\"></p>\n<h2 id=\"测试安装和配置是否成功\"><a href=\"#测试安装和配置是否成功\" class=\"headerlink\" title=\"测试安装和配置是否成功\"></a>测试安装和配置是否成功</h2><p>在之前创建test项目，打开test.cpp,编写如下测试程序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">/***********************************************************************</div><div class=\"line\">* OpenCV 2.4.10 测试例程</div><div class=\"line\">* 梁泽浪提供</div><div class=\"line\">***********************************************************************/</div><div class=\"line\">#include&quot;stdafx.h&quot;</div><div class=\"line\">#include &lt;opencv2/opencv.hpp&gt;</div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">using namespace cv;</div><div class=\"line\"></div><div class=\"line\">int main(int argc, char*argv[])</div><div class=\"line\">&#123;</div><div class=\"line\">\tIplImage* pImg;  </div><div class=\"line\"></div><div class=\"line\">    if ((pImg = cvLoadImage(&quot;C:\\\\Users\\\\liangzelang\\\\Desktop\\\\lena.jpg&quot;, 1)) != 0)  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        cvNamedWindow (&quot;Image&quot;, 1);  </div><div class=\"line\">        cvMoveWindow (&quot;Image&quot;, 0, 0);  </div><div class=\"line\">        cvShowImage (&quot;Image&quot;, pImg);  </div><div class=\"line\">        cvWaitKey (0);  </div><div class=\"line\">        cvDestroyWindow (&quot;Image&quot;);  </div><div class=\"line\">        cvReleaseImage (&amp;pImg);  </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>需要注意的是cvLoadImage(“C:\\Users\\liangzelang\\Desktop\\lena.jpg”,1)中的图片地址的写法。<br><br><img src=\"http://oapeb119y.bkt.clouddn.com/11.png\" alt=\"图11\"><br><img src=\"http://oapeb119y.bkt.clouddn.com/12.png\" alt=\"图12\"><br>最后,一切OK。尽情享受OpenCV吧。</p>\n","excerpt":"<p>由于本人最近要做图像处理的一些工作，因此将相应的流程记录备份，方便自己，也为他人提供一个思路吧。<br/><br>平台操作系统： Win7 32位 旗舰版<br/></p>\n<h2 id=\"1、VS2010的安装\"><a href=\"#1、VS2010的安装\" class=\"headerlink\" title=\"1、VS2010的安装\"></a>1、VS2010的安装</h2><p>直接点击 AutoRun.exe或者Setup.exe按照提示一步步安装即可。需要选择安装那些模块，按自己的开发需要选择，如果实在不懂，全部安装。<br/></p>\n<h2 id=\"2、OpenCV的安装\"><a href=\"#2、OpenCV的安装\" class=\"headerlink\" title=\"2、OpenCV的安装\"></a>2、OpenCV的安装</h2><p>我用的是OpenCV2.4.10，安装非常简单。只要选择安装位置就可以自动完成，如图1。需要记住该安装地址（本文假设安装在D盘根目录下 D:\\）。<br><img src=\"http://oapeb119y.bkt.clouddn.com/1.png\" alt=\"图1\"><br><img src=\"http://oapeb119y.bkt.clouddn.com/2.png\" alt=\"图2\"></p>\n<h2 id=\"3、OpenCV的配置\"><a href=\"#3、OpenCV的配置\" class=\"headerlink\" title=\"3、OpenCV的配置\"></a>3、OpenCV的配置</h2>","more":"<h3 id=\"3-1、系统环境变量的配置\"><a href=\"#3-1、系统环境变量的配置\" class=\"headerlink\" title=\"3.1、系统环境变量的配置\"></a>3.1、系统环境变量的配置</h3><p>OpenCV其实就是开源视觉库，要让开发环境找到并使用这个库，需要将OpenCV的路径添加到系统的PATH环境变量。具体方法：<b>我的电脑——&gt;属性——&gt;高级——&gt;环境变量——PATH变量<b><br/><br>编辑PATH环境变量，在最后加入 Opencv的路径(本文假设安装在D:\\下面，需要根据自己安装路径更改)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">;D:\\opencv\\build\\x86\\vc10\\bin</div></pre></td></tr></table></figure></p>\n<p><b>不要遗忘分号 ；<b/></p>\n<h2 id=\"3-2、VS2010工程的相关配置\"><a href=\"#3-2、VS2010工程的相关配置\" class=\"headerlink\" title=\"3.2、VS2010工程的相关配置\"></a>3.2、VS2010工程的相关配置</h2><p>工程要使用OpenCV库，就需要在工程中把库的相关路径包含进去。<br>有两种方法，一种是在某个工程下包含相应路径，但是这样每建一个目录就需要重新包含一次，非常繁琐。<b>本文采用第二种方法,包含一次，以后建立工程就不用反复添加<b/>：</p>\n<ul>\n<li>新建项目：<b>文件–&gt;新建–&gt;项目–&gt;选择Win32控制台程序–&gt;确定<b/>（本文项目名叫做test，后文要用）<br><img src=\"http://oapeb119y.bkt.clouddn.com/3.png\" alt=\"图3\"><br><img src=\"http://oapeb119y.bkt.clouddn.com/4.png\" alt=\"图4\"></li>\n<li>包含目录和库目录配置: 在新建的工程页面 <b>菜单栏–&gt;视图–&gt;属性管理器–&gt;Debug|Microsoft.cpp.win32.user(右键属性)，弹出属性页–&gt;VC++目录<b/>，分别修改包含目录和库目录。<br><img src=\"http://oapeb119y.bkt.clouddn.com/5.png\" alt=\"图5\"><br><img src=\"http://oapeb119y.bkt.clouddn.com/6.png\" alt=\"图6\"><br><img src=\"http://oapeb119y.bkt.clouddn.com/7.png\" alt=\"图7\"><br><img src=\"http://oapeb119y.bkt.clouddn.com/8.png\" alt=\"图8\"></li>\n<li>包含目录配置&lt;&gt;<br>添加<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">D:\\opencv\\build\\include</div><div class=\"line\">D:\\opencv\\build\\include\\opencv</div><div class=\"line\">D:\\opencv\\build\\include\\opencv2</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这三个路径，如图九所示。<br>注意，根据自己不同的路径修改。<br><img src=\"http://oapeb119y.bkt.clouddn.com/9.png\" alt=\"图9\"></p>\n<ul>\n<li><b>库目录配置<br>添加<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">D:\\opencv\\build\\x86\\vc10\\lib</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这个路径。</p>\n<ul>\n<li>链接器配置<br>在<b>属性页–&gt;链接器–&gt;输入–&gt;附加依赖项<b>添加<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">opencv_calib3d2410.lib</div><div class=\"line\">opencv_contrib2410.lib</div><div class=\"line\">opencv_core2410.lib</div><div class=\"line\">opencv_features2d2410.lib</div><div class=\"line\">opencv_flann2410.lib</div><div class=\"line\">opencv_gpu2410.lib</div><div class=\"line\">opencv_highgui2410.lib</div><div class=\"line\">opencv_imgproc2410.lib</div><div class=\"line\">opencv_legacy2410.lib</div><div class=\"line\">opencv_ml2410.lib</div><div class=\"line\">opencv_nonfree2410.lib</div><div class=\"line\">opencv_objdetect2410.lib</div><div class=\"line\">opencv_ocl2410.lib</div><div class=\"line\">opencv_photo2410.lib</div><div class=\"line\">opencv_stitching2410.lib</div><div class=\"line\">opencv_superres2410.lib</div><div class=\"line\">opencv_ts2410.lib</div><div class=\"line\">opencv_video2410.lib</div><div class=\"line\">opencv_videostab2410.lib</div><div class=\"line\">opencv_calib3d2410d.lib</div><div class=\"line\">opencv_contrib2410d.lib</div><div class=\"line\">opencv_core2410d.lib</div><div class=\"line\">opencv_features2d2410d.lib</div><div class=\"line\">opencv_flann2410d.lib</div><div class=\"line\">opencv_gpu2410d.lib</div><div class=\"line\">opencv_highgui2410d.lib</div><div class=\"line\">opencv_imgproc2410d.lib</div><div class=\"line\">opencv_legacy2410d.lib</div><div class=\"line\">opencv_ml2410d.lib</div><div class=\"line\">opencv_nonfree2410d.lib</div><div class=\"line\">opencv_objdetect2410d.lib</div><div class=\"line\">opencv_ocl2410d.lib</div><div class=\"line\">opencv_photo2410d.lib</div><div class=\"line\">opencv_stitching2410d.lib</div><div class=\"line\">opencv_superres2410d.lib</div><div class=\"line\">opencv_ts2410d.lib</div><div class=\"line\">opencv_video2410d.lib</div><div class=\"line\">opencv_videostab2410d.lib</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>即可。至此所有配置都完成。<br><img src=\"http://oapeb119y.bkt.clouddn.com/10.png\" alt=\"图10\"></p>\n<h2 id=\"测试安装和配置是否成功\"><a href=\"#测试安装和配置是否成功\" class=\"headerlink\" title=\"测试安装和配置是否成功\"></a>测试安装和配置是否成功</h2><p>在之前创建test项目，打开test.cpp,编写如下测试程序：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">/***********************************************************************</div><div class=\"line\">* OpenCV 2.4.10 测试例程</div><div class=\"line\">* 梁泽浪提供</div><div class=\"line\">***********************************************************************/</div><div class=\"line\">#include&quot;stdafx.h&quot;</div><div class=\"line\">#include &lt;opencv2/opencv.hpp&gt;</div><div class=\"line\">using namespace std;</div><div class=\"line\"></div><div class=\"line\">using namespace cv;</div><div class=\"line\"></div><div class=\"line\">int main(int argc, char*argv[])</div><div class=\"line\">&#123;</div><div class=\"line\">\tIplImage* pImg;  </div><div class=\"line\"></div><div class=\"line\">    if ((pImg = cvLoadImage(&quot;C:\\\\Users\\\\liangzelang\\\\Desktop\\\\lena.jpg&quot;, 1)) != 0)  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        cvNamedWindow (&quot;Image&quot;, 1);  </div><div class=\"line\">        cvMoveWindow (&quot;Image&quot;, 0, 0);  </div><div class=\"line\">        cvShowImage (&quot;Image&quot;, pImg);  </div><div class=\"line\">        cvWaitKey (0);  </div><div class=\"line\">        cvDestroyWindow (&quot;Image&quot;);  </div><div class=\"line\">        cvReleaseImage (&amp;pImg);  </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>需要注意的是cvLoadImage(“C:\\Users\\liangzelang\\Desktop\\lena.jpg”,1)中的图片地址的写法。<br/><br><img src=\"http://oapeb119y.bkt.clouddn.com/11.png\" alt=\"图11\"><br><img src=\"http://oapeb119y.bkt.clouddn.com/12.png\" alt=\"图12\"><br>最后,一切OK。尽情享受OpenCV吧。</p>"},{"title":"core组件进阶","date":"2017-03-28T14:54:25.000Z","comments":1,"_content":"+ LUT函数： LOOK UP TABLE 操作\n用于批量元素查找、扫描和操作图像。\n```\n//首先我们建立一个mat型用于查表\nMat lookUpTable(1, 256, CV_8U);\nuchar* p = lookUpTable.data;\nfor( int i = 0; i < 256; ++ i)\n{\n\tp[i] = table[i];\n}\n//然后我们调用函数(I 是输入， J 是输出)：\nfor(int i = 0; i < times; ++ i)\n\tLUT(I, lookUpTable, J);\n```\n\n+ 计时函数\n'getTickCount()'函数： 返回CPU自某个时间以来走过的时钟周期；\n'getTickFrequency()'函数： 返回CPU一秒钟的时钟周期；\n故使用以上两个函数可以得到某段程度的运行时间：\n```\ndouble time1 = static_cast<double>(getTickCount()); //记录起始时间\n// 你的程序...\ntime1 = ((double)getTickCount() - time1) / getTickFrequency();\ncout << \"程序运行时间 : \" << time1 << endl;\n```\n\n+ 访问图中像素的方法\n图像处理最基本的就是处理每个点的像素啦，所以呢，如何访问每个像素点呢。\n1. 指针访问： C操作符[]\n如果是一幅 640 *320 的图像，就把他看成是一个二维数组 pic[640][320]。两个嵌套的for循环，即可完成图像像素点的遍历。\n  \n","source":"_posts/OpenCV/core组件进阶.md","raw":"---\ntitle: core组件进阶\ndate: 2017-03-28 22:54:25\ncategories:\n- 技术\ntags:\n- OpenCV基础\n- c++\ncomments: true\n---\n+ LUT函数： LOOK UP TABLE 操作\n用于批量元素查找、扫描和操作图像。\n```\n//首先我们建立一个mat型用于查表\nMat lookUpTable(1, 256, CV_8U);\nuchar* p = lookUpTable.data;\nfor( int i = 0; i < 256; ++ i)\n{\n\tp[i] = table[i];\n}\n//然后我们调用函数(I 是输入， J 是输出)：\nfor(int i = 0; i < times; ++ i)\n\tLUT(I, lookUpTable, J);\n```\n\n+ 计时函数\n'getTickCount()'函数： 返回CPU自某个时间以来走过的时钟周期；\n'getTickFrequency()'函数： 返回CPU一秒钟的时钟周期；\n故使用以上两个函数可以得到某段程度的运行时间：\n```\ndouble time1 = static_cast<double>(getTickCount()); //记录起始时间\n// 你的程序...\ntime1 = ((double)getTickCount() - time1) / getTickFrequency();\ncout << \"程序运行时间 : \" << time1 << endl;\n```\n\n+ 访问图中像素的方法\n图像处理最基本的就是处理每个点的像素啦，所以呢，如何访问每个像素点呢。\n1. 指针访问： C操作符[]\n如果是一幅 640 *320 的图像，就把他看成是一个二维数组 pic[640][320]。两个嵌套的for循环，即可完成图像像素点的遍历。\n  \n","slug":"OpenCV/core组件进阶","published":1,"updated":"2017-05-29T15:22:55.885Z","layout":"post","photos":[],"link":"","_id":"cj3aal9uy001u094uphiygzgi","content":"<ul>\n<li><p>LUT函数： LOOK UP TABLE 操作<br>用于批量元素查找、扫描和操作图像。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">//首先我们建立一个mat型用于查表</div><div class=\"line\">Mat lookUpTable(1, 256, CV_8U);</div><div class=\"line\">uchar* p = lookUpTable.data;</div><div class=\"line\">for( int i = 0; i &lt; 256; ++ i)</div><div class=\"line\">&#123;</div><div class=\"line\">\tp[i] = table[i];</div><div class=\"line\">&#125;</div><div class=\"line\">//然后我们调用函数(I 是输入， J 是输出)：</div><div class=\"line\">for(int i = 0; i &lt; times; ++ i)</div><div class=\"line\">\tLUT(I, lookUpTable, J);</div></pre></td></tr></table></figure>\n</li>\n<li><p>计时函数<br>‘getTickCount()’函数： 返回CPU自某个时间以来走过的时钟周期；<br>‘getTickFrequency()’函数： 返回CPU一秒钟的时钟周期；<br>故使用以上两个函数可以得到某段程度的运行时间：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">double time1 = static_cast&lt;double&gt;(getTickCount()); //记录起始时间</div><div class=\"line\">// 你的程序...</div><div class=\"line\">time1 = ((double)getTickCount() - time1) / getTickFrequency();</div><div class=\"line\">cout &lt;&lt; &quot;程序运行时间 : &quot; &lt;&lt; time1 &lt;&lt; endl;</div></pre></td></tr></table></figure>\n</li>\n<li><p>访问图中像素的方法<br>图像处理最基本的就是处理每个点的像素啦，所以呢，如何访问每个像素点呢。</p>\n</li>\n</ul>\n<ol>\n<li>指针访问： C操作符[]<br>如果是一幅 640 *320 的图像，就把他看成是一个二维数组 pic[640][320]。两个嵌套的for循环，即可完成图像像素点的遍历。</li>\n</ol>\n","excerpt":"","more":"<ul>\n<li><p>LUT函数： LOOK UP TABLE 操作<br>用于批量元素查找、扫描和操作图像。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">//首先我们建立一个mat型用于查表</div><div class=\"line\">Mat lookUpTable(1, 256, CV_8U);</div><div class=\"line\">uchar* p = lookUpTable.data;</div><div class=\"line\">for( int i = 0; i &lt; 256; ++ i)</div><div class=\"line\">&#123;</div><div class=\"line\">\tp[i] = table[i];</div><div class=\"line\">&#125;</div><div class=\"line\">//然后我们调用函数(I 是输入， J 是输出)：</div><div class=\"line\">for(int i = 0; i &lt; times; ++ i)</div><div class=\"line\">\tLUT(I, lookUpTable, J);</div></pre></td></tr></table></figure>\n</li>\n<li><p>计时函数<br>‘getTickCount()’函数： 返回CPU自某个时间以来走过的时钟周期；<br>‘getTickFrequency()’函数： 返回CPU一秒钟的时钟周期；<br>故使用以上两个函数可以得到某段程度的运行时间：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">double time1 = static_cast&lt;double&gt;(getTickCount()); //记录起始时间</div><div class=\"line\">// 你的程序...</div><div class=\"line\">time1 = ((double)getTickCount() - time1) / getTickFrequency();</div><div class=\"line\">cout &lt;&lt; &quot;程序运行时间 : &quot; &lt;&lt; time1 &lt;&lt; endl;</div></pre></td></tr></table></figure>\n</li>\n<li><p>访问图中像素的方法<br>图像处理最基本的就是处理每个点的像素啦，所以呢，如何访问每个像素点呢。</p>\n</li>\n</ul>\n<ol>\n<li>指针访问： C操作符[]<br>如果是一幅 640 *320 的图像，就把他看成是一个二维数组 pic[640][320]。两个嵌套的for循环，即可完成图像像素点的遍历。</li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cj3aal9on0000094udaohbdch","category_id":"cj3aal9pb0003094uts32741o","_id":"cj3aal9pj0005094ux701rve9"},{"post_id":"cj3aal9rc0006094ux3d2tgiu","category_id":"cj3aal9pb0003094uts32741o","_id":"cj3aal9rv000b094u9rcycyr1"},{"post_id":"cj3aal9rk0007094uut3owuto","category_id":"cj3aal9pb0003094uts32741o","_id":"cj3aal9rz000e094ut8ptdptc"},{"post_id":"cj3aal9rn0009094uhfbokcx3","category_id":"cj3aal9pb0003094uts32741o","_id":"cj3aal9s9000h094u3b78i2px"},{"post_id":"cj3aal9rw000c094uowcblaib","category_id":"cj3aal9pb0003094uts32741o","_id":"cj3aal9sn000k094u3do9ej19"},{"post_id":"cj3aal9rz000f094ujh7elgph","category_id":"cj3aal9pb0003094uts32741o","_id":"cj3aal9sq000n094upz2ho676"},{"post_id":"cj3aal9sa000i094ux5th9exl","category_id":"cj3aal9pb0003094uts32741o","_id":"cj3aal9sv000q094uja0ouarb"},{"post_id":"cj3aal9sn000l094ur1qvzisy","category_id":"cj3aal9pb0003094uts32741o","_id":"cj3aal9t0000t094uqnctpbqm"},{"post_id":"cj3aal9sr000o094u8h5710u5","category_id":"cj3aal9pb0003094uts32741o","_id":"cj3aal9t4000w094urhc1teva"},{"post_id":"cj3aal9sw000r094uhap299s2","category_id":"cj3aal9pb0003094uts32741o","_id":"cj3aal9ta000z094u58p81cym"},{"post_id":"cj3aal9t1000u094uvf9x8xjp","category_id":"cj3aal9pb0003094uts32741o","_id":"cj3aal9te0011094uow7b9m2x"},{"post_id":"cj3aal9t5000x094uwz4w6g0h","category_id":"cj3aal9pb0003094uts32741o","_id":"cj3aal9th0014094udts50wsr"},{"post_id":"cj3aal9tb0010094u0atehkwf","category_id":"cj3aal9pb0003094uts32741o","_id":"cj3aal9to0016094u0fvniaqq"},{"post_id":"cj3aal9te0012094ukg8vap1r","category_id":"cj3aal9pb0003094uts32741o","_id":"cj3aal9tr0018094u7wdvwrt0"},{"post_id":"cj3aal9tk0015094u6mh63t2e","category_id":"cj3aal9pb0003094uts32741o","_id":"cj3aal9tx001c094unkg3cu5c"},{"post_id":"cj3aal9tp0017094u7fqjncz3","category_id":"cj3aal9pb0003094uts32741o","_id":"cj3aal9u3001g094ufb32i14v"},{"post_id":"cj3aal9ty001d094u4htc2lvd","category_id":"cj3aal9pb0003094uts32741o","_id":"cj3aal9uc001m094uz6po4oh4"},{"post_id":"cj3aal9u3001h094umcvbxlq8","category_id":"cj3aal9pb0003094uts32741o","_id":"cj3aal9un001p094uk0meu2d4"},{"post_id":"cj3aal9u7001k094u5q7rkzse","category_id":"cj3aal9pb0003094uts32741o","_id":"cj3aal9ux001s094ut3mfw9t0"},{"post_id":"cj3aal9ts0019094uq9ulnfy6","category_id":"cj3aal9u2001f094urxn0gt8q","_id":"cj3aal9v3001w094u79q4cwr4"},{"post_id":"cj3aal9uc001n094uvxodhpht","category_id":"cj3aal9pb0003094uts32741o","_id":"cj3aal9v4001x094uxltzl6cb"},{"post_id":"cj3aal9ur001r094uxkdi77n4","category_id":"cj3aal9pb0003094uts32741o","_id":"cj3aal9v6001z094u9nf4xu7w"},{"post_id":"cj3aal9uy001u094uphiygzgi","category_id":"cj3aal9pb0003094uts32741o","_id":"cj3aal9v60021094usmfnfxff"}],"PostTag":[{"post_id":"cj3aal9on0000094udaohbdch","tag_id":"cj3aal9p80002094unvc3d4hk","_id":"cj3aal9pg0004094ui0ggidde"},{"post_id":"cj3aal9rc0006094ux3d2tgiu","tag_id":"cj3aal9p80002094unvc3d4hk","_id":"cj3aal9rn0008094ufehk5ama"},{"post_id":"cj3aal9rk0007094uut3owuto","tag_id":"cj3aal9p80002094unvc3d4hk","_id":"cj3aal9rv000a094upksuj4lu"},{"post_id":"cj3aal9rn0009094uhfbokcx3","tag_id":"cj3aal9p80002094unvc3d4hk","_id":"cj3aal9rz000d094ua9p2nn0z"},{"post_id":"cj3aal9rw000c094uowcblaib","tag_id":"cj3aal9p80002094unvc3d4hk","_id":"cj3aal9s9000g094u9znox3md"},{"post_id":"cj3aal9rz000f094ujh7elgph","tag_id":"cj3aal9p80002094unvc3d4hk","_id":"cj3aal9sm000j094uiip8dabm"},{"post_id":"cj3aal9sa000i094ux5th9exl","tag_id":"cj3aal9p80002094unvc3d4hk","_id":"cj3aal9sq000m094unbsjyrts"},{"post_id":"cj3aal9sn000l094ur1qvzisy","tag_id":"cj3aal9p80002094unvc3d4hk","_id":"cj3aal9su000p094uu53fhpy2"},{"post_id":"cj3aal9sr000o094u8h5710u5","tag_id":"cj3aal9p80002094unvc3d4hk","_id":"cj3aal9t0000s094uq064s2uh"},{"post_id":"cj3aal9sw000r094uhap299s2","tag_id":"cj3aal9p80002094unvc3d4hk","_id":"cj3aal9t4000v094uq0h5ad22"},{"post_id":"cj3aal9tp0017094u7fqjncz3","tag_id":"cj3aal9t9000y094uo8w27kr4","_id":"cj3aal9tx001b094u1mz6vszo"},{"post_id":"cj3aal9tp0017094u7fqjncz3","tag_id":"cj3aal9th0013094uxpo6d6xc","_id":"cj3aal9u1001e094utev9zjb9"},{"post_id":"cj3aal9t1000u094uvf9x8xjp","tag_id":"cj3aal9t9000y094uo8w27kr4","_id":"cj3aal9u6001j094u86g50v4r"},{"post_id":"cj3aal9t1000u094uvf9x8xjp","tag_id":"cj3aal9th0013094uxpo6d6xc","_id":"cj3aal9ub001l094umwk2mqa6"},{"post_id":"cj3aal9t5000x094uwz4w6g0h","tag_id":"cj3aal9t9000y094uo8w27kr4","_id":"cj3aal9uq001q094u9aodenh9"},{"post_id":"cj3aal9t5000x094uwz4w6g0h","tag_id":"cj3aal9th0013094uxpo6d6xc","_id":"cj3aal9ux001t094uswkr5t1m"},{"post_id":"cj3aal9tb0010094u0atehkwf","tag_id":"cj3aal9t9000y094uo8w27kr4","_id":"cj3aal9v60020094u64wx9lz9"},{"post_id":"cj3aal9tb0010094u0atehkwf","tag_id":"cj3aal9th0013094uxpo6d6xc","_id":"cj3aal9v60022094ure0gj9ci"},{"post_id":"cj3aal9te0012094ukg8vap1r","tag_id":"cj3aal9t9000y094uo8w27kr4","_id":"cj3aal9v80024094u04h1mn9w"},{"post_id":"cj3aal9te0012094ukg8vap1r","tag_id":"cj3aal9th0013094uxpo6d6xc","_id":"cj3aal9v80025094uc8yf4usv"},{"post_id":"cj3aal9tk0015094u6mh63t2e","tag_id":"cj3aal9t9000y094uo8w27kr4","_id":"cj3aal9vb0027094uon4prhk3"},{"post_id":"cj3aal9tk0015094u6mh63t2e","tag_id":"cj3aal9th0013094uxpo6d6xc","_id":"cj3aal9vb0028094ukzvfxezx"},{"post_id":"cj3aal9ts0019094uq9ulnfy6","tag_id":"cj3aal9v80026094u4ts07t6t","_id":"cj3aal9vc002a094u26vqjl2j"},{"post_id":"cj3aal9ty001d094u4htc2lvd","tag_id":"cj3aal9vb0029094uoocf1nvn","_id":"cj3aal9vh002c094uxeaz754z"},{"post_id":"cj3aal9u3001h094umcvbxlq8","tag_id":"cj3aal9vf002b094uujqly60e","_id":"cj3aal9vi002e094uqu1e11s4"},{"post_id":"cj3aal9u3001h094umcvbxlq8","tag_id":"cj3aal9p80002094unvc3d4hk","_id":"cj3aal9vi002f094uqnek1xfm"},{"post_id":"cj3aal9u7001k094u5q7rkzse","tag_id":"cj3aal9vf002b094uujqly60e","_id":"cj3aal9vj002h094ugjhuwh25"},{"post_id":"cj3aal9u7001k094u5q7rkzse","tag_id":"cj3aal9p80002094unvc3d4hk","_id":"cj3aal9vk002i094uz724foui"},{"post_id":"cj3aal9uc001n094uvxodhpht","tag_id":"cj3aal9vi002g094u4vzh61cv","_id":"cj3aal9vl002k094udcx8j0gp"},{"post_id":"cj3aal9ur001r094uxkdi77n4","tag_id":"cj3aal9vf002b094uujqly60e","_id":"cj3aal9vs002n094uf2kavgr3"},{"post_id":"cj3aal9ur001r094uxkdi77n4","tag_id":"cj3aal9vm002l094u877aspz6","_id":"cj3aal9vs002o094u3tg5rhoo"},{"post_id":"cj3aal9uy001u094uphiygzgi","tag_id":"cj3aal9vf002b094uujqly60e","_id":"cj3aal9vt002p094u5si22ur4"},{"post_id":"cj3aal9uy001u094uphiygzgi","tag_id":"cj3aal9p80002094unvc3d4hk","_id":"cj3aal9vt002q094uiebaxop5"}],"Tag":[{"name":"c++","_id":"cj3aal9p80002094unvc3d4hk"},{"name":"leetcode","_id":"cj3aal9t9000y094uo8w27kr4"},{"name":"数据结构与算法","_id":"cj3aal9th0013094uxpo6d6xc"},{"name":"随笔","_id":"cj3aal9v80026094u4ts07t6t"},{"name":"hexo","_id":"cj3aal9vb0029094uoocf1nvn"},{"name":"OpenCV基础","_id":"cj3aal9vf002b094uujqly60e"},{"name":"Linux","_id":"cj3aal9vi002g094u4vzh61cv"},{"name":"VS2010","_id":"cj3aal9vm002l094u877aspz6"}]}}